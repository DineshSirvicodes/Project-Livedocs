"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical";
exports.ids = ["vendor-chunks/@lexical"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $generateJSONFromSelectedNodes: () => (/* binding */ $generateJSONFromSelectedNodes),\n/* harmony export */   $generateNodesFromSerializedNodes: () => (/* binding */ $generateNodesFromSerializedNodes),\n/* harmony export */   $getHtmlContent: () => (/* binding */ $getHtmlContent),\n/* harmony export */   $getLexicalContent: () => (/* binding */ $getLexicalContent),\n/* harmony export */   $insertDataTransferForPlainText: () => (/* binding */ $insertDataTransferForPlainText),\n/* harmony export */   $insertDataTransferForRichText: () => (/* binding */ $insertDataTransferForRichText),\n/* harmony export */   $insertGeneratedNodes: () => (/* binding */ $insertGeneratedNodes),\n/* harmony export */   copyToClipboard: () => (/* binding */ copyToClipboard)\n/* harmony export */ });\n/* harmony import */ var _lexical_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/html */ \"(ssr)/./node_modules/@lexical/html/LexicalHtml.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return (0,_lexical_html__WEBPACK_IMPORTED_MODULE_1__.$generateHtmlFromNodes)(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @returns\n */\nfunction $getLexicalContent(editor) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = (0,_lexical_html__WEBPACK_IMPORTED_MODULE_1__.$generateNodesFromDOM)(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTabNode)()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$cloneWithProperties)(currentNode);\n    clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone) && selection !== null ? (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$sliceSelectedTextNodeContent)(selection, clone) : clone;\n    target = clone;\n  }\n  const children = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$parseSerializedNode)(serializedNode);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$addNodeStyle)(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.COPY_COMMAND, secondEvent => {\n      if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_3__.objectKlassEquals)(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = getDOMSelection(editor._window);\n  if (!domSelection) {\n    return false;\n  }\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n  if (anchorDOM !== null && focusDOM !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isSelectionWithinEditor)(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY2xpcGJvYXJkL0xleGljYWxDbGlwYm9hcmQuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEU7QUFDMEI7QUFDckQ7QUFDaU07O0FBRXBQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLDBEQUFpQjtBQUN2QjtBQUNBO0FBQ0EsU0FBUyxxRUFBc0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sMERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0VBQXFCO0FBQ3pDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDLGlDQUFpQyxzREFBYTtBQUM5QyxZQUFZLDBEQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osMENBQTBDLHVEQUFjO0FBQ3hELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkVBQXdDO0FBQ3RFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBO0FBQ0EsTUFBTSx1REFBYztBQUNwQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFjO0FBQ3RDO0FBQ0E7QUFDQSxnQkFBZ0Isd0VBQW9CO0FBQ3BDLFlBQVksb0RBQVcsZ0NBQWdDLGlGQUE2QjtBQUNwRjtBQUNBO0FBQ0EsbUJBQW1CLHVEQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0RBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLDBCQUEwQix1REFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBLGlCQUFpQiw2REFBb0I7QUFDckMsUUFBUSxvREFBVztBQUNuQixNQUFNLGlFQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaURBQVk7QUFDOUQsVUFBVSxpRUFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFLDhEQUF5QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdFQUF1QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl2ZWRvY3MvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY2xpcGJvYXJkL0xleGljYWxDbGlwYm9hcmQuZGV2Lm1qcz8wYzQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGdlbmVyYXRlSHRtbEZyb21Ob2RlcywgJGdlbmVyYXRlTm9kZXNGcm9tRE9NIH0gZnJvbSAnQGxleGljYWwvaHRtbCc7XG5pbXBvcnQgeyAkYWRkTm9kZVN0eWxlLCAkY2xvbmVXaXRoUHJvcGVydGllcywgJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQgfSBmcm9tICdAbGV4aWNhbC9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgb2JqZWN0S2xhc3NFcXVhbHMgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGNyZWF0ZVRhYk5vZGUsIFNFTEVDVElPTl9JTlNFUlRfQ0xJUEJPQVJEX05PREVTX0NPTU1BTkQsICRnZXRSb290LCAkcGFyc2VTZXJpYWxpemVkTm9kZSwgJGlzVGV4dE5vZGUsIENPUFlfQ09NTUFORCwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCwgaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IsICRpc0VsZW1lbnROb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IGdldERPTVNlbGVjdGlvbiA9IHRhcmdldFdpbmRvdyA9PiBDQU5fVVNFX0RPTSA/ICh0YXJnZXRXaW5kb3cgfHwgd2luZG93KS5nZXRTZWxlY3Rpb24oKSA6IG51bGw7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgKmN1cnJlbnRseSBzZWxlY3RlZCogTGV4aWNhbCBjb250ZW50IGFzIGFuIEhUTUwgc3RyaW5nLCByZWx5aW5nIG9uIHRoZVxuICogbG9naWMgZGVmaW5lZCBpbiB0aGUgZXhwb3J0RE9NIG1ldGhvZHMgb24gdGhlIExleGljYWxOb2RlIGNsYXNzZXMuIE5vdGUgdGhhdFxuICogdGhpcyB3aWxsIG5vdCByZXR1cm4gdGhlIEhUTUwgY29udGVudCBvZiB0aGUgZW50aXJlIGVkaXRvciAodW5sZXNzIGFsbCB0aGUgY29udGVudCBpcyBpbmNsdWRlZFxuICogaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uKS5cbiAqXG4gKiBAcGFyYW0gZWRpdG9yIC0gTGV4aWNhbEVkaXRvciBpbnN0YW5jZSB0byBnZXQgSFRNTCBjb250ZW50IGZyb21cbiAqIEByZXR1cm5zIGEgc3RyaW5nIG9mIEhUTUwgY29udGVudFxuICovXG5mdW5jdGlvbiAkZ2V0SHRtbENvbnRlbnQoZWRpdG9yKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKHNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHZhbGlkIExleGljYWxTZWxlY3Rpb25gKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlbid0IHNlbGVjdGVkIGFueXRoaW5nXG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8IHNlbGVjdGlvbi5nZXROb2RlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gJGdlbmVyYXRlSHRtbEZyb21Ob2RlcyhlZGl0b3IsIHNlbGVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgKmN1cnJlbnRseSBzZWxlY3RlZCogTGV4aWNhbCBjb250ZW50IGFzIGEgSlNPTiBzdHJpbmcsIHJlbHlpbmcgb24gdGhlXG4gKiBsb2dpYyBkZWZpbmVkIGluIHRoZSBleHBvcnRKU09OIG1ldGhvZHMgb24gdGhlIExleGljYWxOb2RlIGNsYXNzZXMuIE5vdGUgdGhhdFxuICogdGhpcyB3aWxsIG5vdCByZXR1cm4gdGhlIEpTT04gY29udGVudCBvZiB0aGUgZW50aXJlIGVkaXRvciAodW5sZXNzIGFsbCB0aGUgY29udGVudCBpcyBpbmNsdWRlZFxuICogaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uKS5cbiAqXG4gKiBAcGFyYW0gZWRpdG9yICAtIExleGljYWxFZGl0b3IgaW5zdGFuY2UgdG8gZ2V0IHRoZSBKU09OIGNvbnRlbnQgZnJvbVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gJGdldExleGljYWxDb250ZW50KGVkaXRvcikge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB2YWxpZCBMZXhpY2FsU2VsZWN0aW9uYCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UgaGF2ZW4ndCBzZWxlY3RlZCBhbnl0aGluZ1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCBzZWxlY3Rpb24uZ2V0Tm9kZXMoKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJGdlbmVyYXRlSlNPTkZyb21TZWxlY3RlZE5vZGVzKGVkaXRvciwgc2VsZWN0aW9uKSk7XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gaW5zZXJ0IGNvbnRlbnQgb2YgdGhlIG1pbWUtdHlwZXMgdGV4dC9wbGFpbiBvciB0ZXh0L3VyaS1saXN0IGZyb21cbiAqIHRoZSBwcm92aWRlZCBEYXRhVHJhbnNmZXIgb2JqZWN0IGludG8gdGhlIGVkaXRvciBhdCB0aGUgcHJvdmlkZWQgc2VsZWN0aW9uLlxuICogdGV4dC91cmktbGlzdCBpcyBvbmx5IHVzZWQgaWYgdGV4dC9wbGFpbiBpcyBub3QgYWxzbyBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0gZGF0YVRyYW5zZmVyIGFuIG9iamVjdCBjb25mb3JtaW5nIHRvIHRoZSBbRGF0YVRyYW5zZmVyIGludGVyZmFjZV0gKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RuZC5odG1sI3RoZS1kYXRhdHJhbnNmZXItaW50ZXJmYWNlKVxuICogQHBhcmFtIHNlbGVjdGlvbiB0aGUgc2VsZWN0aW9uIHRvIHVzZSBhcyB0aGUgaW5zZXJ0aW9uIHBvaW50IGZvciB0aGUgY29udGVudCBpbiB0aGUgRGF0YVRyYW5zZmVyIG9iamVjdFxuICovXG5mdW5jdGlvbiAkaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUGxhaW5UZXh0KGRhdGFUcmFuc2Zlciwgc2VsZWN0aW9uKSB7XG4gIGNvbnN0IHRleHQgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9wbGFpbicpIHx8IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3VyaS1saXN0Jyk7XG4gIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICBzZWxlY3Rpb24uaW5zZXJ0UmF3VGV4dCh0ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGluc2VydCBjb250ZW50IG9mIHRoZSBtaW1lLXR5cGVzIGFwcGxpY2F0aW9uL3gtbGV4aWNhbC1lZGl0b3IsIHRleHQvaHRtbCxcbiAqIHRleHQvcGxhaW4sIG9yIHRleHQvdXJpLWxpc3QgKGluIGRlc2NlbmRpbmcgb3JkZXIgb2YgcHJpb3JpdHkpIGZyb20gdGhlIHByb3ZpZGVkIERhdGFUcmFuc2ZlclxuICogb2JqZWN0IGludG8gdGhlIGVkaXRvciBhdCB0aGUgcHJvdmlkZWQgc2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSBkYXRhVHJhbnNmZXIgYW4gb2JqZWN0IGNvbmZvcm1pbmcgdG8gdGhlIFtEYXRhVHJhbnNmZXIgaW50ZXJmYWNlXSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG5kLmh0bWwjdGhlLWRhdGF0cmFuc2Zlci1pbnRlcmZhY2UpXG4gKiBAcGFyYW0gc2VsZWN0aW9uIHRoZSBzZWxlY3Rpb24gdG8gdXNlIGFzIHRoZSBpbnNlcnRpb24gcG9pbnQgZm9yIHRoZSBjb250ZW50IGluIHRoZSBEYXRhVHJhbnNmZXIgb2JqZWN0XG4gKiBAcGFyYW0gZWRpdG9yIHRoZSBMZXhpY2FsRWRpdG9yIHRoZSBjb250ZW50IGlzIGJlaW5nIGluc2VydGVkIGludG8uXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dChkYXRhVHJhbnNmZXIsIHNlbGVjdGlvbiwgZWRpdG9yKSB7XG4gIGNvbnN0IGxleGljYWxTdHJpbmcgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgnYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvcicpO1xuICBpZiAobGV4aWNhbFN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShsZXhpY2FsU3RyaW5nKTtcbiAgICAgIGlmIChwYXlsb2FkLm5hbWVzcGFjZSA9PT0gZWRpdG9yLl9jb25maWcubmFtZXNwYWNlICYmIEFycmF5LmlzQXJyYXkocGF5bG9hZC5ub2RlcykpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSAkZ2VuZXJhdGVOb2Rlc0Zyb21TZXJpYWxpemVkTm9kZXMocGF5bG9hZC5ub2Rlcyk7XG4gICAgICAgIHJldHVybiAkaW5zZXJ0R2VuZXJhdGVkTm9kZXMoZWRpdG9yLCBub2Rlcywgc2VsZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAvLyBGYWlsIHNpbGVudGx5LlxuICAgIH1cbiAgfVxuICBjb25zdCBodG1sU3RyaW5nID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvaHRtbCcpO1xuICBpZiAoaHRtbFN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICBjb25zdCBkb20gPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKGh0bWxTdHJpbmcsICd0ZXh0L2h0bWwnKTtcbiAgICAgIGNvbnN0IG5vZGVzID0gJGdlbmVyYXRlTm9kZXNGcm9tRE9NKGVkaXRvciwgZG9tKTtcbiAgICAgIHJldHVybiAkaW5zZXJ0R2VuZXJhdGVkTm9kZXMoZWRpdG9yLCBub2Rlcywgc2VsZWN0aW9uKTtcbiAgICB9IGNhdGNoIChfdW51c2VkMikge1xuICAgICAgLy8gRmFpbCBzaWxlbnRseS5cbiAgICB9XG4gIH1cblxuICAvLyBNdWx0aS1saW5lIHBsYWluIHRleHQgaW4gcmljaCB0ZXh0IG1vZGUgcGFzdGVkIGFzIHNlcGFyYXRlIHBhcmFncmFwaHNcbiAgLy8gaW5zdGVhZCBvZiBzaW5nbGUgcGFyYWdyYXBoIHdpdGggbGluZWJyZWFrcy5cbiAgLy8gV2Via2l0LXNwZWNpZmljOiBTdXBwb3J0cyByZWFkICd0ZXh0L3VyaS1saXN0JyBpbiBjbGlwYm9hcmQuXG4gIGNvbnN0IHRleHQgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9wbGFpbicpIHx8IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3VyaS1saXN0Jyk7XG4gIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgcGFydHMgPSB0ZXh0LnNwbGl0KC8oXFxyP1xcbnxcXHQpLyk7XG4gICAgICBpZiAocGFydHNbcGFydHMubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgaWYgKHBhcnQgPT09ICdcXG4nIHx8IHBhcnQgPT09ICdcXHJcXG4nKSB7XG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9uLmluc2VydFBhcmFncmFwaCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24uaW5zZXJ0Tm9kZXMoWyRjcmVhdGVUYWJOb2RlKCldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFNlbGVjdGlvbi5pbnNlcnRUZXh0KHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uaW5zZXJ0UmF3VGV4dCh0ZXh0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbnNlcnRzIExleGljYWwgbm9kZXMgaW50byB0aGUgZWRpdG9yIHVzaW5nIGRpZmZlcmVudCBzdHJhdGVnaWVzIGRlcGVuZGluZyBvblxuICogc29tZSBzaW1wbGUgc2VsZWN0aW9uLWJhc2VkIGhldXJpc3RpY3MuIElmIHlvdSdyZSBsb29raW5nIGZvciBhIGdlbmVyaWMgd2F5IHRvXG4gKiB0byBpbnNlcnQgbm9kZXMgaW50byB0aGUgZWRpdG9yIGF0IGEgc3BlY2lmaWMgc2VsZWN0aW9uIHBvaW50LCB5b3UgcHJvYmFibHkgd2FudFxuICoge0BsaW5rIGxleGljYWwuJGluc2VydE5vZGVzfVxuICpcbiAqIEBwYXJhbSBlZGl0b3IgTGV4aWNhbEVkaXRvciBpbnN0YW5jZSB0byBpbnNlcnQgdGhlIG5vZGVzIGludG8uXG4gKiBAcGFyYW0gbm9kZXMgVGhlIG5vZGVzIHRvIGluc2VydC5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gVGhlIHNlbGVjdGlvbiB0byBpbnNlcnQgdGhlIG5vZGVzIGludG8uXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnRHZW5lcmF0ZWROb2RlcyhlZGl0b3IsIG5vZGVzLCBzZWxlY3Rpb24pIHtcbiAgaWYgKCFlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9JTlNFUlRfQ0xJUEJPQVJEX05PREVTX0NPTU1BTkQsIHtcbiAgICBub2RlcyxcbiAgICBzZWxlY3Rpb25cbiAgfSkpIHtcbiAgICBzZWxlY3Rpb24uaW5zZXJ0Tm9kZXMobm9kZXMpO1xuICB9XG4gIHJldHVybjtcbn1cbmZ1bmN0aW9uIGV4cG9ydE5vZGVUb0pTT04obm9kZSkge1xuICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IG5vZGUuZXhwb3J0SlNPTigpO1xuICBjb25zdCBub2RlQ2xhc3MgPSBub2RlLmNvbnN0cnVjdG9yO1xuICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSAhPT0gbm9kZUNsYXNzLmdldFR5cGUoKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsTm9kZTogTm9kZSAke25vZGVDbGFzcy5uYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgLmV4cG9ydEpTT04oKS5gKTtcbiAgICB9XG4gIH1cbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZENoaWxkcmVuID0gc2VyaWFsaXplZE5vZGUuY2hpbGRyZW47XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNlcmlhbGl6ZWRDaGlsZHJlbikpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7bm9kZUNsYXNzLm5hbWV9IGlzIGFuIGVsZW1lbnQgYnV0IC5leHBvcnRKU09OKCkgZG9lcyBub3QgaGF2ZSBhIGNoaWxkcmVuIGFycmF5LmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZE5vZGU7XG59XG5mdW5jdGlvbiAkYXBwZW5kTm9kZXNUb0pTT04oZWRpdG9yLCBzZWxlY3Rpb24sIGN1cnJlbnROb2RlLCB0YXJnZXRBcnJheSA9IFtdKSB7XG4gIGxldCBzaG91bGRJbmNsdWRlID0gc2VsZWN0aW9uICE9PSBudWxsID8gY3VycmVudE5vZGUuaXNTZWxlY3RlZChzZWxlY3Rpb24pIDogdHJ1ZTtcbiAgY29uc3Qgc2hvdWxkRXhjbHVkZSA9ICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiBjdXJyZW50Tm9kZS5leGNsdWRlRnJvbUNvcHkoJ2h0bWwnKTtcbiAgbGV0IHRhcmdldCA9IGN1cnJlbnROb2RlO1xuICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgbGV0IGNsb25lID0gJGNsb25lV2l0aFByb3BlcnRpZXMoY3VycmVudE5vZGUpO1xuICAgIGNsb25lID0gJGlzVGV4dE5vZGUoY2xvbmUpICYmIHNlbGVjdGlvbiAhPT0gbnVsbCA/ICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50KHNlbGVjdGlvbiwgY2xvbmUpIDogY2xvbmU7XG4gICAgdGFyZ2V0ID0gY2xvbmU7XG4gIH1cbiAgY29uc3QgY2hpbGRyZW4gPSAkaXNFbGVtZW50Tm9kZSh0YXJnZXQpID8gdGFyZ2V0LmdldENoaWxkcmVuKCkgOiBbXTtcbiAgY29uc3Qgc2VyaWFsaXplZE5vZGUgPSBleHBvcnROb2RlVG9KU09OKHRhcmdldCk7XG5cbiAgLy8gVE9ETzogVGV4dE5vZGUgY2FsbHMgZ2V0VGV4dENvbnRlbnQoKSAoTk9UIG5vZGUuX190ZXh0KSB3aXRoaW4gaXQncyBleHBvcnRKU09OIG1ldGhvZFxuICAvLyB3aGljaCB1c2VzIGdldExhdGVzdCgpIHRvIGdldCB0aGUgdGV4dCBmcm9tIHRoZSBvcmlnaW5hbCBub2RlIHdpdGggdGhlIHNhbWUga2V5LlxuICAvLyBUaGlzIGlzIGEgZGVlcGVyIGlzc3VlIHdpdGggdGhlIHdvcmQgXCJjbG9uZVwiIGhlcmUsIGl0J3Mgc3RpbGwgYSByZWZlcmVuY2UgdG8gdGhlXG4gIC8vIHNhbWUgbm9kZSBhcyBmYXIgYXMgdGhlIExleGljYWxFZGl0b3IgaXMgY29uY2VybmVkIHNpbmNlIGl0IHNoYXJlcyBhIGtleS5cbiAgLy8gV2UgbmVlZCBhIHdheSB0byBjcmVhdGUgYSBjbG9uZSBvZiBhIE5vZGUgaW4gbWVtb3J5IHdpdGggaXQncyBvd24ga2V5LCBidXRcbiAgLy8gdW50aWwgdGhlbiB0aGlzIGhhY2sgd2lsbCB3b3JrIGZvciB0aGUgc2VsZWN0ZWQgdGV4dCBleHRyYWN0IHVzZSBjYXNlLlxuICBpZiAoJGlzVGV4dE5vZGUodGFyZ2V0KSkge1xuICAgIGNvbnN0IHRleHQgPSB0YXJnZXQuX190ZXh0O1xuICAgIC8vIElmIGFuIHVuY29sbGFwc2VkIHNlbGVjdGlvbiBlbmRzIG9yIHN0YXJ0cyBhdCB0aGUgZW5kIG9mIGEgbGluZSBvZiBzcGVjaWFsaXplZCxcbiAgICAvLyBUZXh0Tm9kZXMsIHN1Y2ggYXMgY29kZSB0b2tlbnMsIHdlIHdpbGwgZ2V0IGEgJ2JsYW5rJyBUZXh0Tm9kZSBoZXJlLCBpLmUuLCBvbmVcbiAgICAvLyB3aXRoIHRleHQgb2YgbGVuZ3RoIDAuIFdlIGRvbid0IHdhbnQgdGhpcywgaXQgbWFrZXMgYSBjb25mdXNpbmcgbWVzcy4gUmVzZXQhXG4gICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgc2VyaWFsaXplZE5vZGUudGV4dCA9IHRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZEluY2x1ZGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IHNob3VsZEluY2x1ZGVDaGlsZCA9ICRhcHBlbmROb2Rlc1RvSlNPTihlZGl0b3IsIHNlbGVjdGlvbiwgY2hpbGROb2RlLCBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbik7XG4gICAgaWYgKCFzaG91bGRJbmNsdWRlICYmICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiBzaG91bGRJbmNsdWRlQ2hpbGQgJiYgY3VycmVudE5vZGUuZXh0cmFjdFdpdGhDaGlsZChjaGlsZE5vZGUsIHNlbGVjdGlvbiwgJ2Nsb25lJykpIHtcbiAgICAgIHNob3VsZEluY2x1ZGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoc2hvdWxkSW5jbHVkZSAmJiAhc2hvdWxkRXhjbHVkZSkge1xuICAgIHRhcmdldEFycmF5LnB1c2goc2VyaWFsaXplZE5vZGUpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VyaWFsaXplZE5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZENoaWxkTm9kZSA9IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuW2ldO1xuICAgICAgdGFyZ2V0QXJyYXkucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNob3VsZEluY2x1ZGU7XG59XG5cbi8vIFRPRE8gd2h5ICQgZnVuY3Rpb24gd2l0aCBFZGl0b3IgaW5zdGFuY2U/XG4vKipcbiAqIEdldHMgdGhlIExleGljYWwgSlNPTiBvZiB0aGUgbm9kZXMgaW5zaWRlIHRoZSBwcm92aWRlZCBTZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIGVkaXRvciBMZXhpY2FsRWRpdG9yIHRvIGdldCB0aGUgSlNPTiBjb250ZW50IGZyb20uXG4gKiBAcGFyYW0gc2VsZWN0aW9uIFNlbGVjdGlvbiB0byBnZXQgdGhlIEpTT04gY29udGVudCBmcm9tLlxuICogQHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGVkaXRvciBuYW1lc3BhY2UgYW5kIGEgbGlzdCBvZiBzZXJpYWxpemFibGUgbm9kZXMgYXMgSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiAkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXMoZWRpdG9yLCBzZWxlY3Rpb24pIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gIGNvbnN0IHRvcExldmVsQ2hpbGRyZW4gPSByb290LmdldENoaWxkcmVuKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9wTGV2ZWxDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvcExldmVsTm9kZSA9IHRvcExldmVsQ2hpbGRyZW5baV07XG4gICAgJGFwcGVuZE5vZGVzVG9KU09OKGVkaXRvciwgc2VsZWN0aW9uLCB0b3BMZXZlbE5vZGUsIG5vZGVzKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWVzcGFjZTogZWRpdG9yLl9jb25maWcubmFtZXNwYWNlLFxuICAgIG5vZGVzXG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgdGFrZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb25mb3JtaW5nIHRvIHRoZSBCYXNlU2VyYWxpemVkTm9kZSBpbnRlcmZhY2UgYW5kIHJldHVybnNcbiAqIGFuIEFycmF5IGNvbnRhaW5pbmcgaW5zdGFuY2VzIG9mIHRoZSBjb3JyZXNwb25kaW5nIExleGljYWxOb2RlIGNsYXNzZXMgcmVnaXN0ZXJlZCBvbiB0aGUgZWRpdG9yLlxuICogTm9ybWFsbHksIHlvdSdkIGdldCBhbiBBcnJheSBvZiBCYXNlU2VyaWFsaXplZCBub2RlcyBmcm9tIHtAbGluayAkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXN9XG4gKlxuICogQHBhcmFtIHNlcmlhbGl6ZWROb2RlcyBhbiBBcnJheSBvZiBvYmplY3RzIGNvbmZvcm1pbmcgdG8gdGhlIEJhc2VTZXJpYWxpemVkTm9kZSBpbnRlcmZhY2UuXG4gKiBAcmV0dXJucyBhbiBBcnJheSBvZiBMZXhpY2FsIE5vZGUgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gJGdlbmVyYXRlTm9kZXNGcm9tU2VyaWFsaXplZE5vZGVzKHNlcmlhbGl6ZWROb2Rlcykge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcmlhbGl6ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gc2VyaWFsaXplZE5vZGVzW2ldO1xuICAgIGNvbnN0IG5vZGUgPSAkcGFyc2VTZXJpYWxpemVkTm9kZShzZXJpYWxpemVkTm9kZSk7XG4gICAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAkYWRkTm9kZVN0eWxlKG5vZGUpO1xuICAgIH1cbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cbmNvbnN0IEVWRU5UX0xBVEVOQ1kgPSA1MDtcbmxldCBjbGlwYm9hcmRFdmVudFRpbWVvdXQgPSBudWxsO1xuXG4vLyBUT0RPIGN1c3RvbSBzZWxlY3Rpb25cbi8vIFRPRE8gcG90ZW50aWFsbHkgaGF2ZSBhIG5vZGUgY3VzdG9taXphYmxlIHZlcnNpb24gZm9yIHBsYWluIHRleHRcbi8qKlxuICogQ29waWVzIHRoZSBjb250ZW50IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB0byB0aGUgY2xpcGJvYXJkIGluXG4gKiB0ZXh0L3BsYWluLCB0ZXh0L2h0bWwsIGFuZCBhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yIChMZXhpY2FsIEpTT04pXG4gKiBmb3JtYXRzLlxuICpcbiAqIEBwYXJhbSBlZGl0b3IgdGhlIExleGljYWxFZGl0b3IgaW5zdGFuY2UgdG8gY29weSBjb250ZW50IGZyb21cbiAqIEBwYXJhbSBldmVudCB0aGUgbmF0aXZlIGJyb3dzZXIgQ2xpcGJvYXJkRXZlbnQgdG8gYWRkIHRoZSBjb250ZW50IHRvLlxuICogQHJldHVybnNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY29weVRvQ2xpcGJvYXJkKGVkaXRvciwgZXZlbnQpIHtcbiAgaWYgKGNsaXBib2FyZEV2ZW50VGltZW91dCAhPT0gbnVsbCkge1xuICAgIC8vIFByZXZlbnQgd2VpcmQgcmFjZSBjb25kaXRpb25zIHRoYXQgY2FuIGhhcHBlbiB3aGVuIHRoaXMgZnVuY3Rpb24gaXMgcnVuIG11bHRpcGxlIHRpbWVzXG4gICAgLy8gc3luY2hyb25vdXNseS4gSW4gdGhlIGZ1dHVyZSwgd2UgY2FuIGRvIGJldHRlciwgd2UgY2FuIGNhbmNlbC9vdmVycmlkZSB0aGUgcHJldmlvdXNseSBydW5uaW5nIGpvYi5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGV2ZW50ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICByZXNvbHZlKCRjb3B5VG9DbGlwYm9hcmRFdmVudChlZGl0b3IsIGV2ZW50KSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICBjb25zdCB3aW5kb3dEb2N1bWVudCA9IGVkaXRvci5fd2luZG93ID09IG51bGwgPyB3aW5kb3cuZG9jdW1lbnQgOiBlZGl0b3IuX3dpbmRvdy5kb2N1bWVudDtcbiAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcbiAgaWYgKHJvb3RFbGVtZW50ID09PSBudWxsIHx8IGRvbVNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBlbGVtZW50ID0gd2luZG93RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGZpeGVkOyB0b3A6IC0xMDAwcHg7JztcbiAgZWxlbWVudC5hcHBlbmQod2luZG93RG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyMnKSk7XG4gIHJvb3RFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgY29uc3QgcmFuZ2UgPSBuZXcgUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoZWxlbWVudCwgMCk7XG4gIHJhbmdlLnNldEVuZChlbGVtZW50LCAxKTtcbiAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICBkb21TZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDT1BZX0NPTU1BTkQsIHNlY29uZEV2ZW50ID0+IHtcbiAgICAgIGlmIChvYmplY3RLbGFzc0VxdWFscyhzZWNvbmRFdmVudCwgQ2xpcGJvYXJkRXZlbnQpKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgIGlmIChjbGlwYm9hcmRFdmVudFRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGNsaXBib2FyZEV2ZW50VGltZW91dCk7XG4gICAgICAgICAgY2xpcGJvYXJkRXZlbnRUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCRjb3B5VG9DbGlwYm9hcmRFdmVudChlZGl0b3IsIHNlY29uZEV2ZW50KSk7XG4gICAgICB9XG4gICAgICAvLyBCbG9jayB0aGUgZW50aXJlIGNvcHkgZmxvdyB3aGlsZSB3ZSB3YWl0IGZvciB0aGUgbmV4dCBDbGlwYm9hcmRFdmVudFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCk7XG4gICAgLy8gSWYgdGhlIGFib3ZlIGhhY2sgZXhlY0NvbW1hbmQgaGFjayB3b3JrcywgdGhpcyB0aW1lb3V0IGNvZGUgc2hvdWxkIG5ldmVyIGZpcmUuIE90aGVyd2lzZSxcbiAgICAvLyB0aGUgbGlzdGVuZXIgd2lsbCBiZSBxdWlja2x5IGZyZWVkIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHJldXNlIGl0IGFnYWluXG4gICAgY2xpcGJvYXJkRXZlbnRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgIGNsaXBib2FyZEV2ZW50VGltZW91dCA9IG51bGw7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICB9LCBFVkVOVF9MQVRFTkNZKTtcbiAgICB3aW5kb3dEb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gIH0pO1xufVxuXG4vLyBUT0RPIHNob3VsZG4ndCBwYXNzIGVkaXRvciAocGFzcyBuYW1lc3BhY2UgZGlyZWN0bHkpXG5mdW5jdGlvbiAkY29weVRvQ2xpcGJvYXJkRXZlbnQoZWRpdG9yLCBldmVudCkge1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuICBpZiAoIWRvbVNlbGVjdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhbmNob3JET00gPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgY29uc3QgZm9jdXNET00gPSBkb21TZWxlY3Rpb24uZm9jdXNOb2RlO1xuICBpZiAoYW5jaG9yRE9NICE9PSBudWxsICYmIGZvY3VzRE9NICE9PSBudWxsICYmICFpc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTSwgZm9jdXNET00pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGNvbnN0IGNsaXBib2FyZERhdGEgPSBldmVudC5jbGlwYm9hcmREYXRhO1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmIChjbGlwYm9hcmREYXRhID09PSBudWxsIHx8IHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBodG1sU3RyaW5nID0gJGdldEh0bWxDb250ZW50KGVkaXRvcik7XG4gIGNvbnN0IGxleGljYWxTdHJpbmcgPSAkZ2V0TGV4aWNhbENvbnRlbnQoZWRpdG9yKTtcbiAgbGV0IHBsYWluU3RyaW5nID0gJyc7XG4gIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICBwbGFpblN0cmluZyA9IHNlbGVjdGlvbi5nZXRUZXh0Q29udGVudCgpO1xuICB9XG4gIGlmIChodG1sU3RyaW5nICE9PSBudWxsKSB7XG4gICAgY2xpcGJvYXJkRGF0YS5zZXREYXRhKCd0ZXh0L2h0bWwnLCBodG1sU3RyaW5nKTtcbiAgfVxuICBpZiAobGV4aWNhbFN0cmluZyAhPT0gbnVsbCkge1xuICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YSgnYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvcicsIGxleGljYWxTdHJpbmcpO1xuICB9XG4gIGNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIHBsYWluU3RyaW5nKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCB7ICRnZW5lcmF0ZUpTT05Gcm9tU2VsZWN0ZWROb2RlcywgJGdlbmVyYXRlTm9kZXNGcm9tU2VyaWFsaXplZE5vZGVzLCAkZ2V0SHRtbENvbnRlbnQsICRnZXRMZXhpY2FsQ29udGVudCwgJGluc2VydERhdGFUcmFuc2ZlckZvclBsYWluVGV4dCwgJGluc2VydERhdGFUcmFuc2ZlckZvclJpY2hUZXh0LCAkaW5zZXJ0R2VuZXJhdGVkTm9kZXMsIGNvcHlUb0NsaXBib2FyZCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/dragon/LexicalDragon.dev.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/dragon/LexicalDragon.dev.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   registerDragonSupport: () => (/* binding */ registerDragonSupport)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n    const rootElement = editor.getRootElement();\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n    const data = event.data;\n    if (typeof data === 'string') {\n      let parsedData;\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;\n            editor.update(() => {\n              const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n              if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n                if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength;\n                    // If the offset is more than the end, make it the end\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n                if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize();\n                  // If the offset is more than the end, make it the end\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                }\n\n                // block the chrome extension from handling this event\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvZHJhZ29uL0xleGljYWxEcmFnb24uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RTs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzREFBYTtBQUM3QyxrQkFBa0IsMERBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdmVkb2NzLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2RyYWdvbi9MZXhpY2FsRHJhZ29uLmRldi5tanM/NjhhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7ICRnZXRTZWxlY3Rpb24sICRpc1JhbmdlU2VsZWN0aW9uLCAkaXNUZXh0Tm9kZSB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRHJhZ29uU3VwcG9ydChlZGl0b3IpIHtcbiAgY29uc3Qgb3JpZ2luID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbjtcbiAgY29uc3QgaGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICBpZiAoZXZlbnQub3JpZ2luICE9PSBvcmlnaW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gcm9vdEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgbGV0IHBhcnNlZERhdGE7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWREYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnNlZERhdGEgJiYgcGFyc2VkRGF0YS5wcm90b2NvbCA9PT0gJ251YW5yaWFfbWVzc2FnaW5nJyAmJiBwYXJzZWREYXRhLnR5cGUgPT09ICdyZXF1ZXN0Jykge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gcGFyc2VkRGF0YS5wYXlsb2FkO1xuICAgICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmZ1bmN0aW9uSWQgPT09ICdtYWtlQ2hhbmdlcycpIHtcbiAgICAgICAgICBjb25zdCBhcmdzID0gcGF5bG9hZC5hcmdzO1xuICAgICAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBbZWxlbWVudFN0YXJ0LCBlbGVtZW50TGVuZ3RoLCB0ZXh0LCBzZWxTdGFydCwgc2VsTGVuZ3RoLCBmb3JtYXRDb21tYW5kXSA9IGFyZ3M7XG4gICAgICAgICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICAgICAgICAgICAgbGV0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgICAgIGxldCBzZXRTZWxTdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHNldFNlbEVuZCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCRpc1RleHROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzZXQgaW5pdGlhbCBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50U3RhcnQgPj0gMCAmJiBlbGVtZW50TGVuZ3RoID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2VsU3RhcnQgPSBlbGVtZW50U3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHNldFNlbEVuZCA9IGVsZW1lbnRTdGFydCArIGVsZW1lbnRMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvZmZzZXQgaXMgbW9yZSB0aGFuIHRoZSBlbmQsIG1ha2UgaXQgdGhlIGVuZFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uc2V0VGV4dE5vZGVSYW5nZShhbmNob3JOb2RlLCBzZXRTZWxTdGFydCwgYW5jaG9yTm9kZSwgc2V0U2VsRW5kKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNldFNlbFN0YXJ0ICE9PSBzZXRTZWxFbmQgfHwgdGV4dCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5pbnNlcnRSYXdUZXh0KHRleHQpO1xuICAgICAgICAgICAgICAgICAgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgICAgICAgICAgICAgLy8gc2V0IGZpbmFsIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgc2V0U2VsU3RhcnQgPSBzZWxTdGFydDtcbiAgICAgICAgICAgICAgICAgIHNldFNlbEVuZCA9IHNlbFN0YXJ0ICsgc2VsTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yTm9kZVRleHRMZW5ndGggPSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9mZnNldCBpcyBtb3JlIHRoYW4gdGhlIGVuZCwgbWFrZSBpdCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICBzZXRTZWxTdGFydCA9IHNldFNlbFN0YXJ0ID4gYW5jaG9yTm9kZVRleHRMZW5ndGggPyBhbmNob3JOb2RlVGV4dExlbmd0aCA6IHNldFNlbFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgc2V0U2VsRW5kID0gc2V0U2VsRW5kID4gYW5jaG9yTm9kZVRleHRMZW5ndGggPyBhbmNob3JOb2RlVGV4dExlbmd0aCA6IHNldFNlbEVuZDtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5zZXRUZXh0Tm9kZVJhbmdlKGFuY2hvck5vZGUsIHNldFNlbFN0YXJ0LCBhbmNob3JOb2RlLCBzZXRTZWxFbmQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGJsb2NrIHRoZSBjaHJvbWUgZXh0ZW5zaW9uIGZyb20gaGFuZGxpbmcgdGhpcyBldmVudFxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlciwgdHJ1ZSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyLCB0cnVlKTtcbiAgfTtcbn1cblxuZXhwb3J0IHsgcmVnaXN0ZXJEcmFnb25TdXBwb3J0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/dragon/LexicalDragon.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/history/LexicalHistory.dev.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/history/LexicalHistory.dev.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEmptyHistoryState: () => (/* binding */ createEmptyHistoryState),\n/* harmony export */   registerHistory: () => (/* binding */ registerHistory)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n    if (dirtyElement !== undefined && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n  return nodes;\n}\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(nextSelection) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  }\n\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n    return OTHER;\n  }\n  const nextDirtyNode = dirtyNodes[0];\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevDirtyNode) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n  if (prevText === nextText) {\n    return OTHER;\n  }\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n  return OTHER;\n}\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n  const nextNode = nextEditorState._nodeMap.get(key);\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  let isDeletingLine = false;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(nextSelection)) {\n    isDeletingLine = prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  }\n  if (!isDeletingLine && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevNode) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextNode)) {\n    return prevNode.__type === nextNode.__type && prevNode.__text === nextNode.__text && prevNode.__mode === nextNode.__mode && prevNode.__detail === nextNode.__detail && prevNode.__style === nextNode.__style && prevNode.__format === nextNode.__format && prevNode.__parent === nextNode.__parent;\n  }\n  return false;\n}\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now();\n\n    // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n    if (tags.has('historic')) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has('history-push');\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has('history-merge');\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      }\n\n      // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n      return HISTORY_PUSH;\n    })();\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, true);\n    }\n    const historyStateEntry = redoStack.pop();\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, true);\n    }\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n      }\n      if (current !== null) {\n        undoStack.push({\n          ...current\n        });\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    }\n\n    // Else we merge\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n  const unregister = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, false);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  return unregister;\n}\n\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaGlzdG9yeS9MZXhpY2FsSGlzdG9yeS5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0M7QUFDNko7O0FBRTVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9EQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDBEQUFpQixvQkFBb0IsMERBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsb0RBQVc7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxvREFBVyxvQkFBb0Isb0RBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMERBQWlCLG1CQUFtQiwwREFBaUI7QUFDM0Q7QUFDQTtBQUNBLHlCQUF5QixvREFBVyxjQUFjLG9EQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscURBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxREFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscURBQWdCO0FBQzdDO0FBQ0E7QUFDQSw2QkFBNkIscURBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscURBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULCtCQUErQixxREFBZ0I7QUFDL0M7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkRBQWEsd0JBQXdCLGlEQUFZO0FBQ3RFO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQixpREFBWTtBQUNsRTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIseURBQW9CO0FBQzFFO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQiwwREFBcUI7QUFDM0U7QUFDQSwyQkFBMkIscURBQWdCO0FBQzNDLDJCQUEyQixxREFBZ0I7QUFDM0M7QUFDQSxHQUFHLEVBQUUsNERBQXVCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXZlZG9jcy8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9oaXN0b3J5L0xleGljYWxIaXN0b3J5LmRldi5tanM/OTNkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IG1lcmdlUmVnaXN0ZXIgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyBVTkRPX0NPTU1BTkQsIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SLCBSRURPX0NPTU1BTkQsIENMRUFSX0VESVRPUl9DT01NQU5ELCBDTEVBUl9ISVNUT1JZX0NPTU1BTkQsIENBTl9SRURPX0NPTU1BTkQsIENBTl9VTkRPX0NPTU1BTkQsICRpc1JhbmdlU2VsZWN0aW9uLCAkaXNUZXh0Tm9kZSwgJGlzUm9vdE5vZGUgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBISVNUT1JZX01FUkdFID0gMDtcbmNvbnN0IEhJU1RPUllfUFVTSCA9IDE7XG5jb25zdCBESVNDQVJEX0hJU1RPUllfQ0FORElEQVRFID0gMjtcbmNvbnN0IE9USEVSID0gMDtcbmNvbnN0IENPTVBPU0lOR19DSEFSQUNURVIgPSAxO1xuY29uc3QgSU5TRVJUX0NIQVJBQ1RFUl9BRlRFUl9TRUxFQ1RJT04gPSAyO1xuY29uc3QgREVMRVRFX0NIQVJBQ1RFUl9CRUZPUkVfU0VMRUNUSU9OID0gMztcbmNvbnN0IERFTEVURV9DSEFSQUNURVJfQUZURVJfU0VMRUNUSU9OID0gNDtcbmZ1bmN0aW9uIGdldERpcnR5Tm9kZXMoZWRpdG9yU3RhdGUsIGRpcnR5TGVhdmVzLCBkaXJ0eUVsZW1lbnRzKSB7XG4gIGNvbnN0IG5vZGVNYXAgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgZm9yIChjb25zdCBkaXJ0eUxlYWZLZXkgb2YgZGlydHlMZWF2ZXMpIHtcbiAgICBjb25zdCBkaXJ0eUxlYWYgPSBub2RlTWFwLmdldChkaXJ0eUxlYWZLZXkpO1xuICAgIGlmIChkaXJ0eUxlYWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9kZXMucHVzaChkaXJ0eUxlYWYpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IFtkaXJ0eUVsZW1lbnRLZXksIGludGVudGlvbmFsbHlNYXJrZWRBc0RpcnR5XSBvZiBkaXJ0eUVsZW1lbnRzKSB7XG4gICAgaWYgKCFpbnRlbnRpb25hbGx5TWFya2VkQXNEaXJ0eSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGRpcnR5RWxlbWVudCA9IG5vZGVNYXAuZ2V0KGRpcnR5RWxlbWVudEtleSk7XG4gICAgaWYgKGRpcnR5RWxlbWVudCAhPT0gdW5kZWZpbmVkICYmICEkaXNSb290Tm9kZShkaXJ0eUVsZW1lbnQpKSB7XG4gICAgICBub2Rlcy5wdXNoKGRpcnR5RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2Rlcztcbn1cbmZ1bmN0aW9uIGdldENoYW5nZVR5cGUocHJldkVkaXRvclN0YXRlLCBuZXh0RWRpdG9yU3RhdGUsIGRpcnR5TGVhdmVzU2V0LCBkaXJ0eUVsZW1lbnRzU2V0LCBpc0NvbXBvc2luZykge1xuICBpZiAocHJldkVkaXRvclN0YXRlID09PSBudWxsIHx8IGRpcnR5TGVhdmVzU2V0LnNpemUgPT09IDAgJiYgZGlydHlFbGVtZW50c1NldC5zaXplID09PSAwICYmICFpc0NvbXBvc2luZykge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuICBjb25zdCBuZXh0U2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBwcmV2RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIENPTVBPU0lOR19DSEFSQUNURVI7XG4gIH1cbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKSB8fCAhJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgfHwgIXByZXZTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCAhbmV4dFNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG4gIGNvbnN0IGRpcnR5Tm9kZXMgPSBnZXREaXJ0eU5vZGVzKG5leHRFZGl0b3JTdGF0ZSwgZGlydHlMZWF2ZXNTZXQsIGRpcnR5RWxlbWVudHNTZXQpO1xuICBpZiAoZGlydHlOb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cblxuICAvLyBDYXRjaGluZyB0aGUgY2FzZSB3aGVuIGluc2VydGluZyBuZXcgdGV4dCBub2RlIGludG8gYW4gZWxlbWVudCAoZS5nLiBmaXJzdCBjaGFyIGluIHBhcmFncmFwaC9saXN0KSxcbiAgLy8gb3IgYWZ0ZXIgZXhpc3Rpbmcgbm9kZS5cbiAgaWYgKGRpcnR5Tm9kZXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IG5leHROb2RlTWFwID0gbmV4dEVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICAgIGNvbnN0IG5leHRBbmNob3JOb2RlID0gbmV4dE5vZGVNYXAuZ2V0KG5leHRTZWxlY3Rpb24uYW5jaG9yLmtleSk7XG4gICAgY29uc3QgcHJldkFuY2hvck5vZGUgPSBuZXh0Tm9kZU1hcC5nZXQocHJldlNlbGVjdGlvbi5hbmNob3Iua2V5KTtcbiAgICBpZiAobmV4dEFuY2hvck5vZGUgJiYgcHJldkFuY2hvck5vZGUgJiYgIXByZXZFZGl0b3JTdGF0ZS5fbm9kZU1hcC5oYXMobmV4dEFuY2hvck5vZGUuX19rZXkpICYmICRpc1RleHROb2RlKG5leHRBbmNob3JOb2RlKSAmJiBuZXh0QW5jaG9yTm9kZS5fX3RleHQubGVuZ3RoID09PSAxICYmIG5leHRTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMSkge1xuICAgICAgcmV0dXJuIElOU0VSVF9DSEFSQUNURVJfQUZURVJfU0VMRUNUSU9OO1xuICAgIH1cbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cbiAgY29uc3QgbmV4dERpcnR5Tm9kZSA9IGRpcnR5Tm9kZXNbMF07XG4gIGNvbnN0IHByZXZEaXJ0eU5vZGUgPSBwcmV2RWRpdG9yU3RhdGUuX25vZGVNYXAuZ2V0KG5leHREaXJ0eU5vZGUuX19rZXkpO1xuICBpZiAoISRpc1RleHROb2RlKHByZXZEaXJ0eU5vZGUpIHx8ICEkaXNUZXh0Tm9kZShuZXh0RGlydHlOb2RlKSB8fCBwcmV2RGlydHlOb2RlLl9fbW9kZSAhPT0gbmV4dERpcnR5Tm9kZS5fX21vZGUpIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cbiAgY29uc3QgcHJldlRleHQgPSBwcmV2RGlydHlOb2RlLl9fdGV4dDtcbiAgY29uc3QgbmV4dFRleHQgPSBuZXh0RGlydHlOb2RlLl9fdGV4dDtcbiAgaWYgKHByZXZUZXh0ID09PSBuZXh0VGV4dCkge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuICBjb25zdCBuZXh0QW5jaG9yID0gbmV4dFNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IHByZXZBbmNob3IgPSBwcmV2U2VsZWN0aW9uLmFuY2hvcjtcbiAgaWYgKG5leHRBbmNob3Iua2V5ICE9PSBwcmV2QW5jaG9yLmtleSB8fCBuZXh0QW5jaG9yLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuICBjb25zdCBuZXh0QW5jaG9yT2Zmc2V0ID0gbmV4dEFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IHByZXZBbmNob3JPZmZzZXQgPSBwcmV2QW5jaG9yLm9mZnNldDtcbiAgY29uc3QgdGV4dERpZmYgPSBuZXh0VGV4dC5sZW5ndGggLSBwcmV2VGV4dC5sZW5ndGg7XG4gIGlmICh0ZXh0RGlmZiA9PT0gMSAmJiBwcmV2QW5jaG9yT2Zmc2V0ID09PSBuZXh0QW5jaG9yT2Zmc2V0IC0gMSkge1xuICAgIHJldHVybiBJTlNFUlRfQ0hBUkFDVEVSX0FGVEVSX1NFTEVDVElPTjtcbiAgfVxuICBpZiAodGV4dERpZmYgPT09IC0xICYmIHByZXZBbmNob3JPZmZzZXQgPT09IG5leHRBbmNob3JPZmZzZXQgKyAxKSB7XG4gICAgcmV0dXJuIERFTEVURV9DSEFSQUNURVJfQkVGT1JFX1NFTEVDVElPTjtcbiAgfVxuICBpZiAodGV4dERpZmYgPT09IC0xICYmIHByZXZBbmNob3JPZmZzZXQgPT09IG5leHRBbmNob3JPZmZzZXQpIHtcbiAgICByZXR1cm4gREVMRVRFX0NIQVJBQ1RFUl9BRlRFUl9TRUxFQ1RJT047XG4gIH1cbiAgcmV0dXJuIE9USEVSO1xufVxuZnVuY3Rpb24gaXNUZXh0Tm9kZVVuY2hhbmdlZChrZXksIHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IHByZXZOb2RlID0gcHJldkVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChrZXkpO1xuICBjb25zdCBuZXh0Tm9kZSA9IG5leHRFZGl0b3JTdGF0ZS5fbm9kZU1hcC5nZXQoa2V5KTtcbiAgY29uc3QgcHJldlNlbGVjdGlvbiA9IHByZXZFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBuZXh0U2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGxldCBpc0RlbGV0aW5nTGluZSA9IGZhbHNlO1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgJGlzUmFuZ2VTZWxlY3Rpb24obmV4dFNlbGVjdGlvbikpIHtcbiAgICBpc0RlbGV0aW5nTGluZSA9IHByZXZTZWxlY3Rpb24uYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBwcmV2U2VsZWN0aW9uLmZvY3VzLnR5cGUgPT09ICdlbGVtZW50JyAmJiBuZXh0U2VsZWN0aW9uLmFuY2hvci50eXBlID09PSAndGV4dCcgJiYgbmV4dFNlbGVjdGlvbi5mb2N1cy50eXBlID09PSAndGV4dCc7XG4gIH1cbiAgaWYgKCFpc0RlbGV0aW5nTGluZSAmJiAkaXNUZXh0Tm9kZShwcmV2Tm9kZSkgJiYgJGlzVGV4dE5vZGUobmV4dE5vZGUpKSB7XG4gICAgcmV0dXJuIHByZXZOb2RlLl9fdHlwZSA9PT0gbmV4dE5vZGUuX190eXBlICYmIHByZXZOb2RlLl9fdGV4dCA9PT0gbmV4dE5vZGUuX190ZXh0ICYmIHByZXZOb2RlLl9fbW9kZSA9PT0gbmV4dE5vZGUuX19tb2RlICYmIHByZXZOb2RlLl9fZGV0YWlsID09PSBuZXh0Tm9kZS5fX2RldGFpbCAmJiBwcmV2Tm9kZS5fX3N0eWxlID09PSBuZXh0Tm9kZS5fX3N0eWxlICYmIHByZXZOb2RlLl9fZm9ybWF0ID09PSBuZXh0Tm9kZS5fX2Zvcm1hdCAmJiBwcmV2Tm9kZS5fX3BhcmVudCA9PT0gbmV4dE5vZGUuX19wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY3JlYXRlTWVyZ2VBY3Rpb25HZXR0ZXIoZWRpdG9yLCBkZWxheSkge1xuICBsZXQgcHJldkNoYW5nZVRpbWUgPSBEYXRlLm5vdygpO1xuICBsZXQgcHJldkNoYW5nZVR5cGUgPSBPVEhFUjtcbiAgcmV0dXJuIChwcmV2RWRpdG9yU3RhdGUsIG5leHRFZGl0b3JTdGF0ZSwgY3VycmVudEhpc3RvcnlFbnRyeSwgZGlydHlMZWF2ZXMsIGRpcnR5RWxlbWVudHMsIHRhZ3MpID0+IHtcbiAgICBjb25zdCBjaGFuZ2VUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIElmIGFwcGx5aW5nIGNoYW5nZXMgZnJvbSBoaXN0b3J5IHN0YWNrIHRoZXJlJ3Mgbm8gbmVlZFxuICAgIC8vIHRvIHJ1biBoaXN0b3J5IGxvZ2ljIGFnYWluLCBhcyBoaXN0b3J5IGVudHJpZXMgYWxyZWFkeSBjYWxjdWxhdGVkXG4gICAgaWYgKHRhZ3MuaGFzKCdoaXN0b3JpYycpKSB7XG4gICAgICBwcmV2Q2hhbmdlVHlwZSA9IE9USEVSO1xuICAgICAgcHJldkNoYW5nZVRpbWUgPSBjaGFuZ2VUaW1lO1xuICAgICAgcmV0dXJuIERJU0NBUkRfSElTVE9SWV9DQU5ESURBVEU7XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZVR5cGUgPSBnZXRDaGFuZ2VUeXBlKHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlLCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cywgZWRpdG9yLmlzQ29tcG9zaW5nKCkpO1xuICAgIGNvbnN0IG1lcmdlQWN0aW9uID0gKCgpID0+IHtcbiAgICAgIGNvbnN0IGlzU2FtZUVkaXRvciA9IGN1cnJlbnRIaXN0b3J5RW50cnkgPT09IG51bGwgfHwgY3VycmVudEhpc3RvcnlFbnRyeS5lZGl0b3IgPT09IGVkaXRvcjtcbiAgICAgIGNvbnN0IHNob3VsZFB1c2hIaXN0b3J5ID0gdGFncy5oYXMoJ2hpc3RvcnktcHVzaCcpO1xuICAgICAgY29uc3Qgc2hvdWxkTWVyZ2VIaXN0b3J5ID0gIXNob3VsZFB1c2hIaXN0b3J5ICYmIGlzU2FtZUVkaXRvciAmJiB0YWdzLmhhcygnaGlzdG9yeS1tZXJnZScpO1xuICAgICAgaWYgKHNob3VsZE1lcmdlSGlzdG9yeSkge1xuICAgICAgICByZXR1cm4gSElTVE9SWV9NRVJHRTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2RWRpdG9yU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIEhJU1RPUllfUFVTSDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IG5leHRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICAgICAgY29uc3QgaGFzRGlydHlOb2RlcyA9IGRpcnR5TGVhdmVzLnNpemUgPiAwIHx8IGRpcnR5RWxlbWVudHMuc2l6ZSA+IDA7XG4gICAgICBpZiAoIWhhc0RpcnR5Tm9kZXMpIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBISVNUT1JZX01FUkdFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBESVNDQVJEX0hJU1RPUllfQ0FORElEQVRFO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFB1c2hIaXN0b3J5ID09PSBmYWxzZSAmJiBjaGFuZ2VUeXBlICE9PSBPVEhFUiAmJiBjaGFuZ2VUeXBlID09PSBwcmV2Q2hhbmdlVHlwZSAmJiBjaGFuZ2VUaW1lIDwgcHJldkNoYW5nZVRpbWUgKyBkZWxheSAmJiBpc1NhbWVFZGl0b3IpIHtcbiAgICAgICAgcmV0dXJuIEhJU1RPUllfTUVSR0U7XG4gICAgICB9XG5cbiAgICAgIC8vIEEgc2luZ2xlIG5vZGUgbWlnaHQgaGF2ZSBiZWVuIG1hcmtlZCBhcyBkaXJ0eSwgYnV0IG5vdCBoYXZlIGNoYW5nZWRcbiAgICAgIC8vIGR1ZSB0byBzb21lIG5vZGUgdHJhbnNmb3JtIHJldmVydGluZyB0aGUgY2hhbmdlLlxuICAgICAgaWYgKGRpcnR5TGVhdmVzLnNpemUgPT09IDEpIHtcbiAgICAgICAgY29uc3QgZGlydHlMZWFmS2V5ID0gQXJyYXkuZnJvbShkaXJ0eUxlYXZlcylbMF07XG4gICAgICAgIGlmIChpc1RleHROb2RlVW5jaGFuZ2VkKGRpcnR5TGVhZktleSwgcHJldkVkaXRvclN0YXRlLCBuZXh0RWRpdG9yU3RhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIEhJU1RPUllfTUVSR0U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBISVNUT1JZX1BVU0g7XG4gICAgfSkoKTtcbiAgICBwcmV2Q2hhbmdlVGltZSA9IGNoYW5nZVRpbWU7XG4gICAgcHJldkNoYW5nZVR5cGUgPSBjaGFuZ2VUeXBlO1xuICAgIHJldHVybiBtZXJnZUFjdGlvbjtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlZG8oZWRpdG9yLCBoaXN0b3J5U3RhdGUpIHtcbiAgY29uc3QgcmVkb1N0YWNrID0gaGlzdG9yeVN0YXRlLnJlZG9TdGFjaztcbiAgY29uc3QgdW5kb1N0YWNrID0gaGlzdG9yeVN0YXRlLnVuZG9TdGFjaztcbiAgaWYgKHJlZG9TdGFjay5sZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBjdXJyZW50ID0gaGlzdG9yeVN0YXRlLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHVuZG9TdGFjay5wdXNoKGN1cnJlbnQpO1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fVU5ET19DT01NQU5ELCB0cnVlKTtcbiAgICB9XG4gICAgY29uc3QgaGlzdG9yeVN0YXRlRW50cnkgPSByZWRvU3RhY2sucG9wKCk7XG4gICAgaWYgKHJlZG9TdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoQ0FOX1JFRE9fQ09NTUFORCwgZmFsc2UpO1xuICAgIH1cbiAgICBoaXN0b3J5U3RhdGUuY3VycmVudCA9IGhpc3RvcnlTdGF0ZUVudHJ5IHx8IG51bGw7XG4gICAgaWYgKGhpc3RvcnlTdGF0ZUVudHJ5KSB7XG4gICAgICBoaXN0b3J5U3RhdGVFbnRyeS5lZGl0b3Iuc2V0RWRpdG9yU3RhdGUoaGlzdG9yeVN0YXRlRW50cnkuZWRpdG9yU3RhdGUsIHtcbiAgICAgICAgdGFnOiAnaGlzdG9yaWMnXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVuZG8oZWRpdG9yLCBoaXN0b3J5U3RhdGUpIHtcbiAgY29uc3QgcmVkb1N0YWNrID0gaGlzdG9yeVN0YXRlLnJlZG9TdGFjaztcbiAgY29uc3QgdW5kb1N0YWNrID0gaGlzdG9yeVN0YXRlLnVuZG9TdGFjaztcbiAgY29uc3QgdW5kb1N0YWNrTGVuZ3RoID0gdW5kb1N0YWNrLmxlbmd0aDtcbiAgaWYgKHVuZG9TdGFja0xlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBoaXN0b3J5U3RhdGUuY3VycmVudDtcbiAgICBjb25zdCBoaXN0b3J5U3RhdGVFbnRyeSA9IHVuZG9TdGFjay5wb3AoKTtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgcmVkb1N0YWNrLnB1c2goY3VycmVudCk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKENBTl9SRURPX0NPTU1BTkQsIHRydWUpO1xuICAgIH1cbiAgICBpZiAodW5kb1N0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fVU5ET19DT01NQU5ELCBmYWxzZSk7XG4gICAgfVxuICAgIGhpc3RvcnlTdGF0ZS5jdXJyZW50ID0gaGlzdG9yeVN0YXRlRW50cnkgfHwgbnVsbDtcbiAgICBpZiAoaGlzdG9yeVN0YXRlRW50cnkpIHtcbiAgICAgIGhpc3RvcnlTdGF0ZUVudHJ5LmVkaXRvci5zZXRFZGl0b3JTdGF0ZShoaXN0b3J5U3RhdGVFbnRyeS5lZGl0b3JTdGF0ZSwge1xuICAgICAgICB0YWc6ICdoaXN0b3JpYydcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2xlYXJIaXN0b3J5KGhpc3RvcnlTdGF0ZSkge1xuICBoaXN0b3J5U3RhdGUudW5kb1N0YWNrID0gW107XG4gIGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2sgPSBbXTtcbiAgaGlzdG9yeVN0YXRlLmN1cnJlbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBuZWNlc3NhcnkgbGlzdGVuZXJzIHRvIG1hbmFnZSB1bmRvL3JlZG8gaGlzdG9yeSBzdGFjayBhbmQgcmVsYXRlZCBlZGl0b3IgY29tbWFuZHMuXG4gKiBJdCByZXR1cm5zIGB1bnJlZ2lzdGVyYCBjYWxsYmFjayB0aGF0IGNsZWFucyB1cCBhbGwgbGlzdGVuZXJzIGFuZCBzaG91bGQgYmUgY2FsbGVkIG9uIGVkaXRvciB1bm1vdW50LlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBoaXN0b3J5U3RhdGUgLSBUaGUgaGlzdG9yeSBzdGF0ZSwgY29udGFpbmluZyB0aGUgY3VycmVudCBzdGF0ZSBhbmQgdGhlIHVuZG8vcmVkbyBzdGFjay5cbiAqIEBwYXJhbSBkZWxheSAtIFRoZSB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRoZSBlZGl0b3Igc2hvdWxkIGRlbGF5IGdlbmVyYXRpbmcgYSBuZXcgaGlzdG9yeSBzdGFjayxcbiAqIGluc3RlYWQgb2YgbWVyZ2luZyB0aGUgY3VycmVudCBjaGFuZ2VzIHdpdGggdGhlIGN1cnJlbnQgc3RhY2suXG4gKiBAcmV0dXJucyBUaGUgbGlzdGVuZXJzIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVySGlzdG9yeShlZGl0b3IsIGhpc3RvcnlTdGF0ZSwgZGVsYXkpIHtcbiAgY29uc3QgZ2V0TWVyZ2VBY3Rpb24gPSBjcmVhdGVNZXJnZUFjdGlvbkdldHRlcihlZGl0b3IsIGRlbGF5KTtcbiAgY29uc3QgYXBwbHlDaGFuZ2UgPSAoe1xuICAgIGVkaXRvclN0YXRlLFxuICAgIHByZXZFZGl0b3JTdGF0ZSxcbiAgICBkaXJ0eUxlYXZlcyxcbiAgICBkaXJ0eUVsZW1lbnRzLFxuICAgIHRhZ3NcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBoaXN0b3J5U3RhdGUuY3VycmVudDtcbiAgICBjb25zdCByZWRvU3RhY2sgPSBoaXN0b3J5U3RhdGUucmVkb1N0YWNrO1xuICAgIGNvbnN0IHVuZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS51bmRvU3RhY2s7XG4gICAgY29uc3QgY3VycmVudEVkaXRvclN0YXRlID0gY3VycmVudCA9PT0gbnVsbCA/IG51bGwgOiBjdXJyZW50LmVkaXRvclN0YXRlO1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGVkaXRvclN0YXRlID09PSBjdXJyZW50RWRpdG9yU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VBY3Rpb24gPSBnZXRNZXJnZUFjdGlvbihwcmV2RWRpdG9yU3RhdGUsIGVkaXRvclN0YXRlLCBjdXJyZW50LCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cywgdGFncyk7XG4gICAgaWYgKG1lcmdlQWN0aW9uID09PSBISVNUT1JZX1BVU0gpIHtcbiAgICAgIGlmIChyZWRvU3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2sgPSBbXTtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fUkVET19DT01NQU5ELCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICB1bmRvU3RhY2sucHVzaCh7XG4gICAgICAgICAgLi4uY3VycmVudFxuICAgICAgICB9KTtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fVU5ET19DT01NQU5ELCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1lcmdlQWN0aW9uID09PSBESVNDQVJEX0hJU1RPUllfQ0FORElEQVRFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRWxzZSB3ZSBtZXJnZVxuICAgIGhpc3RvcnlTdGF0ZS5jdXJyZW50ID0ge1xuICAgICAgZWRpdG9yLFxuICAgICAgZWRpdG9yU3RhdGVcbiAgICB9O1xuICB9O1xuICBjb25zdCB1bnJlZ2lzdGVyID0gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFVORE9fQ09NTUFORCwgKCkgPT4ge1xuICAgIHVuZG8oZWRpdG9yLCBoaXN0b3J5U3RhdGUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoUkVET19DT01NQU5ELCAoKSA9PiB7XG4gICAgcmVkbyhlZGl0b3IsIGhpc3RvcnlTdGF0ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDTEVBUl9FRElUT1JfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNsZWFySGlzdG9yeShoaXN0b3J5U3RhdGUpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENMRUFSX0hJU1RPUllfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNsZWFySGlzdG9yeShoaXN0b3J5U3RhdGUpO1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoQ0FOX1JFRE9fQ09NTUFORCwgZmFsc2UpO1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoQ0FOX1VORE9fQ09NTUFORCwgZmFsc2UpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKGFwcGx5Q2hhbmdlKSk7XG4gIHJldHVybiB1bnJlZ2lzdGVyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW1wdHkgaGlzdG9yeSBzdGF0ZS5cbiAqIEByZXR1cm5zIC0gVGhlIGVtcHR5IGhpc3Rvcnkgc3RhdGUsIGFzIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogbnVsbCxcbiAgICByZWRvU3RhY2s6IFtdLFxuICAgIHVuZG9TdGFjazogW11cbiAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGUsIHJlZ2lzdGVySGlzdG9yeSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/history/LexicalHistory.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/html/LexicalHtml.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/html/LexicalHtml.dev.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $generateHtmlFromNodes: () => (/* binding */ $generateHtmlFromNodes),\n/* harmony export */   $generateNodesFromDOM: () => (/* binding */ $generateNodesFromDOM)\n/* harmony export */ });\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificalNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.$cloneWithProperties)(currentNode);\n    clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone) && selection !== null ? (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.$sliceSelectedTextNodeContent)(selection, clone) : clone;\n    target = clone;\n  }\n  const children = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        element.replaceWith(newElement);\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null || (currentConversion.priority || 0) < (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(currentLexicalNode) ? false : currentLexicalNode != null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode)(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new lexical__WEBPACK_IMPORTED_MODULE_0__.ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificalNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof lexical__WEBPACK_IMPORTED_MODULE_0__.ArtificialNode__DO_NOT_USE) {\n      node.insertAfter((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createLineBreakNode)());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaHRtbC9MZXhpY2FsSHRtbC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUY7QUFDMUI7QUFDbUg7O0FBRWxMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdURBQWM7QUFDdEM7QUFDQTtBQUNBLGdCQUFnQix3RUFBb0I7QUFDcEMsWUFBWSxvREFBVyxnQ0FBZ0MsaUZBQTZCO0FBQ3BGO0FBQ0E7QUFDQSxtQkFBbUIsdURBQWM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLDBCQUEwQix1REFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsNERBQW1CLDZEQUE2RCw0REFBbUI7QUFDbEwsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBYztBQUNwQjtBQUNBLHlFQUF5RSx5REFBb0I7QUFDN0YsTUFBTTtBQUNOO0FBQ0EsbUNBQW1DLCtEQUEwQjtBQUM3RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQSxRQUFRLDREQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDREQUE0RCw0REFBbUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLCtEQUEwQjtBQUNuRSx1QkFBdUIsNkRBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl2ZWRvY3MvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaHRtbC9MZXhpY2FsSHRtbC5kZXYubWpzP2I0ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkY2xvbmVXaXRoUHJvcGVydGllcywgJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQgfSBmcm9tICdAbGV4aWNhbC9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgaXNCbG9ja0RvbU5vZGUgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyAkZ2V0Um9vdCwgJGlzRWxlbWVudE5vZGUsICRpc1RleHROb2RlLCAkaXNSb290T3JTaGFkb3dSb290LCAkaXNCbG9ja0VsZW1lbnROb2RlLCBBcnRpZmljaWFsTm9kZV9fRE9fTk9UX1VTRSwgJGNyZWF0ZUxpbmVCcmVha05vZGUsICRjcmVhdGVQYXJhZ3JhcGhOb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vKipcbiAqIEhvdyB5b3UgcGFyc2UgeW91ciBodG1sIHN0cmluZyB0byBnZXQgYSBkb2N1bWVudCBpcyBsZWZ0IHVwIHRvIHlvdS4gSW4gdGhlIGJyb3dzZXIgeW91IGNhbiB1c2UgdGhlIG5hdGl2ZVxuICogRE9NUGFyc2VyIEFQSSB0byBnZW5lcmF0ZSBhIGRvY3VtZW50IChzZWUgY2xpcGJvYXJkLnRzKSwgYnV0IHRvIHVzZSBpbiBhIGhlYWRsZXNzIGVudmlyb25tZW50IHlvdSBjYW4gdXNlIEpTRG9tXG4gKiBvciBhbiBlcXVpdmFsZW50IGxpYnJhcnkgYW5kIHBhc3MgaW4gdGhlIGRvY3VtZW50IGhlcmUuXG4gKi9cbmZ1bmN0aW9uICRnZW5lcmF0ZU5vZGVzRnJvbURPTShlZGl0b3IsIGRvbSkge1xuICBjb25zdCBlbGVtZW50cyA9IGRvbS5ib2R5ID8gZG9tLmJvZHkuY2hpbGROb2RlcyA6IFtdO1xuICBsZXQgbGV4aWNhbE5vZGVzID0gW107XG4gIGNvbnN0IGFsbEFydGlmaWNpYWxOb2RlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgIGlmICghSUdOT1JFX1RBR1MuaGFzKGVsZW1lbnQubm9kZU5hbWUpKSB7XG4gICAgICBjb25zdCBsZXhpY2FsTm9kZSA9ICRjcmVhdGVOb2Rlc0Zyb21ET00oZWxlbWVudCwgZWRpdG9yLCBhbGxBcnRpZmljaWFsTm9kZXMsIGZhbHNlKTtcbiAgICAgIGlmIChsZXhpY2FsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBsZXhpY2FsTm9kZXMgPSBsZXhpY2FsTm9kZXMuY29uY2F0KGxleGljYWxOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgJHVud3JhcEFydGlmaWNhbE5vZGVzKGFsbEFydGlmaWNpYWxOb2Rlcyk7XG4gIHJldHVybiBsZXhpY2FsTm9kZXM7XG59XG5mdW5jdGlvbiAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzKGVkaXRvciwgc2VsZWN0aW9uKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWwud2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcignVG8gdXNlICRnZW5lcmF0ZUh0bWxGcm9tTm9kZXMgaW4gaGVhZGxlc3MgbW9kZSBwbGVhc2UgaW5pdGlhbGl6ZSBhIGhlYWRsZXNzIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gc3VjaCBhcyBKU0RvbSBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLicpO1xuICB9XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgY29uc3QgdG9wTGV2ZWxDaGlsZHJlbiA9IHJvb3QuZ2V0Q2hpbGRyZW4oKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3BMZXZlbENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9wTGV2ZWxOb2RlID0gdG9wTGV2ZWxDaGlsZHJlbltpXTtcbiAgICAkYXBwZW5kTm9kZXNUb0hUTUwoZWRpdG9yLCB0b3BMZXZlbE5vZGUsIGNvbnRhaW5lciwgc2VsZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTDtcbn1cbmZ1bmN0aW9uICRhcHBlbmROb2Rlc1RvSFRNTChlZGl0b3IsIGN1cnJlbnROb2RlLCBwYXJlbnRFbGVtZW50LCBzZWxlY3Rpb24gPSBudWxsKSB7XG4gIGxldCBzaG91bGRJbmNsdWRlID0gc2VsZWN0aW9uICE9PSBudWxsID8gY3VycmVudE5vZGUuaXNTZWxlY3RlZChzZWxlY3Rpb24pIDogdHJ1ZTtcbiAgY29uc3Qgc2hvdWxkRXhjbHVkZSA9ICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiBjdXJyZW50Tm9kZS5leGNsdWRlRnJvbUNvcHkoJ2h0bWwnKTtcbiAgbGV0IHRhcmdldCA9IGN1cnJlbnROb2RlO1xuICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgbGV0IGNsb25lID0gJGNsb25lV2l0aFByb3BlcnRpZXMoY3VycmVudE5vZGUpO1xuICAgIGNsb25lID0gJGlzVGV4dE5vZGUoY2xvbmUpICYmIHNlbGVjdGlvbiAhPT0gbnVsbCA/ICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50KHNlbGVjdGlvbiwgY2xvbmUpIDogY2xvbmU7XG4gICAgdGFyZ2V0ID0gY2xvbmU7XG4gIH1cbiAgY29uc3QgY2hpbGRyZW4gPSAkaXNFbGVtZW50Tm9kZSh0YXJnZXQpID8gdGFyZ2V0LmdldENoaWxkcmVuKCkgOiBbXTtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSBlZGl0b3IuX25vZGVzLmdldCh0YXJnZXQuZ2V0VHlwZSgpKTtcbiAgbGV0IGV4cG9ydE91dHB1dDtcblxuICAvLyBVc2UgSFRNTENvbmZpZyBvdmVycmlkZXMsIGlmIGF2YWlsYWJsZS5cbiAgaWYgKHJlZ2lzdGVyZWROb2RlICYmIHJlZ2lzdGVyZWROb2RlLmV4cG9ydERPTSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwb3J0T3V0cHV0ID0gcmVnaXN0ZXJlZE5vZGUuZXhwb3J0RE9NKGVkaXRvciwgdGFyZ2V0KTtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRPdXRwdXQgPSB0YXJnZXQuZXhwb3J0RE9NKGVkaXRvcik7XG4gIH1cbiAgY29uc3Qge1xuICAgIGVsZW1lbnQsXG4gICAgYWZ0ZXJcbiAgfSA9IGV4cG9ydE91dHB1dDtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5baV07XG4gICAgY29uc3Qgc2hvdWxkSW5jbHVkZUNoaWxkID0gJGFwcGVuZE5vZGVzVG9IVE1MKGVkaXRvciwgY2hpbGROb2RlLCBmcmFnbWVudCwgc2VsZWN0aW9uKTtcbiAgICBpZiAoIXNob3VsZEluY2x1ZGUgJiYgJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmIHNob3VsZEluY2x1ZGVDaGlsZCAmJiBjdXJyZW50Tm9kZS5leHRyYWN0V2l0aENoaWxkKGNoaWxkTm9kZSwgc2VsZWN0aW9uLCAnaHRtbCcpKSB7XG4gICAgICBzaG91bGRJbmNsdWRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHNob3VsZEluY2x1ZGUgJiYgIXNob3VsZEV4Y2x1ZGUpIHtcbiAgICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgZWxlbWVudC5hcHBlbmQoZnJhZ21lbnQpO1xuICAgIH1cbiAgICBwYXJlbnRFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBhZnRlci5jYWxsKHRhcmdldCwgZWxlbWVudCk7XG4gICAgICBpZiAobmV3RWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnJlcGxhY2VXaXRoKG5ld0VsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRFbGVtZW50LmFwcGVuZChmcmFnbWVudCk7XG4gIH1cbiAgcmV0dXJuIHNob3VsZEluY2x1ZGU7XG59XG5mdW5jdGlvbiBnZXRDb252ZXJzaW9uRnVuY3Rpb24oZG9tTm9kZSwgZWRpdG9yKSB7XG4gIGNvbnN0IHtcbiAgICBub2RlTmFtZVxuICB9ID0gZG9tTm9kZTtcbiAgY29uc3QgY2FjaGVkQ29udmVyc2lvbnMgPSBlZGl0b3IuX2h0bWxDb252ZXJzaW9ucy5nZXQobm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIGxldCBjdXJyZW50Q29udmVyc2lvbiA9IG51bGw7XG4gIGlmIChjYWNoZWRDb252ZXJzaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCBjYWNoZWRDb252ZXJzaW9uIG9mIGNhY2hlZENvbnZlcnNpb25zKSB7XG4gICAgICBjb25zdCBkb21Db252ZXJzaW9uID0gY2FjaGVkQ29udmVyc2lvbihkb21Ob2RlKTtcbiAgICAgIGlmIChkb21Db252ZXJzaW9uICE9PSBudWxsICYmIChjdXJyZW50Q29udmVyc2lvbiA9PT0gbnVsbCB8fCAoY3VycmVudENvbnZlcnNpb24ucHJpb3JpdHkgfHwgMCkgPCAoZG9tQ29udmVyc2lvbi5wcmlvcml0eSB8fCAwKSkpIHtcbiAgICAgICAgY3VycmVudENvbnZlcnNpb24gPSBkb21Db252ZXJzaW9uO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY3VycmVudENvbnZlcnNpb24gIT09IG51bGwgPyBjdXJyZW50Q29udmVyc2lvbi5jb252ZXJzaW9uIDogbnVsbDtcbn1cbmNvbnN0IElHTk9SRV9UQUdTID0gbmV3IFNldChbJ1NUWUxFJywgJ1NDUklQVCddKTtcbmZ1bmN0aW9uICRjcmVhdGVOb2Rlc0Zyb21ET00obm9kZSwgZWRpdG9yLCBhbGxBcnRpZmljaWFsTm9kZXMsIGhhc0Jsb2NrQW5jZXN0b3JMZXhpY2FsTm9kZSwgZm9yQ2hpbGRNYXAgPSBuZXcgTWFwKCksIHBhcmVudExleGljYWxOb2RlKSB7XG4gIGxldCBsZXhpY2FsTm9kZXMgPSBbXTtcbiAgaWYgKElHTk9SRV9UQUdTLmhhcyhub2RlLm5vZGVOYW1lKSkge1xuICAgIHJldHVybiBsZXhpY2FsTm9kZXM7XG4gIH1cbiAgbGV0IGN1cnJlbnRMZXhpY2FsTm9kZSA9IG51bGw7XG4gIGNvbnN0IHRyYW5zZm9ybUZ1bmN0aW9uID0gZ2V0Q29udmVyc2lvbkZ1bmN0aW9uKG5vZGUsIGVkaXRvcik7XG4gIGNvbnN0IHRyYW5zZm9ybU91dHB1dCA9IHRyYW5zZm9ybUZ1bmN0aW9uID8gdHJhbnNmb3JtRnVuY3Rpb24obm9kZSkgOiBudWxsO1xuICBsZXQgcG9zdFRyYW5zZm9ybSA9IG51bGw7XG4gIGlmICh0cmFuc2Zvcm1PdXRwdXQgIT09IG51bGwpIHtcbiAgICBwb3N0VHJhbnNmb3JtID0gdHJhbnNmb3JtT3V0cHV0LmFmdGVyO1xuICAgIGNvbnN0IHRyYW5zZm9ybU5vZGVzID0gdHJhbnNmb3JtT3V0cHV0Lm5vZGU7XG4gICAgY3VycmVudExleGljYWxOb2RlID0gQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1Ob2RlcykgPyB0cmFuc2Zvcm1Ob2Rlc1t0cmFuc2Zvcm1Ob2Rlcy5sZW5ndGggLSAxXSA6IHRyYW5zZm9ybU5vZGVzO1xuICAgIGlmIChjdXJyZW50TGV4aWNhbE5vZGUgIT09IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgWywgZm9yQ2hpbGRGdW5jdGlvbl0gb2YgZm9yQ2hpbGRNYXApIHtcbiAgICAgICAgY3VycmVudExleGljYWxOb2RlID0gZm9yQ2hpbGRGdW5jdGlvbihjdXJyZW50TGV4aWNhbE5vZGUsIHBhcmVudExleGljYWxOb2RlKTtcbiAgICAgICAgaWYgKCFjdXJyZW50TGV4aWNhbE5vZGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRMZXhpY2FsTm9kZSkge1xuICAgICAgICBsZXhpY2FsTm9kZXMucHVzaCguLi4oQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1Ob2RlcykgPyB0cmFuc2Zvcm1Ob2RlcyA6IFtjdXJyZW50TGV4aWNhbE5vZGVdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1PdXRwdXQuZm9yQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgZm9yQ2hpbGRNYXAuc2V0KG5vZGUubm9kZU5hbWUsIHRyYW5zZm9ybU91dHB1dC5mb3JDaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlIERPTSBub2RlIGRvZXNuJ3QgaGF2ZSBhIHRyYW5zZm9ybWVyLCB3ZSBkb24ndCBrbm93IHdoYXRcbiAgLy8gdG8gZG8gd2l0aCBpdCBidXQgd2Ugc3RpbGwgbmVlZCB0byBwcm9jZXNzIGFueSBjaGlsZE5vZGVzLlxuICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgbGV0IGNoaWxkTGV4aWNhbE5vZGVzID0gW107XG4gIGNvbnN0IGhhc0Jsb2NrQW5jZXN0b3JMZXhpY2FsTm9kZUZvckNoaWxkcmVuID0gY3VycmVudExleGljYWxOb2RlICE9IG51bGwgJiYgJGlzUm9vdE9yU2hhZG93Um9vdChjdXJyZW50TGV4aWNhbE5vZGUpID8gZmFsc2UgOiBjdXJyZW50TGV4aWNhbE5vZGUgIT0gbnVsbCAmJiAkaXNCbG9ja0VsZW1lbnROb2RlKGN1cnJlbnRMZXhpY2FsTm9kZSkgfHwgaGFzQmxvY2tBbmNlc3RvckxleGljYWxOb2RlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hpbGRMZXhpY2FsTm9kZXMucHVzaCguLi4kY3JlYXRlTm9kZXNGcm9tRE9NKGNoaWxkcmVuW2ldLCBlZGl0b3IsIGFsbEFydGlmaWNpYWxOb2RlcywgaGFzQmxvY2tBbmNlc3RvckxleGljYWxOb2RlRm9yQ2hpbGRyZW4sIG5ldyBNYXAoZm9yQ2hpbGRNYXApLCBjdXJyZW50TGV4aWNhbE5vZGUpKTtcbiAgfVxuICBpZiAocG9zdFRyYW5zZm9ybSAhPSBudWxsKSB7XG4gICAgY2hpbGRMZXhpY2FsTm9kZXMgPSBwb3N0VHJhbnNmb3JtKGNoaWxkTGV4aWNhbE5vZGVzKTtcbiAgfVxuICBpZiAoaXNCbG9ja0RvbU5vZGUobm9kZSkpIHtcbiAgICBpZiAoIWhhc0Jsb2NrQW5jZXN0b3JMZXhpY2FsTm9kZUZvckNoaWxkcmVuKSB7XG4gICAgICBjaGlsZExleGljYWxOb2RlcyA9IHdyYXBDb250aW51b3VzSW5saW5lcyhub2RlLCBjaGlsZExleGljYWxOb2RlcywgJGNyZWF0ZVBhcmFncmFwaE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZExleGljYWxOb2RlcyA9IHdyYXBDb250aW51b3VzSW5saW5lcyhub2RlLCBjaGlsZExleGljYWxOb2RlcywgKCkgPT4ge1xuICAgICAgICBjb25zdCBhcnRpZmljaWFsTm9kZSA9IG5ldyBBcnRpZmljaWFsTm9kZV9fRE9fTk9UX1VTRSgpO1xuICAgICAgICBhbGxBcnRpZmljaWFsTm9kZXMucHVzaChhcnRpZmljaWFsTm9kZSk7XG4gICAgICAgIHJldHVybiBhcnRpZmljaWFsTm9kZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoY3VycmVudExleGljYWxOb2RlID09IG51bGwpIHtcbiAgICAvLyBJZiBpdCBoYXNuJ3QgYmVlbiBjb252ZXJ0ZWQgdG8gYSBMZXhpY2FsTm9kZSwgd2UgaG9pc3QgaXRzIGNoaWxkcmVuXG4gICAgLy8gdXAgdG8gdGhlIHNhbWUgbGV2ZWwgYXMgaXQuXG4gICAgbGV4aWNhbE5vZGVzID0gbGV4aWNhbE5vZGVzLmNvbmNhdChjaGlsZExleGljYWxOb2Rlcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGN1cnJlbnRMZXhpY2FsTm9kZSkpIHtcbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IG5vZGUgaXMgYSBFbGVtZW50Tm9kZSBhZnRlciBjb252ZXJzaW9uLFxuICAgICAgLy8gd2UgY2FuIGFwcGVuZCBhbGwgdGhlIGNoaWxkcmVuIHRvIGl0LlxuICAgICAgY3VycmVudExleGljYWxOb2RlLmFwcGVuZCguLi5jaGlsZExleGljYWxOb2Rlcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZXhpY2FsTm9kZXM7XG59XG5mdW5jdGlvbiB3cmFwQ29udGludW91c0lubGluZXMoZG9tTm9kZSwgbm9kZXMsIGNyZWF0ZVdyYXBwZXJGbikge1xuICBjb25zdCB0ZXh0QWxpZ24gPSBkb21Ob2RlLnN0eWxlLnRleHRBbGlnbjtcbiAgY29uc3Qgb3V0ID0gW107XG4gIGxldCBjb250aW51b3VzSW5saW5lcyA9IFtdO1xuICAvLyB3cmFwIGNvbnRpZ3VvdXMgaW5saW5lIGNoaWxkIG5vZGVzIGluIHBhcmFcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAoJGlzQmxvY2tFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgaWYgKHRleHRBbGlnbiAmJiAhbm9kZS5nZXRGb3JtYXQoKSkge1xuICAgICAgICBub2RlLnNldEZvcm1hdCh0ZXh0QWxpZ24pO1xuICAgICAgfVxuICAgICAgb3V0LnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRpbnVvdXNJbmxpbmVzLnB1c2gobm9kZSk7XG4gICAgICBpZiAoaSA9PT0gbm9kZXMubGVuZ3RoIC0gMSB8fCBpIDwgbm9kZXMubGVuZ3RoIC0gMSAmJiAkaXNCbG9ja0VsZW1lbnROb2RlKG5vZGVzW2kgKyAxXSkpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IGNyZWF0ZVdyYXBwZXJGbigpO1xuICAgICAgICB3cmFwcGVyLnNldEZvcm1hdCh0ZXh0QWxpZ24pO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZCguLi5jb250aW51b3VzSW5saW5lcyk7XG4gICAgICAgIG91dC5wdXNoKHdyYXBwZXIpO1xuICAgICAgICBjb250aW51b3VzSW5saW5lcyA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gJHVud3JhcEFydGlmaWNhbE5vZGVzKGFsbEFydGlmaWNpYWxOb2Rlcykge1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgYWxsQXJ0aWZpY2lhbE5vZGVzKSB7XG4gICAgaWYgKG5vZGUuZ2V0TmV4dFNpYmxpbmcoKSBpbnN0YW5jZW9mIEFydGlmaWNpYWxOb2RlX19ET19OT1RfVVNFKSB7XG4gICAgICBub2RlLmluc2VydEFmdGVyKCRjcmVhdGVMaW5lQnJlYWtOb2RlKCkpO1xuICAgIH1cbiAgfVxuICAvLyBSZXBsYWNlIGFydGlmaWNpYWwgbm9kZSB3aXRoIGl0J3MgY2hpbGRyZW5cbiAgZm9yIChjb25zdCBub2RlIG9mIGFsbEFydGlmaWNpYWxOb2Rlcykge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIG5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkKTtcbiAgICB9XG4gICAgbm9kZS5yZW1vdmUoKTtcbiAgfVxufVxuXG5leHBvcnQgeyAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzLCAkZ2VuZXJhdGVOb2Rlc0Zyb21ET00gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/html/LexicalHtml.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/offset/LexicalOffset.dev.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/offset/LexicalOffset.dev.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createChildrenArray: () => (/* binding */ $createChildrenArray),\n/* harmony export */   $createOffsetView: () => (/* binding */ $createOffsetView),\n/* harmony export */   OffsetView: () => (/* binding */ OffsetView),\n/* harmony export */   createChildrenArray: () => (/* binding */ createChildrenArray)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass OffsetView {\n  constructor(offsetMap, firstNode, blockOffsetSize = 1) {\n    this._offsetMap = offsetMap;\n    this._firstNode = firstNode;\n    this._blockOffsetSize = blockOffsetSize;\n  }\n  createSelectionFromOffsets(originalStart, originalEnd, diffOffsetView) {\n    const firstNode = this._firstNode;\n    if (firstNode === null) {\n      return null;\n    }\n    let start = originalStart;\n    let end = originalEnd;\n    let startOffsetNode = $searchForNodeWithOffset(firstNode, start, this._blockOffsetSize);\n    let endOffsetNode = $searchForNodeWithOffset(firstNode, end, this._blockOffsetSize);\n    if (diffOffsetView !== undefined) {\n      start = $getAdjustedOffsetFromDiff(start, startOffsetNode, diffOffsetView, this, this._blockOffsetSize);\n      startOffsetNode = $searchForNodeWithOffset(firstNode, start, this._blockOffsetSize);\n      end = $getAdjustedOffsetFromDiff(end, endOffsetNode, diffOffsetView, this, this._blockOffsetSize);\n      endOffsetNode = $searchForNodeWithOffset(firstNode, end, this._blockOffsetSize);\n    }\n    if (startOffsetNode === null || endOffsetNode === null) {\n      return null;\n    }\n    let startKey = startOffsetNode.key;\n    let endKey = endOffsetNode.key;\n    const startNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(startKey);\n    const endNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(endKey);\n    if (startNode === null || endNode === null) {\n      return null;\n    }\n    let startOffset = 0;\n    let endOffset = 0;\n    let startType = 'element';\n    let endType = 'element';\n    if (startOffsetNode.type === 'text') {\n      startOffset = start - startOffsetNode.start;\n      startType = 'text';\n      // If we are at the edge of a text node and we\n      // don't have a collapsed selection, then let's\n      // try and correct the offset node.\n      const sibling = startNode.getNextSibling();\n      if (start !== end && startOffset === startNode.getTextContentSize() && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(sibling)) {\n        startOffset = 0;\n        startKey = sibling.__key;\n      }\n    } else if (startOffsetNode.type === 'inline') {\n      startKey = startNode.getParentOrThrow().getKey();\n      startOffset = end > startOffsetNode.start ? startOffsetNode.end : startOffsetNode.start;\n    }\n    if (endOffsetNode.type === 'text') {\n      endOffset = end - endOffsetNode.start;\n      endType = 'text';\n    } else if (endOffsetNode.type === 'inline') {\n      endKey = endNode.getParentOrThrow().getKey();\n      endOffset = end > endOffsetNode.start ? endOffsetNode.end : endOffsetNode.start;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n    if (selection === null) {\n      return null;\n    }\n    selection.anchor.set(startKey, startOffset, startType);\n    selection.focus.set(endKey, endOffset, endType);\n    return selection;\n  }\n  getOffsetsFromSelection(selection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const offsetMap = this._offsetMap;\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    let start = -1;\n    let end = -1;\n    if (anchor.type === 'text') {\n      const offsetNode = offsetMap.get(anchor.key);\n      if (offsetNode !== undefined) {\n        start = offsetNode.start + anchorOffset;\n      }\n    } else {\n      const node = anchor.getNode().getDescendantByIndex(anchorOffset);\n      if (node !== null) {\n        const offsetNode = offsetMap.get(node.getKey());\n        if (offsetNode !== undefined) {\n          const isAtEnd = node.getIndexWithinParent() !== anchorOffset;\n          start = isAtEnd ? offsetNode.end : offsetNode.start;\n        }\n      }\n    }\n    if (focus.type === 'text') {\n      const offsetNode = offsetMap.get(focus.key);\n      if (offsetNode !== undefined) {\n        end = offsetNode.start + focus.offset;\n      }\n    } else {\n      const node = focus.getNode().getDescendantByIndex(focusOffset);\n      if (node !== null) {\n        const offsetNode = offsetMap.get(node.getKey());\n        if (offsetNode !== undefined) {\n          const isAtEnd = node.getIndexWithinParent() !== focusOffset;\n          end = isAtEnd ? offsetNode.end : offsetNode.start;\n        }\n      }\n    }\n    return [start, end];\n  }\n}\nfunction $getAdjustedOffsetFromDiff(offset, offsetNode, prevOffsetView, offsetView, blockOffsetSize) {\n  const prevOffsetMap = prevOffsetView._offsetMap;\n  const offsetMap = offsetView._offsetMap;\n  const visited = new Set();\n  let adjustedOffset = offset;\n  let currentNode = offsetNode;\n  while (currentNode !== null) {\n    const key = currentNode.key;\n    const prevNode = prevOffsetMap.get(key);\n    const diff = currentNode.end - currentNode.start;\n    visited.add(key);\n    if (prevNode === undefined) {\n      adjustedOffset += diff;\n    } else {\n      const prevDiff = prevNode.end - prevNode.start;\n      if (prevDiff !== diff) {\n        adjustedOffset += diff - prevDiff;\n      }\n    }\n    const sibling = currentNode.prev;\n    if (sibling !== null) {\n      currentNode = sibling;\n      continue;\n    }\n    let parent = currentNode.parent;\n    while (parent !== null) {\n      let parentSibling = parent.prev;\n      if (parentSibling !== null) {\n        const parentSiblingKey = parentSibling.key;\n        const prevParentSibling = prevOffsetMap.get(parentSiblingKey);\n        const parentDiff = parentSibling.end - parentSibling.start;\n        visited.add(parentSiblingKey);\n        if (prevParentSibling === undefined) {\n          adjustedOffset += parentDiff;\n        } else {\n          const prevParentDiff = prevParentSibling.end - prevParentSibling.start;\n          if (prevParentDiff !== parentDiff) {\n            adjustedOffset += parentDiff - prevParentDiff;\n          }\n        }\n        parentSibling = parentSibling.prev;\n      }\n      parent = parent.parent;\n    }\n    break;\n  }\n\n  // Now traverse through the old offsets nodes and find any nodes we missed\n  // above, because they were not in the latest offset node view (they have been\n  // deleted).\n  const prevFirstNode = prevOffsetView._firstNode;\n  if (prevFirstNode !== null) {\n    currentNode = $searchForNodeWithOffset(prevFirstNode, offset, blockOffsetSize);\n    let alreadyVisitedParentOfCurrentNode = false;\n    while (currentNode !== null) {\n      if (!visited.has(currentNode.key)) {\n        alreadyVisitedParentOfCurrentNode = true;\n        break;\n      }\n      currentNode = currentNode.parent;\n    }\n    if (!alreadyVisitedParentOfCurrentNode) {\n      while (currentNode !== null) {\n        const key = currentNode.key;\n        if (!visited.has(key)) {\n          const node = offsetMap.get(key);\n          const prevDiff = currentNode.end - currentNode.start;\n          if (node === undefined) {\n            adjustedOffset -= prevDiff;\n          } else {\n            const diff = node.end - node.start;\n            if (prevDiff !== diff) {\n              adjustedOffset += diff - prevDiff;\n            }\n          }\n        }\n        currentNode = currentNode.prev;\n      }\n    }\n  }\n  return adjustedOffset;\n}\nfunction $searchForNodeWithOffset(firstNode, offset, blockOffsetSize) {\n  let currentNode = firstNode;\n  while (currentNode !== null) {\n    const end = currentNode.end + (currentNode.type !== 'element' || blockOffsetSize === 0 ? 1 : 0);\n    if (offset < end) {\n      const child = currentNode.child;\n      if (child !== null) {\n        currentNode = child;\n        continue;\n      }\n      return currentNode;\n    }\n    const sibling = currentNode.next;\n    if (sibling === null) {\n      break;\n    }\n    currentNode = sibling;\n  }\n  return null;\n}\nfunction $createInternalOffsetNode(child, type, start, end, key, parent) {\n  return {\n    child,\n    end,\n    key,\n    next: null,\n    parent,\n    prev: null,\n    start,\n    type\n  };\n}\nfunction $createOffsetNode(state, key, parent, nodeMap, offsetMap, blockOffsetSize) {\n  const node = nodeMap.get(key);\n  if (node === undefined) {\n    {\n      throw Error(`createOffsetModel: could not find node by key`);\n    }\n  }\n  const start = state.offset;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    const childKeys = $createChildrenArray(node, nodeMap);\n    const blockIsEmpty = childKeys.length === 0;\n    const child = blockIsEmpty ? null : $createOffsetChild(state, childKeys, null, nodeMap, offsetMap, blockOffsetSize);\n\n    // If the prev node was not a block or the block is empty, we should\n    // account for the user being able to selection the block (due to the \\n).\n    if (!state.prevIsBlock || blockIsEmpty) {\n      state.prevIsBlock = true;\n      state.offset += blockOffsetSize;\n    }\n    const offsetNode = $createInternalOffsetNode(child, 'element', start, start, key, parent);\n    if (child !== null) {\n      child.parent = offsetNode;\n    }\n    const end = state.offset;\n    offsetNode.end = end;\n    offsetMap.set(key, offsetNode);\n    return offsetNode;\n  }\n  state.prevIsBlock = false;\n  const isText = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node);\n  const length = isText ? node.__text.length : 1;\n  const end = state.offset += length;\n  const offsetNode = $createInternalOffsetNode(null, isText ? 'text' : 'inline', start, end, key, parent);\n  offsetMap.set(key, offsetNode);\n  return offsetNode;\n}\nfunction $createOffsetChild(state, children, parent, nodeMap, offsetMap, blockOffsetSize) {\n  let firstNode = null;\n  let currentNode = null;\n  const childrenLength = children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const childKey = children[i];\n    const offsetNode = $createOffsetNode(state, childKey, parent, nodeMap, offsetMap, blockOffsetSize);\n    if (currentNode === null) {\n      firstNode = offsetNode;\n    } else {\n      offsetNode.prev = currentNode;\n      currentNode.next = offsetNode;\n    }\n    currentNode = offsetNode;\n  }\n  return firstNode;\n}\nfunction $createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap === null ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(nodeKey) : nodeMap.get(nodeKey);\n    if (node === null || node === undefined) {\n      {\n        throw Error(`$createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\n/** @deprecated renamed to {@link $createChildrenArray} by @lexical/eslint-plugin rules-of-lexical */\nconst createChildrenArray = $createChildrenArray;\nfunction $createOffsetView(editor, blockOffsetSize = 1, editorState) {\n  const targetEditorState = editorState || editor._pendingEditorState || editor._editorState;\n  const nodeMap = targetEditorState._nodeMap;\n  const root = nodeMap.get('root');\n  const offsetMap = new Map();\n  const state = {\n    offset: 0,\n    prevIsBlock: false\n  };\n  const node = $createOffsetChild(state, $createChildrenArray(root, nodeMap), null, nodeMap, offsetMap, blockOffsetSize);\n  return new OffsetView(offsetMap, node, blockOffsetSize);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvb2Zmc2V0L0xleGljYWxPZmZzZXQuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0Rjs7QUFFNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBYTtBQUNuQyxvQkFBb0Isc0RBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxvREFBVztBQUN4RjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4REFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQWM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9EQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNEQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXZlZG9jcy8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9vZmZzZXQvTGV4aWNhbE9mZnNldC5kZXYubWpzP2UzY2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkZ2V0Tm9kZUJ5S2V5LCAkaXNUZXh0Tm9kZSwgJGNyZWF0ZVJhbmdlU2VsZWN0aW9uLCAkaXNFbGVtZW50Tm9kZSB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNsYXNzIE9mZnNldFZpZXcge1xuICBjb25zdHJ1Y3RvcihvZmZzZXRNYXAsIGZpcnN0Tm9kZSwgYmxvY2tPZmZzZXRTaXplID0gMSkge1xuICAgIHRoaXMuX29mZnNldE1hcCA9IG9mZnNldE1hcDtcbiAgICB0aGlzLl9maXJzdE5vZGUgPSBmaXJzdE5vZGU7XG4gICAgdGhpcy5fYmxvY2tPZmZzZXRTaXplID0gYmxvY2tPZmZzZXRTaXplO1xuICB9XG4gIGNyZWF0ZVNlbGVjdGlvbkZyb21PZmZzZXRzKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kLCBkaWZmT2Zmc2V0Vmlldykge1xuICAgIGNvbnN0IGZpcnN0Tm9kZSA9IHRoaXMuX2ZpcnN0Tm9kZTtcbiAgICBpZiAoZmlyc3ROb2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ID0gb3JpZ2luYWxTdGFydDtcbiAgICBsZXQgZW5kID0gb3JpZ2luYWxFbmQ7XG4gICAgbGV0IHN0YXJ0T2Zmc2V0Tm9kZSA9ICRzZWFyY2hGb3JOb2RlV2l0aE9mZnNldChmaXJzdE5vZGUsIHN0YXJ0LCB0aGlzLl9ibG9ja09mZnNldFNpemUpO1xuICAgIGxldCBlbmRPZmZzZXROb2RlID0gJHNlYXJjaEZvck5vZGVXaXRoT2Zmc2V0KGZpcnN0Tm9kZSwgZW5kLCB0aGlzLl9ibG9ja09mZnNldFNpemUpO1xuICAgIGlmIChkaWZmT2Zmc2V0VmlldyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGFydCA9ICRnZXRBZGp1c3RlZE9mZnNldEZyb21EaWZmKHN0YXJ0LCBzdGFydE9mZnNldE5vZGUsIGRpZmZPZmZzZXRWaWV3LCB0aGlzLCB0aGlzLl9ibG9ja09mZnNldFNpemUpO1xuICAgICAgc3RhcnRPZmZzZXROb2RlID0gJHNlYXJjaEZvck5vZGVXaXRoT2Zmc2V0KGZpcnN0Tm9kZSwgc3RhcnQsIHRoaXMuX2Jsb2NrT2Zmc2V0U2l6ZSk7XG4gICAgICBlbmQgPSAkZ2V0QWRqdXN0ZWRPZmZzZXRGcm9tRGlmZihlbmQsIGVuZE9mZnNldE5vZGUsIGRpZmZPZmZzZXRWaWV3LCB0aGlzLCB0aGlzLl9ibG9ja09mZnNldFNpemUpO1xuICAgICAgZW5kT2Zmc2V0Tm9kZSA9ICRzZWFyY2hGb3JOb2RlV2l0aE9mZnNldChmaXJzdE5vZGUsIGVuZCwgdGhpcy5fYmxvY2tPZmZzZXRTaXplKTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0T2Zmc2V0Tm9kZSA9PT0gbnVsbCB8fCBlbmRPZmZzZXROb2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHN0YXJ0S2V5ID0gc3RhcnRPZmZzZXROb2RlLmtleTtcbiAgICBsZXQgZW5kS2V5ID0gZW5kT2Zmc2V0Tm9kZS5rZXk7XG4gICAgY29uc3Qgc3RhcnROb2RlID0gJGdldE5vZGVCeUtleShzdGFydEtleSk7XG4gICAgY29uc3QgZW5kTm9kZSA9ICRnZXROb2RlQnlLZXkoZW5kS2V5KTtcbiAgICBpZiAoc3RhcnROb2RlID09PSBudWxsIHx8IGVuZE5vZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgc3RhcnRPZmZzZXQgPSAwO1xuICAgIGxldCBlbmRPZmZzZXQgPSAwO1xuICAgIGxldCBzdGFydFR5cGUgPSAnZWxlbWVudCc7XG4gICAgbGV0IGVuZFR5cGUgPSAnZWxlbWVudCc7XG4gICAgaWYgKHN0YXJ0T2Zmc2V0Tm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gc3RhcnQgLSBzdGFydE9mZnNldE5vZGUuc3RhcnQ7XG4gICAgICBzdGFydFR5cGUgPSAndGV4dCc7XG4gICAgICAvLyBJZiB3ZSBhcmUgYXQgdGhlIGVkZ2Ugb2YgYSB0ZXh0IG5vZGUgYW5kIHdlXG4gICAgICAvLyBkb24ndCBoYXZlIGEgY29sbGFwc2VkIHNlbGVjdGlvbiwgdGhlbiBsZXQnc1xuICAgICAgLy8gdHJ5IGFuZCBjb3JyZWN0IHRoZSBvZmZzZXQgbm9kZS5cbiAgICAgIGNvbnN0IHNpYmxpbmcgPSBzdGFydE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIGlmIChzdGFydCAhPT0gZW5kICYmIHN0YXJ0T2Zmc2V0ID09PSBzdGFydE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgJiYgJGlzVGV4dE5vZGUoc2libGluZykpIHtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICBzdGFydEtleSA9IHNpYmxpbmcuX19rZXk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGFydE9mZnNldE5vZGUudHlwZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIHN0YXJ0S2V5ID0gc3RhcnROb2RlLmdldFBhcmVudE9yVGhyb3coKS5nZXRLZXkoKTtcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gZW5kID4gc3RhcnRPZmZzZXROb2RlLnN0YXJ0ID8gc3RhcnRPZmZzZXROb2RlLmVuZCA6IHN0YXJ0T2Zmc2V0Tm9kZS5zdGFydDtcbiAgICB9XG4gICAgaWYgKGVuZE9mZnNldE5vZGUudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBlbmRPZmZzZXQgPSBlbmQgLSBlbmRPZmZzZXROb2RlLnN0YXJ0O1xuICAgICAgZW5kVHlwZSA9ICd0ZXh0JztcbiAgICB9IGVsc2UgaWYgKGVuZE9mZnNldE5vZGUudHlwZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIGVuZEtleSA9IGVuZE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLmdldEtleSgpO1xuICAgICAgZW5kT2Zmc2V0ID0gZW5kID4gZW5kT2Zmc2V0Tm9kZS5zdGFydCA/IGVuZE9mZnNldE5vZGUuZW5kIDogZW5kT2Zmc2V0Tm9kZS5zdGFydDtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uKCk7XG4gICAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5hbmNob3Iuc2V0KHN0YXJ0S2V5LCBzdGFydE9mZnNldCwgc3RhcnRUeXBlKTtcbiAgICBzZWxlY3Rpb24uZm9jdXMuc2V0KGVuZEtleSwgZW5kT2Zmc2V0LCBlbmRUeXBlKTtcbiAgICByZXR1cm4gc2VsZWN0aW9uO1xuICB9XG4gIGdldE9mZnNldHNGcm9tU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgY29uc3Qgb2Zmc2V0TWFwID0gdGhpcy5fb2Zmc2V0TWFwO1xuICAgIGNvbnN0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgY29uc3QgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gICAgbGV0IHN0YXJ0ID0gLTE7XG4gICAgbGV0IGVuZCA9IC0xO1xuICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBjb25zdCBvZmZzZXROb2RlID0gb2Zmc2V0TWFwLmdldChhbmNob3Iua2V5KTtcbiAgICAgIGlmIChvZmZzZXROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RhcnQgPSBvZmZzZXROb2RlLnN0YXJ0ICsgYW5jaG9yT2Zmc2V0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub2RlID0gYW5jaG9yLmdldE5vZGUoKS5nZXREZXNjZW5kYW50QnlJbmRleChhbmNob3JPZmZzZXQpO1xuICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0Tm9kZSA9IG9mZnNldE1hcC5nZXQobm9kZS5nZXRLZXkoKSk7XG4gICAgICAgIGlmIChvZmZzZXROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBpc0F0RW5kID0gbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpICE9PSBhbmNob3JPZmZzZXQ7XG4gICAgICAgICAgc3RhcnQgPSBpc0F0RW5kID8gb2Zmc2V0Tm9kZS5lbmQgOiBvZmZzZXROb2RlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmb2N1cy50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIGNvbnN0IG9mZnNldE5vZGUgPSBvZmZzZXRNYXAuZ2V0KGZvY3VzLmtleSk7XG4gICAgICBpZiAob2Zmc2V0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IG9mZnNldE5vZGUuc3RhcnQgKyBmb2N1cy5vZmZzZXQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBmb2N1cy5nZXROb2RlKCkuZ2V0RGVzY2VuZGFudEJ5SW5kZXgoZm9jdXNPZmZzZXQpO1xuICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0Tm9kZSA9IG9mZnNldE1hcC5nZXQobm9kZS5nZXRLZXkoKSk7XG4gICAgICAgIGlmIChvZmZzZXROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBpc0F0RW5kID0gbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpICE9PSBmb2N1c09mZnNldDtcbiAgICAgICAgICBlbmQgPSBpc0F0RW5kID8gb2Zmc2V0Tm9kZS5lbmQgOiBvZmZzZXROb2RlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbc3RhcnQsIGVuZF07XG4gIH1cbn1cbmZ1bmN0aW9uICRnZXRBZGp1c3RlZE9mZnNldEZyb21EaWZmKG9mZnNldCwgb2Zmc2V0Tm9kZSwgcHJldk9mZnNldFZpZXcsIG9mZnNldFZpZXcsIGJsb2NrT2Zmc2V0U2l6ZSkge1xuICBjb25zdCBwcmV2T2Zmc2V0TWFwID0gcHJldk9mZnNldFZpZXcuX29mZnNldE1hcDtcbiAgY29uc3Qgb2Zmc2V0TWFwID0gb2Zmc2V0Vmlldy5fb2Zmc2V0TWFwO1xuICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICBsZXQgYWRqdXN0ZWRPZmZzZXQgPSBvZmZzZXQ7XG4gIGxldCBjdXJyZW50Tm9kZSA9IG9mZnNldE5vZGU7XG4gIHdoaWxlIChjdXJyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGtleSA9IGN1cnJlbnROb2RlLmtleTtcbiAgICBjb25zdCBwcmV2Tm9kZSA9IHByZXZPZmZzZXRNYXAuZ2V0KGtleSk7XG4gICAgY29uc3QgZGlmZiA9IGN1cnJlbnROb2RlLmVuZCAtIGN1cnJlbnROb2RlLnN0YXJ0O1xuICAgIHZpc2l0ZWQuYWRkKGtleSk7XG4gICAgaWYgKHByZXZOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFkanVzdGVkT2Zmc2V0ICs9IGRpZmY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZXZEaWZmID0gcHJldk5vZGUuZW5kIC0gcHJldk5vZGUuc3RhcnQ7XG4gICAgICBpZiAocHJldkRpZmYgIT09IGRpZmYpIHtcbiAgICAgICAgYWRqdXN0ZWRPZmZzZXQgKz0gZGlmZiAtIHByZXZEaWZmO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzaWJsaW5nID0gY3VycmVudE5vZGUucHJldjtcbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgY3VycmVudE5vZGUgPSBzaWJsaW5nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBwYXJlbnQgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgbGV0IHBhcmVudFNpYmxpbmcgPSBwYXJlbnQucHJldjtcbiAgICAgIGlmIChwYXJlbnRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFNpYmxpbmdLZXkgPSBwYXJlbnRTaWJsaW5nLmtleTtcbiAgICAgICAgY29uc3QgcHJldlBhcmVudFNpYmxpbmcgPSBwcmV2T2Zmc2V0TWFwLmdldChwYXJlbnRTaWJsaW5nS2V5KTtcbiAgICAgICAgY29uc3QgcGFyZW50RGlmZiA9IHBhcmVudFNpYmxpbmcuZW5kIC0gcGFyZW50U2libGluZy5zdGFydDtcbiAgICAgICAgdmlzaXRlZC5hZGQocGFyZW50U2libGluZ0tleSk7XG4gICAgICAgIGlmIChwcmV2UGFyZW50U2libGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYWRqdXN0ZWRPZmZzZXQgKz0gcGFyZW50RGlmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwcmV2UGFyZW50RGlmZiA9IHByZXZQYXJlbnRTaWJsaW5nLmVuZCAtIHByZXZQYXJlbnRTaWJsaW5nLnN0YXJ0O1xuICAgICAgICAgIGlmIChwcmV2UGFyZW50RGlmZiAhPT0gcGFyZW50RGlmZikge1xuICAgICAgICAgICAgYWRqdXN0ZWRPZmZzZXQgKz0gcGFyZW50RGlmZiAtIHByZXZQYXJlbnREaWZmO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJlbnRTaWJsaW5nID0gcGFyZW50U2libGluZy5wcmV2O1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBOb3cgdHJhdmVyc2UgdGhyb3VnaCB0aGUgb2xkIG9mZnNldHMgbm9kZXMgYW5kIGZpbmQgYW55IG5vZGVzIHdlIG1pc3NlZFxuICAvLyBhYm92ZSwgYmVjYXVzZSB0aGV5IHdlcmUgbm90IGluIHRoZSBsYXRlc3Qgb2Zmc2V0IG5vZGUgdmlldyAodGhleSBoYXZlIGJlZW5cbiAgLy8gZGVsZXRlZCkuXG4gIGNvbnN0IHByZXZGaXJzdE5vZGUgPSBwcmV2T2Zmc2V0Vmlldy5fZmlyc3ROb2RlO1xuICBpZiAocHJldkZpcnN0Tm9kZSAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnROb2RlID0gJHNlYXJjaEZvck5vZGVXaXRoT2Zmc2V0KHByZXZGaXJzdE5vZGUsIG9mZnNldCwgYmxvY2tPZmZzZXRTaXplKTtcbiAgICBsZXQgYWxyZWFkeVZpc2l0ZWRQYXJlbnRPZkN1cnJlbnROb2RlID0gZmFsc2U7XG4gICAgd2hpbGUgKGN1cnJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGN1cnJlbnROb2RlLmtleSkpIHtcbiAgICAgICAgYWxyZWFkeVZpc2l0ZWRQYXJlbnRPZkN1cnJlbnROb2RlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFhbHJlYWR5VmlzaXRlZFBhcmVudE9mQ3VycmVudE5vZGUpIHtcbiAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBrZXkgPSBjdXJyZW50Tm9kZS5rZXk7XG4gICAgICAgIGlmICghdmlzaXRlZC5oYXMoa2V5KSkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBvZmZzZXRNYXAuZ2V0KGtleSk7XG4gICAgICAgICAgY29uc3QgcHJldkRpZmYgPSBjdXJyZW50Tm9kZS5lbmQgLSBjdXJyZW50Tm9kZS5zdGFydDtcbiAgICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhZGp1c3RlZE9mZnNldCAtPSBwcmV2RGlmZjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IG5vZGUuZW5kIC0gbm9kZS5zdGFydDtcbiAgICAgICAgICAgIGlmIChwcmV2RGlmZiAhPT0gZGlmZikge1xuICAgICAgICAgICAgICBhZGp1c3RlZE9mZnNldCArPSBkaWZmIC0gcHJldkRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucHJldjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFkanVzdGVkT2Zmc2V0O1xufVxuZnVuY3Rpb24gJHNlYXJjaEZvck5vZGVXaXRoT2Zmc2V0KGZpcnN0Tm9kZSwgb2Zmc2V0LCBibG9ja09mZnNldFNpemUpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gZmlyc3ROb2RlO1xuICB3aGlsZSAoY3VycmVudE5vZGUgIT09IG51bGwpIHtcbiAgICBjb25zdCBlbmQgPSBjdXJyZW50Tm9kZS5lbmQgKyAoY3VycmVudE5vZGUudHlwZSAhPT0gJ2VsZW1lbnQnIHx8IGJsb2NrT2Zmc2V0U2l6ZSA9PT0gMCA/IDEgOiAwKTtcbiAgICBpZiAob2Zmc2V0IDwgZW5kKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGN1cnJlbnROb2RlLmNoaWxkO1xuICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH1cbiAgICBjb25zdCBzaWJsaW5nID0gY3VycmVudE5vZGUubmV4dDtcbiAgICBpZiAoc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGN1cnJlbnROb2RlID0gc2libGluZztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRjcmVhdGVJbnRlcm5hbE9mZnNldE5vZGUoY2hpbGQsIHR5cGUsIHN0YXJ0LCBlbmQsIGtleSwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgY2hpbGQsXG4gICAgZW5kLFxuICAgIGtleSxcbiAgICBuZXh0OiBudWxsLFxuICAgIHBhcmVudCxcbiAgICBwcmV2OiBudWxsLFxuICAgIHN0YXJ0LFxuICAgIHR5cGVcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVPZmZzZXROb2RlKHN0YXRlLCBrZXksIHBhcmVudCwgbm9kZU1hcCwgb2Zmc2V0TWFwLCBibG9ja09mZnNldFNpemUpIHtcbiAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KGtleSk7XG4gIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgY3JlYXRlT2Zmc2V0TW9kZWw6IGNvdWxkIG5vdCBmaW5kIG5vZGUgYnkga2V5YCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0YXJ0ID0gc3RhdGUub2Zmc2V0O1xuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBjaGlsZEtleXMgPSAkY3JlYXRlQ2hpbGRyZW5BcnJheShub2RlLCBub2RlTWFwKTtcbiAgICBjb25zdCBibG9ja0lzRW1wdHkgPSBjaGlsZEtleXMubGVuZ3RoID09PSAwO1xuICAgIGNvbnN0IGNoaWxkID0gYmxvY2tJc0VtcHR5ID8gbnVsbCA6ICRjcmVhdGVPZmZzZXRDaGlsZChzdGF0ZSwgY2hpbGRLZXlzLCBudWxsLCBub2RlTWFwLCBvZmZzZXRNYXAsIGJsb2NrT2Zmc2V0U2l6ZSk7XG5cbiAgICAvLyBJZiB0aGUgcHJldiBub2RlIHdhcyBub3QgYSBibG9jayBvciB0aGUgYmxvY2sgaXMgZW1wdHksIHdlIHNob3VsZFxuICAgIC8vIGFjY291bnQgZm9yIHRoZSB1c2VyIGJlaW5nIGFibGUgdG8gc2VsZWN0aW9uIHRoZSBibG9jayAoZHVlIHRvIHRoZSBcXG4pLlxuICAgIGlmICghc3RhdGUucHJldklzQmxvY2sgfHwgYmxvY2tJc0VtcHR5KSB7XG4gICAgICBzdGF0ZS5wcmV2SXNCbG9jayA9IHRydWU7XG4gICAgICBzdGF0ZS5vZmZzZXQgKz0gYmxvY2tPZmZzZXRTaXplO1xuICAgIH1cbiAgICBjb25zdCBvZmZzZXROb2RlID0gJGNyZWF0ZUludGVybmFsT2Zmc2V0Tm9kZShjaGlsZCwgJ2VsZW1lbnQnLCBzdGFydCwgc3RhcnQsIGtleSwgcGFyZW50KTtcbiAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkLnBhcmVudCA9IG9mZnNldE5vZGU7XG4gICAgfVxuICAgIGNvbnN0IGVuZCA9IHN0YXRlLm9mZnNldDtcbiAgICBvZmZzZXROb2RlLmVuZCA9IGVuZDtcbiAgICBvZmZzZXRNYXAuc2V0KGtleSwgb2Zmc2V0Tm9kZSk7XG4gICAgcmV0dXJuIG9mZnNldE5vZGU7XG4gIH1cbiAgc3RhdGUucHJldklzQmxvY2sgPSBmYWxzZTtcbiAgY29uc3QgaXNUZXh0ID0gJGlzVGV4dE5vZGUobm9kZSk7XG4gIGNvbnN0IGxlbmd0aCA9IGlzVGV4dCA/IG5vZGUuX190ZXh0Lmxlbmd0aCA6IDE7XG4gIGNvbnN0IGVuZCA9IHN0YXRlLm9mZnNldCArPSBsZW5ndGg7XG4gIGNvbnN0IG9mZnNldE5vZGUgPSAkY3JlYXRlSW50ZXJuYWxPZmZzZXROb2RlKG51bGwsIGlzVGV4dCA/ICd0ZXh0JyA6ICdpbmxpbmUnLCBzdGFydCwgZW5kLCBrZXksIHBhcmVudCk7XG4gIG9mZnNldE1hcC5zZXQoa2V5LCBvZmZzZXROb2RlKTtcbiAgcmV0dXJuIG9mZnNldE5vZGU7XG59XG5mdW5jdGlvbiAkY3JlYXRlT2Zmc2V0Q2hpbGQoc3RhdGUsIGNoaWxkcmVuLCBwYXJlbnQsIG5vZGVNYXAsIG9mZnNldE1hcCwgYmxvY2tPZmZzZXRTaXplKSB7XG4gIGxldCBmaXJzdE5vZGUgPSBudWxsO1xuICBsZXQgY3VycmVudE5vZGUgPSBudWxsO1xuICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGRLZXkgPSBjaGlsZHJlbltpXTtcbiAgICBjb25zdCBvZmZzZXROb2RlID0gJGNyZWF0ZU9mZnNldE5vZGUoc3RhdGUsIGNoaWxkS2V5LCBwYXJlbnQsIG5vZGVNYXAsIG9mZnNldE1hcCwgYmxvY2tPZmZzZXRTaXplKTtcbiAgICBpZiAoY3VycmVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgIGZpcnN0Tm9kZSA9IG9mZnNldE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldE5vZGUucHJldiA9IGN1cnJlbnROb2RlO1xuICAgICAgY3VycmVudE5vZGUubmV4dCA9IG9mZnNldE5vZGU7XG4gICAgfVxuICAgIGN1cnJlbnROb2RlID0gb2Zmc2V0Tm9kZTtcbiAgfVxuICByZXR1cm4gZmlyc3ROb2RlO1xufVxuZnVuY3Rpb24gJGNyZWF0ZUNoaWxkcmVuQXJyYXkoZWxlbWVudCwgbm9kZU1hcCkge1xuICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICBsZXQgbm9kZUtleSA9IGVsZW1lbnQuX19maXJzdDtcbiAgd2hpbGUgKG5vZGVLZXkgIT09IG51bGwpIHtcbiAgICBjb25zdCBub2RlID0gbm9kZU1hcCA9PT0gbnVsbCA/ICRnZXROb2RlQnlLZXkobm9kZUtleSkgOiBub2RlTWFwLmdldChub2RlS2V5KTtcbiAgICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYCRjcmVhdGVDaGlsZHJlbkFycmF5OiBub2RlIGRvZXMgbm90IGV4aXN0IGluIG5vZGVNYXBgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2hpbGRyZW4ucHVzaChub2RlS2V5KTtcbiAgICBub2RlS2V5ID0gbm9kZS5fX25leHQ7XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuLyoqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8ge0BsaW5rICRjcmVhdGVDaGlsZHJlbkFycmF5fSBieSBAbGV4aWNhbC9lc2xpbnQtcGx1Z2luIHJ1bGVzLW9mLWxleGljYWwgKi9cbmNvbnN0IGNyZWF0ZUNoaWxkcmVuQXJyYXkgPSAkY3JlYXRlQ2hpbGRyZW5BcnJheTtcbmZ1bmN0aW9uICRjcmVhdGVPZmZzZXRWaWV3KGVkaXRvciwgYmxvY2tPZmZzZXRTaXplID0gMSwgZWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgdGFyZ2V0RWRpdG9yU3RhdGUgPSBlZGl0b3JTdGF0ZSB8fCBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZSB8fCBlZGl0b3IuX2VkaXRvclN0YXRlO1xuICBjb25zdCBub2RlTWFwID0gdGFyZ2V0RWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGNvbnN0IHJvb3QgPSBub2RlTWFwLmdldCgncm9vdCcpO1xuICBjb25zdCBvZmZzZXRNYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIG9mZnNldDogMCxcbiAgICBwcmV2SXNCbG9jazogZmFsc2VcbiAgfTtcbiAgY29uc3Qgbm9kZSA9ICRjcmVhdGVPZmZzZXRDaGlsZChzdGF0ZSwgJGNyZWF0ZUNoaWxkcmVuQXJyYXkocm9vdCwgbm9kZU1hcCksIG51bGwsIG5vZGVNYXAsIG9mZnNldE1hcCwgYmxvY2tPZmZzZXRTaXplKTtcbiAgcmV0dXJuIG5ldyBPZmZzZXRWaWV3KG9mZnNldE1hcCwgbm9kZSwgYmxvY2tPZmZzZXRTaXplKTtcbn1cblxuZXhwb3J0IHsgJGNyZWF0ZUNoaWxkcmVuQXJyYXksICRjcmVhdGVPZmZzZXRWaWV3LCBPZmZzZXRWaWV3LCBjcmVhdGVDaGlsZHJlbkFycmF5IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/offset/LexicalOffset.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoFocusPlugin: () => (/* binding */ AutoFocusPlugin)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction AutoFocusPlugin({\n  defaultSelection\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    editor.focus(() => {\n      // If we try and move selection to the same point with setBaseAndExtent, it won't\n      // trigger a re-focus on the element. So in the case this occurs, we'll need to correct it.\n      // Normally this is fine, Selection API !== Focus API, but fore the intents of the naming\n      // of this plugin, which should preserve focus too.\n      const activeElement = document.activeElement;\n      const rootElement = editor.getRootElement();\n      if (rootElement !== null && (activeElement === null || !rootElement.contains(activeElement))) {\n        // Note: preventScroll won't work in Webkit.\n        rootElement.focus({\n          preventScroll: true\n        });\n      }\n    }, {\n      defaultSelection\n    });\n  }, [defaultSelection, editor]);\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEF1dG9Gb2N1c1BsdWdpbi5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRjtBQUNoRDs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUIsZ0dBQXlCO0FBQzVDLEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUUyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdmVkb2NzLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxBdXRvRm9jdXNQbHVnaW4uZGV2Lm1qcz8zMmMzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIEF1dG9Gb2N1c1BsdWdpbih7XG4gIGRlZmF1bHRTZWxlY3Rpb25cbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZWRpdG9yLmZvY3VzKCgpID0+IHtcbiAgICAgIC8vIElmIHdlIHRyeSBhbmQgbW92ZSBzZWxlY3Rpb24gdG8gdGhlIHNhbWUgcG9pbnQgd2l0aCBzZXRCYXNlQW5kRXh0ZW50LCBpdCB3b24ndFxuICAgICAgLy8gdHJpZ2dlciBhIHJlLWZvY3VzIG9uIHRoZSBlbGVtZW50LiBTbyBpbiB0aGUgY2FzZSB0aGlzIG9jY3Vycywgd2UnbGwgbmVlZCB0byBjb3JyZWN0IGl0LlxuICAgICAgLy8gTm9ybWFsbHkgdGhpcyBpcyBmaW5lLCBTZWxlY3Rpb24gQVBJICE9PSBGb2N1cyBBUEksIGJ1dCBmb3JlIHRoZSBpbnRlbnRzIG9mIHRoZSBuYW1pbmdcbiAgICAgIC8vIG9mIHRoaXMgcGx1Z2luLCB3aGljaCBzaG91bGQgcHJlc2VydmUgZm9jdXMgdG9vLlxuICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgICAgaWYgKHJvb3RFbGVtZW50ICE9PSBudWxsICYmIChhY3RpdmVFbGVtZW50ID09PSBudWxsIHx8ICFyb290RWxlbWVudC5jb250YWlucyhhY3RpdmVFbGVtZW50KSkpIHtcbiAgICAgICAgLy8gTm90ZTogcHJldmVudFNjcm9sbCB3b24ndCB3b3JrIGluIFdlYmtpdC5cbiAgICAgICAgcm9vdEVsZW1lbnQuZm9jdXMoe1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZGVmYXVsdFNlbGVjdGlvblxuICAgIH0pO1xuICB9LCBbZGVmYXVsdFNlbGVjdGlvbiwgZWRpdG9yXSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBBdXRvRm9jdXNQbHVnaW4gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalCollaborationContext.dev.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalCollaborationContext.dev.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollaborationContext: () => (/* binding */ CollaborationContext),\n/* harmony export */   useCollaborationContext: () => (/* binding */ useCollaborationContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst entries = [['Cat', 'rgb(125, 50, 0)'], ['Dog', 'rgb(100, 0, 0)'], ['Rabbit', 'rgb(150, 0, 0)'], ['Frog', 'rgb(200, 0, 0)'], ['Fox', 'rgb(200, 75, 0)'], ['Hedgehog', 'rgb(0, 75, 0)'], ['Pigeon', 'rgb(0, 125, 0)'], ['Squirrel', 'rgb(75, 100, 0)'], ['Bear', 'rgb(125, 100, 0)'], ['Tiger', 'rgb(0, 0, 150)'], ['Leopard', 'rgb(0, 0, 200)'], ['Zebra', 'rgb(0, 0, 250)'], ['Wolf', 'rgb(0, 100, 150)'], ['Owl', 'rgb(0, 100, 100)'], ['Gull', 'rgb(100, 0, 100)'], ['Squid', 'rgb(150, 0, 150)']];\nconst randomEntry = entries[Math.floor(Math.random() * entries.length)];\nconst CollaborationContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  clientID: 0,\n  color: randomEntry[1],\n  isCollabActive: false,\n  name: randomEntry[0],\n  yjsDocMap: new Map()\n});\nfunction useCollaborationContext(username, color) {\n  const collabContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CollaborationContext);\n  if (username != null) {\n    collabContext.name = username;\n  }\n  if (color != null) {\n    collabContext.color = color;\n  }\n  return collabContext;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbGxhYm9yYXRpb25Db250ZXh0LmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLG9EQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx3QkFBd0IsaURBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXZlZG9jcy8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29sbGFib3JhdGlvbkNvbnRleHQuZGV2Lm1qcz84YzgwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBlbnRyaWVzID0gW1snQ2F0JywgJ3JnYigxMjUsIDUwLCAwKSddLCBbJ0RvZycsICdyZ2IoMTAwLCAwLCAwKSddLCBbJ1JhYmJpdCcsICdyZ2IoMTUwLCAwLCAwKSddLCBbJ0Zyb2cnLCAncmdiKDIwMCwgMCwgMCknXSwgWydGb3gnLCAncmdiKDIwMCwgNzUsIDApJ10sIFsnSGVkZ2Vob2cnLCAncmdiKDAsIDc1LCAwKSddLCBbJ1BpZ2VvbicsICdyZ2IoMCwgMTI1LCAwKSddLCBbJ1NxdWlycmVsJywgJ3JnYig3NSwgMTAwLCAwKSddLCBbJ0JlYXInLCAncmdiKDEyNSwgMTAwLCAwKSddLCBbJ1RpZ2VyJywgJ3JnYigwLCAwLCAxNTApJ10sIFsnTGVvcGFyZCcsICdyZ2IoMCwgMCwgMjAwKSddLCBbJ1plYnJhJywgJ3JnYigwLCAwLCAyNTApJ10sIFsnV29sZicsICdyZ2IoMCwgMTAwLCAxNTApJ10sIFsnT3dsJywgJ3JnYigwLCAxMDAsIDEwMCknXSwgWydHdWxsJywgJ3JnYigxMDAsIDAsIDEwMCknXSwgWydTcXVpZCcsICdyZ2IoMTUwLCAwLCAxNTApJ11dO1xuY29uc3QgcmFuZG9tRW50cnkgPSBlbnRyaWVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGVudHJpZXMubGVuZ3RoKV07XG5jb25zdCBDb2xsYWJvcmF0aW9uQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHtcbiAgY2xpZW50SUQ6IDAsXG4gIGNvbG9yOiByYW5kb21FbnRyeVsxXSxcbiAgaXNDb2xsYWJBY3RpdmU6IGZhbHNlLFxuICBuYW1lOiByYW5kb21FbnRyeVswXSxcbiAgeWpzRG9jTWFwOiBuZXcgTWFwKClcbn0pO1xuZnVuY3Rpb24gdXNlQ29sbGFib3JhdGlvbkNvbnRleHQodXNlcm5hbWUsIGNvbG9yKSB7XG4gIGNvbnN0IGNvbGxhYkNvbnRleHQgPSB1c2VDb250ZXh0KENvbGxhYm9yYXRpb25Db250ZXh0KTtcbiAgaWYgKHVzZXJuYW1lICE9IG51bGwpIHtcbiAgICBjb2xsYWJDb250ZXh0Lm5hbWUgPSB1c2VybmFtZTtcbiAgfVxuICBpZiAoY29sb3IgIT0gbnVsbCkge1xuICAgIGNvbGxhYkNvbnRleHQuY29sb3IgPSBjb2xvcjtcbiAgfVxuICByZXR1cm4gY29sbGFiQ29udGV4dDtcbn1cblxuZXhwb3J0IHsgQ29sbGFib3JhdGlvbkNvbnRleHQsIHVzZUNvbGxhYm9yYXRpb25Db250ZXh0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalCollaborationContext.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalCollaborationPlugin.dev.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalCollaborationPlugin.dev.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollaborationPlugin: () => (/* binding */ CollaborationPlugin)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalCollaborationContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lexical/react/LexicalCollaborationContext */ \"(ssr)/./node_modules/@lexical/react/LexicalCollaborationContext.dev.mjs\");\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/yjs */ \"(ssr)/./node_modules/@lexical/yjs/LexicalYjs.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useYjsCollaboration(editor, id, provider, docMap, name, color, shouldBootstrap, binding, setDoc, cursorsContainerRef, initialEditorState, awarenessData) {\n  const isReloadingDoc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    provider.connect();\n  }, [provider]);\n  const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    try {\n      provider.disconnect();\n    } catch (e) {\n      // Do nothing\n    }\n  }, [provider]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const {\n      root\n    } = binding;\n    const {\n      awareness\n    } = provider;\n    const onStatus = ({\n      status\n    }) => {\n      editor.dispatchCommand(_lexical_yjs__WEBPACK_IMPORTED_MODULE_3__.CONNECTED_COMMAND, status === 'connected');\n    };\n    const onSync = isSynced => {\n      if (shouldBootstrap && isSynced && root.isEmpty() && root._xmlText._length === 0 && isReloadingDoc.current === false) {\n        initializeEditor(editor, initialEditorState);\n      }\n      isReloadingDoc.current = false;\n    };\n    const onAwarenessUpdate = () => {\n      (0,_lexical_yjs__WEBPACK_IMPORTED_MODULE_3__.syncCursorPositions)(binding, provider);\n    };\n    const onYjsTreeChanges = (events, transaction) => {\n      const origin = transaction.origin;\n      if (origin !== binding) {\n        const isFromUndoManger = origin instanceof yjs__WEBPACK_IMPORTED_MODULE_4__.UndoManager;\n        (0,_lexical_yjs__WEBPACK_IMPORTED_MODULE_3__.syncYjsChangesToLexical)(binding, provider, events, isFromUndoManger);\n      }\n    };\n    (0,_lexical_yjs__WEBPACK_IMPORTED_MODULE_3__.initLocalState)(provider, name, color, document.activeElement === editor.getRootElement(), awarenessData || {});\n    const onProviderDocReload = ydoc => {\n      clearEditorSkipCollab(editor, binding);\n      setDoc(ydoc);\n      docMap.set(id, ydoc);\n      isReloadingDoc.current = true;\n    };\n    provider.on('reload', onProviderDocReload);\n    provider.on('status', onStatus);\n    provider.on('sync', onSync);\n    awareness.on('update', onAwarenessUpdate);\n    // This updates the local editor state when we recieve updates from other clients\n    root.getSharedType().observeDeep(onYjsTreeChanges);\n    const removeListener = editor.registerUpdateListener(({\n      prevEditorState,\n      editorState,\n      dirtyLeaves,\n      dirtyElements,\n      normalizedNodes,\n      tags\n    }) => {\n      if (tags.has('skip-collab') === false) {\n        (0,_lexical_yjs__WEBPACK_IMPORTED_MODULE_3__.syncLexicalUpdateToYjs)(binding, provider, prevEditorState, editorState, dirtyElements, dirtyLeaves, normalizedNodes, tags);\n      }\n    });\n    connect();\n    return () => {\n      if (isReloadingDoc.current === false) {\n        disconnect();\n      }\n      provider.off('sync', onSync);\n      provider.off('status', onStatus);\n      provider.off('reload', onProviderDocReload);\n      awareness.off('update', onAwarenessUpdate);\n      root.getSharedType().unobserveDeep(onYjsTreeChanges);\n      docMap.delete(id);\n      removeListener();\n    };\n  }, [binding, color, connect, disconnect, docMap, editor, id, initialEditorState, name, provider, shouldBootstrap, awarenessData, setDoc]);\n  const cursorsContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const ref = element => {\n      binding.cursorsContainer = element;\n    };\n    return /*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n      ref: ref\n    }), cursorsContainerRef && cursorsContainerRef.current || document.body);\n  }, [binding, cursorsContainerRef]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return editor.registerCommand(_lexical_yjs__WEBPACK_IMPORTED_MODULE_3__.TOGGLE_CONNECT_COMMAND, payload => {\n      if (connect !== undefined && disconnect !== undefined) {\n        const shouldConnect = payload;\n        if (shouldConnect) {\n          // eslint-disable-next-line no-console\n          console.log('Collaboration connected!');\n          connect();\n        } else {\n          // eslint-disable-next-line no-console\n          console.log('Collaboration disconnected!');\n          disconnect();\n        }\n      }\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_5__.COMMAND_PRIORITY_EDITOR);\n  }, [connect, disconnect, editor]);\n  return cursorsContainer;\n}\nfunction useYjsFocusTracking(editor, provider, name, color, awarenessData) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_6__.mergeRegister)(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_5__.FOCUS_COMMAND, () => {\n      (0,_lexical_yjs__WEBPACK_IMPORTED_MODULE_3__.setLocalStateFocus)(provider, name, color, true, awarenessData || {});\n      return false;\n    }, lexical__WEBPACK_IMPORTED_MODULE_5__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_5__.BLUR_COMMAND, () => {\n      (0,_lexical_yjs__WEBPACK_IMPORTED_MODULE_3__.setLocalStateFocus)(provider, name, color, false, awarenessData || {});\n      return false;\n    }, lexical__WEBPACK_IMPORTED_MODULE_5__.COMMAND_PRIORITY_EDITOR));\n  }, [color, editor, name, provider, awarenessData]);\n}\nfunction useYjsHistory(editor, binding) {\n  const undoManager = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_lexical_yjs__WEBPACK_IMPORTED_MODULE_3__.createUndoManager)(binding, binding.root.getSharedType()), [binding]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const undo = () => {\n      undoManager.undo();\n    };\n    const redo = () => {\n      undoManager.redo();\n    };\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_6__.mergeRegister)(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_5__.UNDO_COMMAND, () => {\n      undo();\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_5__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_5__.REDO_COMMAND, () => {\n      redo();\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_5__.COMMAND_PRIORITY_EDITOR));\n  });\n  const clearHistory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    undoManager.clear();\n  }, [undoManager]);\n\n  // Exposing undo and redo states\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const updateUndoRedoStates = () => {\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_5__.CAN_UNDO_COMMAND, undoManager.undoStack.length > 0);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_5__.CAN_REDO_COMMAND, undoManager.redoStack.length > 0);\n    };\n    undoManager.on('stack-item-added', updateUndoRedoStates);\n    undoManager.on('stack-item-popped', updateUndoRedoStates);\n    undoManager.on('stack-cleared', updateUndoRedoStates);\n    return () => {\n      undoManager.off('stack-item-added', updateUndoRedoStates);\n      undoManager.off('stack-item-popped', updateUndoRedoStates);\n      undoManager.off('stack-cleared', updateUndoRedoStates);\n    };\n  }, [editor, undoManager]);\n  return clearHistory;\n}\nfunction initializeEditor(editor, initialEditorState) {\n  editor.update(() => {\n    const root = (0,lexical__WEBPACK_IMPORTED_MODULE_5__.$getRoot)();\n    if (root.isEmpty()) {\n      if (initialEditorState) {\n        switch (typeof initialEditorState) {\n          case 'string':\n            {\n              const parsedEditorState = editor.parseEditorState(initialEditorState);\n              editor.setEditorState(parsedEditorState, {\n                tag: 'history-merge'\n              });\n              break;\n            }\n          case 'object':\n            {\n              editor.setEditorState(initialEditorState, {\n                tag: 'history-merge'\n              });\n              break;\n            }\n          case 'function':\n            {\n              editor.update(() => {\n                const root1 = (0,lexical__WEBPACK_IMPORTED_MODULE_5__.$getRoot)();\n                if (root1.isEmpty()) {\n                  initialEditorState(editor);\n                }\n              }, {\n                tag: 'history-merge'\n              });\n              break;\n            }\n        }\n      } else {\n        const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_5__.$createParagraphNode)();\n        root.append(paragraph);\n        const {\n          activeElement\n        } = document;\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_5__.$getSelection)() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }\n  }, {\n    tag: 'history-merge'\n  });\n}\nfunction clearEditorSkipCollab(editor, binding) {\n  // reset editor state\n  editor.update(() => {\n    const root = (0,lexical__WEBPACK_IMPORTED_MODULE_5__.$getRoot)();\n    root.clear();\n    root.select();\n  }, {\n    tag: 'skip-collab'\n  });\n  if (binding.cursors == null) {\n    return;\n  }\n  const cursors = binding.cursors;\n  if (cursors == null) {\n    return;\n  }\n  const cursorsContainer = binding.cursorsContainer;\n  if (cursorsContainer == null) {\n    return;\n  }\n\n  // reset cursors in dom\n  const cursorsArr = Array.from(cursors.values());\n  for (let i = 0; i < cursorsArr.length; i++) {\n    const cursor = cursorsArr[i];\n    const selection = cursor.selection;\n    if (selection && selection.selections != null) {\n      const selections = selection.selections;\n      for (let j = 0; j < selections.length; j++) {\n        cursorsContainer.removeChild(selections[i]);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction CollaborationPlugin({\n  id,\n  providerFactory,\n  shouldBootstrap,\n  username,\n  cursorColor,\n  cursorsContainerRef,\n  initialEditorState,\n  excludedProperties,\n  awarenessData\n}) {\n  const isBindingInitialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const isProviderInitialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const collabContext = (0,_lexical_react_LexicalCollaborationContext__WEBPACK_IMPORTED_MODULE_7__.useCollaborationContext)(username, cursorColor);\n  const {\n    yjsDocMap,\n    name,\n    color\n  } = collabContext;\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_8__.useLexicalComposerContext)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    collabContext.isCollabActive = true;\n    return () => {\n      // Reseting flag only when unmount top level editor collab plugin. Nested\n      // editors (e.g. image caption) should unmount without affecting it\n      if (editor._parentEditor == null) {\n        collabContext.isCollabActive = false;\n      }\n    };\n  }, [collabContext, editor]);\n  const [provider, setProvider] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (isProviderInitialized.current) {\n      return;\n    }\n    isProviderInitialized.current = true;\n    const newProvider = providerFactory(id, yjsDocMap);\n    setProvider(newProvider);\n    return () => {\n      newProvider.disconnect();\n    };\n  }, [id, providerFactory, yjsDocMap]);\n  const [doc, setDoc] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(yjsDocMap.get(id));\n  const [binding, setBinding] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!provider) {\n      return;\n    }\n    if (isBindingInitialized.current) {\n      return;\n    }\n    isBindingInitialized.current = true;\n    const newBinding = (0,_lexical_yjs__WEBPACK_IMPORTED_MODULE_3__.createBinding)(editor, provider, id, doc || yjsDocMap.get(id), yjsDocMap, excludedProperties);\n    setBinding(newBinding);\n    return () => {\n      newBinding.root.destroy(newBinding);\n    };\n  }, [editor, provider, id, yjsDocMap, doc, excludedProperties]);\n  if (!provider || !binding) {\n    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {});\n  }\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(YjsCollaborationCursors, {\n    awarenessData: awarenessData,\n    binding: binding,\n    collabContext: collabContext,\n    color: color,\n    cursorsContainerRef: cursorsContainerRef,\n    editor: editor,\n    id: id,\n    initialEditorState: initialEditorState,\n    name: name,\n    provider: provider,\n    setDoc: setDoc,\n    shouldBootstrap: shouldBootstrap,\n    yjsDocMap: yjsDocMap\n  });\n}\nfunction YjsCollaborationCursors({\n  editor,\n  id,\n  provider,\n  yjsDocMap,\n  name,\n  color,\n  shouldBootstrap,\n  cursorsContainerRef,\n  initialEditorState,\n  awarenessData,\n  collabContext,\n  binding,\n  setDoc\n}) {\n  const cursors = useYjsCollaboration(editor, id, provider, yjsDocMap, name, color, shouldBootstrap, binding, setDoc, cursorsContainerRef, initialEditorState, awarenessData);\n  collabContext.clientID = binding.clientID;\n  useYjsHistory(editor, binding);\n  useYjsFocusTracking(editor, provider, name, color, awarenessData);\n  return cursors;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbGxhYm9yYXRpb25QbHVnaW4uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFGO0FBQ0g7QUFDbUk7QUFDdEw7QUFDMkM7QUFDM0I7QUFDK0k7QUFDcko7QUFDUDtBQUNnQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsNkNBQU07QUFDL0Isa0JBQWtCLGtEQUFXO0FBQzdCO0FBQ0EsR0FBRztBQUNILHFCQUFxQixrREFBVztBQUNoQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QiwyREFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0saUVBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDRDQUFXO0FBQzlELFFBQVEscUVBQXVCO0FBQy9CO0FBQ0E7QUFDQSxJQUFJLDREQUFjLCtGQUErRjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFFBQVEsb0VBQXNCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDJCQUEyQiw4Q0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdURBQVksZUFBZSxzREFBRztBQUN0RDtB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QUcsQ0FBQyx1REFBUSxJQUFJO0FBQ3hDO0FBQ0Esc0JBQXNCLHNEQUFHO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl2ZWRvY3MvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbGxhYm9yYXRpb25QbHVnaW4uZGV2Lm1qcz9lNDM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgdXNlQ29sbGFib3JhdGlvbkNvbnRleHQgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29sbGFib3JhdGlvbkNvbnRleHQnO1xuaW1wb3J0IHsgdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnO1xuaW1wb3J0IHsgaW5pdExvY2FsU3RhdGUsIHN5bmNMZXhpY2FsVXBkYXRlVG9ZanMsIFRPR0dMRV9DT05ORUNUX0NPTU1BTkQsIHNldExvY2FsU3RhdGVGb2N1cywgY3JlYXRlVW5kb01hbmFnZXIsIENPTk5FQ1RFRF9DT01NQU5ELCBzeW5jQ3Vyc29yUG9zaXRpb25zLCBzeW5jWWpzQ2hhbmdlc1RvTGV4aWNhbCwgY3JlYXRlQmluZGluZyB9IGZyb20gJ0BsZXhpY2FsL3lqcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VSZWYsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbWVyZ2VSZWdpc3RlciB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7IENPTU1BTkRfUFJJT1JJVFlfRURJVE9SLCBGT0NVU19DT01NQU5ELCBCTFVSX0NPTU1BTkQsIFVORE9fQ09NTUFORCwgUkVET19DT01NQU5ELCBDQU5fVU5ET19DT01NQU5ELCBDQU5fUkVET19DT01NQU5ELCAkZ2V0Um9vdCwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsICRnZXRTZWxlY3Rpb24gfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBVbmRvTWFuYWdlciB9IGZyb20gJ3lqcyc7XG5pbXBvcnQgeyBqc3gsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHVzZVlqc0NvbGxhYm9yYXRpb24oZWRpdG9yLCBpZCwgcHJvdmlkZXIsIGRvY01hcCwgbmFtZSwgY29sb3IsIHNob3VsZEJvb3RzdHJhcCwgYmluZGluZywgc2V0RG9jLCBjdXJzb3JzQ29udGFpbmVyUmVmLCBpbml0aWFsRWRpdG9yU3RhdGUsIGF3YXJlbmVzc0RhdGEpIHtcbiAgY29uc3QgaXNSZWxvYWRpbmdEb2MgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCBjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHByb3ZpZGVyLmNvbm5lY3QoKTtcbiAgfSwgW3Byb3ZpZGVyXSk7XG4gIGNvbnN0IGRpc2Nvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHByb3ZpZGVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBEbyBub3RoaW5nXG4gICAgfVxuICB9LCBbcHJvdmlkZXJdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICByb290XG4gICAgfSA9IGJpbmRpbmc7XG4gICAgY29uc3Qge1xuICAgICAgYXdhcmVuZXNzXG4gICAgfSA9IHByb3ZpZGVyO1xuICAgIGNvbnN0IG9uU3RhdHVzID0gKHtcbiAgICAgIHN0YXR1c1xuICAgIH0pID0+IHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoQ09OTkVDVEVEX0NPTU1BTkQsIHN0YXR1cyA9PT0gJ2Nvbm5lY3RlZCcpO1xuICAgIH07XG4gICAgY29uc3Qgb25TeW5jID0gaXNTeW5jZWQgPT4ge1xuICAgICAgaWYgKHNob3VsZEJvb3RzdHJhcCAmJiBpc1N5bmNlZCAmJiByb290LmlzRW1wdHkoKSAmJiByb290Ll94bWxUZXh0Ll9sZW5ndGggPT09IDAgJiYgaXNSZWxvYWRpbmdEb2MuY3VycmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaW5pdGlhbGl6ZUVkaXRvcihlZGl0b3IsIGluaXRpYWxFZGl0b3JTdGF0ZSk7XG4gICAgICB9XG4gICAgICBpc1JlbG9hZGluZ0RvYy5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBvbkF3YXJlbmVzc1VwZGF0ZSA9ICgpID0+IHtcbiAgICAgIHN5bmNDdXJzb3JQb3NpdGlvbnMoYmluZGluZywgcHJvdmlkZXIpO1xuICAgIH07XG4gICAgY29uc3Qgb25ZanNUcmVlQ2hhbmdlcyA9IChldmVudHMsIHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW4gPSB0cmFuc2FjdGlvbi5vcmlnaW47XG4gICAgICBpZiAob3JpZ2luICE9PSBiaW5kaW5nKSB7XG4gICAgICAgIGNvbnN0IGlzRnJvbVVuZG9NYW5nZXIgPSBvcmlnaW4gaW5zdGFuY2VvZiBVbmRvTWFuYWdlcjtcbiAgICAgICAgc3luY1lqc0NoYW5nZXNUb0xleGljYWwoYmluZGluZywgcHJvdmlkZXIsIGV2ZW50cywgaXNGcm9tVW5kb01hbmdlcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBpbml0TG9jYWxTdGF0ZShwcm92aWRlciwgbmFtZSwgY29sb3IsIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVkaXRvci5nZXRSb290RWxlbWVudCgpLCBhd2FyZW5lc3NEYXRhIHx8IHt9KTtcbiAgICBjb25zdCBvblByb3ZpZGVyRG9jUmVsb2FkID0geWRvYyA9PiB7XG4gICAgICBjbGVhckVkaXRvclNraXBDb2xsYWIoZWRpdG9yLCBiaW5kaW5nKTtcbiAgICAgIHNldERvYyh5ZG9jKTtcbiAgICAgIGRvY01hcC5zZXQoaWQsIHlkb2MpO1xuICAgICAgaXNSZWxvYWRpbmdEb2MuY3VycmVudCA9IHRydWU7XG4gICAgfTtcbiAgICBwcm92aWRlci5vbigncmVsb2FkJywgb25Qcm92aWRlckRvY1JlbG9hZCk7XG4gICAgcHJvdmlkZXIub24oJ3N0YXR1cycsIG9uU3RhdHVzKTtcbiAgICBwcm92aWRlci5vbignc3luYycsIG9uU3luYyk7XG4gICAgYXdhcmVuZXNzLm9uKCd1cGRhdGUnLCBvbkF3YXJlbmVzc1VwZGF0ZSk7XG4gICAgLy8gVGhpcyB1cGRhdGVzIHRoZSBsb2NhbCBlZGl0b3Igc3RhdGUgd2hlbiB3ZSByZWNpZXZlIHVwZGF0ZXMgZnJvbSBvdGhlciBjbGllbnRzXG4gICAgcm9vdC5nZXRTaGFyZWRUeXBlKCkub2JzZXJ2ZURlZXAob25ZanNUcmVlQ2hhbmdlcyk7XG4gICAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSBlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoe1xuICAgICAgcHJldkVkaXRvclN0YXRlLFxuICAgICAgZWRpdG9yU3RhdGUsXG4gICAgICBkaXJ0eUxlYXZlcyxcbiAgICAgIGRpcnR5RWxlbWVudHMsXG4gICAgICBub3JtYWxpemVkTm9kZXMsXG4gICAgICB0YWdzXG4gICAgfSkgPT4ge1xuICAgICAgaWYgKHRhZ3MuaGFzKCdza2lwLWNvbGxhYicpID09PSBmYWxzZSkge1xuICAgICAgICBzeW5jTGV4aWNhbFVwZGF0ZVRvWWpzKGJpbmRpbmcsIHByb3ZpZGVyLCBwcmV2RWRpdG9yU3RhdGUsIGVkaXRvclN0YXRlLCBkaXJ0eUVsZW1lbnRzLCBkaXJ0eUxlYXZlcywgbm9ybWFsaXplZE5vZGVzLCB0YWdzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25uZWN0KCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChpc1JlbG9hZGluZ0RvYy5jdXJyZW50ID09PSBmYWxzZSkge1xuICAgICAgICBkaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgICBwcm92aWRlci5vZmYoJ3N5bmMnLCBvblN5bmMpO1xuICAgICAgcHJvdmlkZXIub2ZmKCdzdGF0dXMnLCBvblN0YXR1cyk7XG4gICAgICBwcm92aWRlci5vZmYoJ3JlbG9hZCcsIG9uUHJvdmlkZXJEb2NSZWxvYWQpO1xuICAgICAgYXdhcmVuZXNzLm9mZigndXBkYXRlJywgb25Bd2FyZW5lc3NVcGRhdGUpO1xuICAgICAgcm9vdC5nZXRTaGFyZWRUeXBlKCkudW5vYnNlcnZlRGVlcChvbllqc1RyZWVDaGFuZ2VzKTtcbiAgICAgIGRvY01hcC5kZWxldGUoaWQpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9LCBbYmluZGluZywgY29sb3IsIGNvbm5lY3QsIGRpc2Nvbm5lY3QsIGRvY01hcCwgZWRpdG9yLCBpZCwgaW5pdGlhbEVkaXRvclN0YXRlLCBuYW1lLCBwcm92aWRlciwgc2hvdWxkQm9vdHN0cmFwLCBhd2FyZW5lc3NEYXRhLCBzZXREb2NdKTtcbiAgY29uc3QgY3Vyc29yc0NvbnRhaW5lciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHJlZiA9IGVsZW1lbnQgPT4ge1xuICAgICAgYmluZGluZy5jdXJzb3JzQ29udGFpbmVyID0gZWxlbWVudDtcbiAgICB9O1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovY3JlYXRlUG9ydGFsKCAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICAgIHJlZjogcmVmXG4gICAgfSksIGN1cnNvcnNDb250YWluZXJSZWYgJiYgY3Vyc29yc0NvbnRhaW5lclJlZi5jdXJyZW50IHx8IGRvY3VtZW50LmJvZHkpO1xuICB9LCBbYmluZGluZywgY3Vyc29yc0NvbnRhaW5lclJlZl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFRPR0dMRV9DT05ORUNUX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgICAgaWYgKGNvbm5lY3QgIT09IHVuZGVmaW5lZCAmJiBkaXNjb25uZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkQ29ubmVjdCA9IHBheWxvYWQ7XG4gICAgICAgIGlmIChzaG91bGRDb25uZWN0KSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ29sbGFib3JhdGlvbiBjb25uZWN0ZWQhJyk7XG4gICAgICAgICAgY29ubmVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS5sb2coJ0NvbGxhYm9yYXRpb24gZGlzY29ubmVjdGVkIScpO1xuICAgICAgICAgIGRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpO1xuICB9LCBbY29ubmVjdCwgZGlzY29ubmVjdCwgZWRpdG9yXSk7XG4gIHJldHVybiBjdXJzb3JzQ29udGFpbmVyO1xufVxuZnVuY3Rpb24gdXNlWWpzRm9jdXNUcmFja2luZyhlZGl0b3IsIHByb3ZpZGVyLCBuYW1lLCBjb2xvciwgYXdhcmVuZXNzRGF0YSkge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoRk9DVVNfQ09NTUFORCwgKCkgPT4ge1xuICAgICAgc2V0TG9jYWxTdGF0ZUZvY3VzKHByb3ZpZGVyLCBuYW1lLCBjb2xvciwgdHJ1ZSwgYXdhcmVuZXNzRGF0YSB8fCB7fSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEJMVVJfQ09NTUFORCwgKCkgPT4ge1xuICAgICAgc2V0TG9jYWxTdGF0ZUZvY3VzKHByb3ZpZGVyLCBuYW1lLCBjb2xvciwgZmFsc2UsIGF3YXJlbmVzc0RhdGEgfHwge30pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSk7XG4gIH0sIFtjb2xvciwgZWRpdG9yLCBuYW1lLCBwcm92aWRlciwgYXdhcmVuZXNzRGF0YV0pO1xufVxuZnVuY3Rpb24gdXNlWWpzSGlzdG9yeShlZGl0b3IsIGJpbmRpbmcpIHtcbiAgY29uc3QgdW5kb01hbmFnZXIgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZVVuZG9NYW5hZ2VyKGJpbmRpbmcsIGJpbmRpbmcucm9vdC5nZXRTaGFyZWRUeXBlKCkpLCBbYmluZGluZ10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICB1bmRvTWFuYWdlci51bmRvKCk7XG4gICAgfTtcbiAgICBjb25zdCByZWRvID0gKCkgPT4ge1xuICAgICAgdW5kb01hbmFnZXIucmVkbygpO1xuICAgIH07XG4gICAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChVTkRPX0NPTU1BTkQsICgpID0+IHtcbiAgICAgIHVuZG8oKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChSRURPX0NPTU1BTkQsICgpID0+IHtcbiAgICAgIHJlZG8oKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSk7XG4gIH0pO1xuICBjb25zdCBjbGVhckhpc3RvcnkgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgdW5kb01hbmFnZXIuY2xlYXIoKTtcbiAgfSwgW3VuZG9NYW5hZ2VyXSk7XG5cbiAgLy8gRXhwb3NpbmcgdW5kbyBhbmQgcmVkbyBzdGF0ZXNcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVVbmRvUmVkb1N0YXRlcyA9ICgpID0+IHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoQ0FOX1VORE9fQ09NTUFORCwgdW5kb01hbmFnZXIudW5kb1N0YWNrLmxlbmd0aCA+IDApO1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fUkVET19DT01NQU5ELCB1bmRvTWFuYWdlci5yZWRvU3RhY2subGVuZ3RoID4gMCk7XG4gICAgfTtcbiAgICB1bmRvTWFuYWdlci5vbignc3RhY2staXRlbS1hZGRlZCcsIHVwZGF0ZVVuZG9SZWRvU3RhdGVzKTtcbiAgICB1bmRvTWFuYWdlci5vbignc3RhY2staXRlbS1wb3BwZWQnLCB1cGRhdGVVbmRvUmVkb1N0YXRlcyk7XG4gICAgdW5kb01hbmFnZXIub24oJ3N0YWNrLWNsZWFyZWQnLCB1cGRhdGVVbmRvUmVkb1N0YXRlcyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVuZG9NYW5hZ2VyLm9mZignc3RhY2staXRlbS1hZGRlZCcsIHVwZGF0ZVVuZG9SZWRvU3RhdGVzKTtcbiAgICAgIHVuZG9NYW5hZ2VyLm9mZignc3RhY2staXRlbS1wb3BwZWQnLCB1cGRhdGVVbmRvUmVkb1N0YXRlcyk7XG4gICAgICB1bmRvTWFuYWdlci5vZmYoJ3N0YWNrLWNsZWFyZWQnLCB1cGRhdGVVbmRvUmVkb1N0YXRlcyk7XG4gICAgfTtcbiAgfSwgW2VkaXRvciwgdW5kb01hbmFnZXJdKTtcbiAgcmV0dXJuIGNsZWFySGlzdG9yeTtcbn1cbmZ1bmN0aW9uIGluaXRpYWxpemVFZGl0b3IoZWRpdG9yLCBpbml0aWFsRWRpdG9yU3RhdGUpIHtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gICAgaWYgKHJvb3QuaXNFbXB0eSgpKSB7XG4gICAgICBpZiAoaW5pdGlhbEVkaXRvclN0YXRlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIGluaXRpYWxFZGl0b3JTdGF0ZSkge1xuICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEVkaXRvclN0YXRlID0gZWRpdG9yLnBhcnNlRWRpdG9yU3RhdGUoaW5pdGlhbEVkaXRvclN0YXRlKTtcbiAgICAgICAgICAgICAgZWRpdG9yLnNldEVkaXRvclN0YXRlKHBhcnNlZEVkaXRvclN0YXRlLCB7XG4gICAgICAgICAgICAgICAgdGFnOiAnaGlzdG9yeS1tZXJnZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGVkaXRvci5zZXRFZGl0b3JTdGF0ZShpbml0aWFsRWRpdG9yU3RhdGUsIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdoaXN0b3J5LW1lcmdlJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByb290MSA9ICRnZXRSb290KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3QxLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEVkaXRvclN0YXRlKGVkaXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdGFnOiAnaGlzdG9yeS1tZXJnZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwYXJhZ3JhcGggPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICByb290LmFwcGVuZChwYXJhZ3JhcGgpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudFxuICAgICAgICB9ID0gZG9jdW1lbnQ7XG4gICAgICAgIGlmICgkZ2V0U2VsZWN0aW9uKCkgIT09IG51bGwgfHwgYWN0aXZlRWxlbWVudCAhPT0gbnVsbCAmJiBhY3RpdmVFbGVtZW50ID09PSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKSkge1xuICAgICAgICAgIHBhcmFncmFwaC5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIHRhZzogJ2hpc3RvcnktbWVyZ2UnXG4gIH0pO1xufVxuZnVuY3Rpb24gY2xlYXJFZGl0b3JTa2lwQ29sbGFiKGVkaXRvciwgYmluZGluZykge1xuICAvLyByZXNldCBlZGl0b3Igc3RhdGVcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gICAgcm9vdC5jbGVhcigpO1xuICAgIHJvb3Quc2VsZWN0KCk7XG4gIH0sIHtcbiAgICB0YWc6ICdza2lwLWNvbGxhYidcbiAgfSk7XG4gIGlmIChiaW5kaW5nLmN1cnNvcnMgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjdXJzb3JzID0gYmluZGluZy5jdXJzb3JzO1xuICBpZiAoY3Vyc29ycyA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGN1cnNvcnNDb250YWluZXIgPSBiaW5kaW5nLmN1cnNvcnNDb250YWluZXI7XG4gIGlmIChjdXJzb3JzQ29udGFpbmVyID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyByZXNldCBjdXJzb3JzIGluIGRvbVxuICBjb25zdCBjdXJzb3JzQXJyID0gQXJyYXkuZnJvbShjdXJzb3JzLnZhbHVlcygpKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJzb3JzQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3Vyc29yID0gY3Vyc29yc0FycltpXTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBjdXJzb3Iuc2VsZWN0aW9uO1xuICAgIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLnNlbGVjdGlvbnMgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2VsZWN0aW9ucyA9IHNlbGVjdGlvbi5zZWxlY3Rpb25zO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZWxlY3Rpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGN1cnNvcnNDb250YWluZXIucmVtb3ZlQ2hpbGQoc2VsZWN0aW9uc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gQ29sbGFib3JhdGlvblBsdWdpbih7XG4gIGlkLFxuICBwcm92aWRlckZhY3RvcnksXG4gIHNob3VsZEJvb3RzdHJhcCxcbiAgdXNlcm5hbWUsXG4gIGN1cnNvckNvbG9yLFxuICBjdXJzb3JzQ29udGFpbmVyUmVmLFxuICBpbml0aWFsRWRpdG9yU3RhdGUsXG4gIGV4Y2x1ZGVkUHJvcGVydGllcyxcbiAgYXdhcmVuZXNzRGF0YVxufSkge1xuICBjb25zdCBpc0JpbmRpbmdJbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGlzUHJvdmlkZXJJbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGNvbGxhYkNvbnRleHQgPSB1c2VDb2xsYWJvcmF0aW9uQ29udGV4dCh1c2VybmFtZSwgY3Vyc29yQ29sb3IpO1xuICBjb25zdCB7XG4gICAgeWpzRG9jTWFwLFxuICAgIG5hbWUsXG4gICAgY29sb3JcbiAgfSA9IGNvbGxhYkNvbnRleHQ7XG4gIGNvbnN0IFtlZGl0b3JdID0gdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbGxhYkNvbnRleHQuaXNDb2xsYWJBY3RpdmUgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBSZXNldGluZyBmbGFnIG9ubHkgd2hlbiB1bm1vdW50IHRvcCBsZXZlbCBlZGl0b3IgY29sbGFiIHBsdWdpbi4gTmVzdGVkXG4gICAgICAvLyBlZGl0b3JzIChlLmcuIGltYWdlIGNhcHRpb24pIHNob3VsZCB1bm1vdW50IHdpdGhvdXQgYWZmZWN0aW5nIGl0XG4gICAgICBpZiAoZWRpdG9yLl9wYXJlbnRFZGl0b3IgPT0gbnVsbCkge1xuICAgICAgICBjb2xsYWJDb250ZXh0LmlzQ29sbGFiQWN0aXZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2NvbGxhYkNvbnRleHQsIGVkaXRvcl0pO1xuICBjb25zdCBbcHJvdmlkZXIsIHNldFByb3ZpZGVyXSA9IHVzZVN0YXRlKCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzUHJvdmlkZXJJbml0aWFsaXplZC5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlzUHJvdmlkZXJJbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICBjb25zdCBuZXdQcm92aWRlciA9IHByb3ZpZGVyRmFjdG9yeShpZCwgeWpzRG9jTWFwKTtcbiAgICBzZXRQcm92aWRlcihuZXdQcm92aWRlcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG5ld1Byb3ZpZGVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbaWQsIHByb3ZpZGVyRmFjdG9yeSwgeWpzRG9jTWFwXSk7XG4gIGNvbnN0IFtkb2MsIHNldERvY10gPSB1c2VTdGF0ZSh5anNEb2NNYXAuZ2V0KGlkKSk7XG4gIGNvbnN0IFtiaW5kaW5nLCBzZXRCaW5kaW5nXSA9IHVzZVN0YXRlKCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNCaW5kaW5nSW5pdGlhbGl6ZWQuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc0JpbmRpbmdJbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICBjb25zdCBuZXdCaW5kaW5nID0gY3JlYXRlQmluZGluZyhlZGl0b3IsIHByb3ZpZGVyLCBpZCwgZG9jIHx8IHlqc0RvY01hcC5nZXQoaWQpLCB5anNEb2NNYXAsIGV4Y2x1ZGVkUHJvcGVydGllcyk7XG4gICAgc2V0QmluZGluZyhuZXdCaW5kaW5nKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbmV3QmluZGluZy5yb290LmRlc3Ryb3kobmV3QmluZGluZyk7XG4gICAgfTtcbiAgfSwgW2VkaXRvciwgcHJvdmlkZXIsIGlkLCB5anNEb2NNYXAsIGRvYywgZXhjbHVkZWRQcm9wZXJ0aWVzXSk7XG4gIGlmICghcHJvdmlkZXIgfHwgIWJpbmRpbmcpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL2pzeChGcmFnbWVudCwge30pO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFlqc0NvbGxhYm9yYXRpb25DdXJzb3JzLCB7XG4gICAgYXdhcmVuZXNzRGF0YTogYXdhcmVuZXNzRGF0YSxcbiAgICBiaW5kaW5nOiBiaW5kaW5nLFxuICAgIGNvbGxhYkNvbnRleHQ6IGNvbGxhYkNvbnRleHQsXG4gICAgY29sb3I6IGNvbG9yLFxuICAgIGN1cnNvcnNDb250YWluZXJSZWY6IGN1cnNvcnNDb250YWluZXJSZWYsXG4gICAgZWRpdG9yOiBlZGl0b3IsXG4gICAgaWQ6IGlkLFxuICAgIGluaXRpYWxFZGl0b3JTdGF0ZTogaW5pdGlhbEVkaXRvclN0YXRlLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcHJvdmlkZXI6IHByb3ZpZGVyLFxuICAgIHNldERvYzogc2V0RG9jLFxuICAgIHNob3VsZEJvb3RzdHJhcDogc2hvdWxkQm9vdHN0cmFwLFxuICAgIHlqc0RvY01hcDogeWpzRG9jTWFwXG4gIH0pO1xufVxuZnVuY3Rpb24gWWpzQ29sbGFib3JhdGlvbkN1cnNvcnMoe1xuICBlZGl0b3IsXG4gIGlkLFxuICBwcm92aWRlcixcbiAgeWpzRG9jTWFwLFxuICBuYW1lLFxuICBjb2xvcixcbiAgc2hvdWxkQm9vdHN0cmFwLFxuICBjdXJzb3JzQ29udGFpbmVyUmVmLFxuICBpbml0aWFsRWRpdG9yU3RhdGUsXG4gIGF3YXJlbmVzc0RhdGEsXG4gIGNvbGxhYkNvbnRleHQsXG4gIGJpbmRpbmcsXG4gIHNldERvY1xufSkge1xuICBjb25zdCBjdXJzb3JzID0gdXNlWWpzQ29sbGFib3JhdGlvbihlZGl0b3IsIGlkLCBwcm92aWRlciwgeWpzRG9jTWFwLCBuYW1lLCBjb2xvciwgc2hvdWxkQm9vdHN0cmFwLCBiaW5kaW5nLCBzZXREb2MsIGN1cnNvcnNDb250YWluZXJSZWYsIGluaXRpYWxFZGl0b3JTdGF0ZSwgYXdhcmVuZXNzRGF0YSk7XG4gIGNvbGxhYkNvbnRleHQuY2xpZW50SUQgPSBiaW5kaW5nLmNsaWVudElEO1xuICB1c2VZanNIaXN0b3J5KGVkaXRvciwgYmluZGluZyk7XG4gIHVzZVlqc0ZvY3VzVHJhY2tpbmcoZWRpdG9yLCBwcm92aWRlciwgbmFtZSwgY29sb3IsIGF3YXJlbmVzc0RhdGEpO1xuICByZXR1cm4gY3Vyc29ycztcbn1cblxuZXhwb3J0IHsgQ29sbGFib3JhdGlvblBsdWdpbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalCollaborationPlugin.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalComposer.dev.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposer.dev.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LexicalComposer: () => (/* binding */ LexicalComposer)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE_OPTIONS = {\n  tag: 'history-merge'\n};\nfunction LexicalComposer({\n  initialConfig,\n  children\n}) {\n  const composerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const {\n      theme,\n      namespace,\n      editor__DEPRECATED: initialEditor,\n      nodes,\n      onError,\n      editorState: initialEditorState,\n      html\n    } = initialConfig;\n    const context = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__.createLexicalComposerContext)(null, theme);\n    let editor = initialEditor || null;\n    if (editor === null) {\n      const newEditor = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.createEditor)({\n        editable: initialConfig.editable,\n        html,\n        namespace,\n        nodes,\n        onError: error => onError(error, newEditor),\n        theme\n      });\n      initializeEditor(newEditor, initialEditorState);\n      editor = newEditor;\n    }\n    return [editor, context];\n  },\n  // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useLayoutEffectImpl(() => {\n    const isEditable = initialConfig.editable;\n    const [editor] = composerContext;\n    editor.setEditable(isEditable !== undefined ? isEditable : true);\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__.LexicalComposerContext.Provider, {\n    value: composerContext,\n    children: children\n  });\n}\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getRoot)();\n      if (root.isEmpty()) {\n        const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$createParagraphNode)();\n        root.append(paragraph);\n        const activeElement = CAN_USE_DOM ? document.activeElement : null;\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getSelection)() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, HISTORY_MERGE_OPTIONS);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'function':\n        {\n          editor.update(() => {\n            const root = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getRoot)();\n            if (root.isEmpty()) {\n              initialEditorState(editor);\n            }\n          }, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n    }\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkc7QUFDdkI7QUFDMUI7QUFDcEI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0RBQWUsR0FBRyw0Q0FBUzs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDBCQUEwQiw4Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixtR0FBNEI7QUFDaEQ7QUFDQTtBQUNBLHdCQUF3QixxREFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0Isc0RBQUcsQ0FBQyx5RkFBc0I7QUFDaEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG1CQUFtQixpREFBUTtBQUMzQjtBQUNBLDBCQUEwQiw2REFBb0I7QUFDOUM7QUFDQTtBQUNBLFlBQVksc0RBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl2ZWRvY3MvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyLmRldi5tanM/ZTY5OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGNyZWF0ZUxleGljYWxDb21wb3NlckNvbnRleHQsIExleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0JztcbmltcG9ydCB7IGNyZWF0ZUVkaXRvciwgJGdldFJvb3QsICRjcmVhdGVQYXJhZ3JhcGhOb2RlLCAkZ2V0U2VsZWN0aW9uIH0gZnJvbSAnbGV4aWNhbCc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vLyBUaGlzIHdvcmthcm91bmQgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSBpbiBSZWFjdCAxOSxcbi8vIGJ1dCB3ZSBjdXJyZW50bHkgc3VwcG9ydCBSZWFjdCA+PTE3Lnhcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI2Mzk1XG5jb25zdCB1c2VMYXlvdXRFZmZlY3RJbXBsID0gQ0FOX1VTRV9ET00gPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgSElTVE9SWV9NRVJHRV9PUFRJT05TID0ge1xuICB0YWc6ICdoaXN0b3J5LW1lcmdlJ1xufTtcbmZ1bmN0aW9uIExleGljYWxDb21wb3Nlcih7XG4gIGluaXRpYWxDb25maWcsXG4gIGNoaWxkcmVuXG59KSB7XG4gIGNvbnN0IGNvbXBvc2VyQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHRoZW1lLFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgZWRpdG9yX19ERVBSRUNBVEVEOiBpbml0aWFsRWRpdG9yLFxuICAgICAgbm9kZXMsXG4gICAgICBvbkVycm9yLFxuICAgICAgZWRpdG9yU3RhdGU6IGluaXRpYWxFZGl0b3JTdGF0ZSxcbiAgICAgIGh0bWxcbiAgICB9ID0gaW5pdGlhbENvbmZpZztcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTGV4aWNhbENvbXBvc2VyQ29udGV4dChudWxsLCB0aGVtZSk7XG4gICAgbGV0IGVkaXRvciA9IGluaXRpYWxFZGl0b3IgfHwgbnVsbDtcbiAgICBpZiAoZWRpdG9yID09PSBudWxsKSB7XG4gICAgICBjb25zdCBuZXdFZGl0b3IgPSBjcmVhdGVFZGl0b3Ioe1xuICAgICAgICBlZGl0YWJsZTogaW5pdGlhbENvbmZpZy5lZGl0YWJsZSxcbiAgICAgICAgaHRtbCxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBub2RlcyxcbiAgICAgICAgb25FcnJvcjogZXJyb3IgPT4gb25FcnJvcihlcnJvciwgbmV3RWRpdG9yKSxcbiAgICAgICAgdGhlbWVcbiAgICAgIH0pO1xuICAgICAgaW5pdGlhbGl6ZUVkaXRvcihuZXdFZGl0b3IsIGluaXRpYWxFZGl0b3JTdGF0ZSk7XG4gICAgICBlZGl0b3IgPSBuZXdFZGl0b3I7XG4gICAgfVxuICAgIHJldHVybiBbZWRpdG9yLCBjb250ZXh0XTtcbiAgfSxcbiAgLy8gV2Ugb25seSBkbyB0aGlzIGZvciBpbml0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW10pO1xuICB1c2VMYXlvdXRFZmZlY3RJbXBsKCgpID0+IHtcbiAgICBjb25zdCBpc0VkaXRhYmxlID0gaW5pdGlhbENvbmZpZy5lZGl0YWJsZTtcbiAgICBjb25zdCBbZWRpdG9yXSA9IGNvbXBvc2VyQ29udGV4dDtcbiAgICBlZGl0b3Iuc2V0RWRpdGFibGUoaXNFZGl0YWJsZSAhPT0gdW5kZWZpbmVkID8gaXNFZGl0YWJsZSA6IHRydWUpO1xuXG4gICAgLy8gV2Ugb25seSBkbyB0aGlzIGZvciBpbml0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KExleGljYWxDb21wb3NlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29tcG9zZXJDb250ZXh0LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRpYWxpemVFZGl0b3IoZWRpdG9yLCBpbml0aWFsRWRpdG9yU3RhdGUpIHtcbiAgaWYgKGluaXRpYWxFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChpbml0aWFsRWRpdG9yU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gICAgICBpZiAocm9vdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgcm9vdC5hcHBlbmQocGFyYWdyYXBoKTtcbiAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IENBTl9VU0VfRE9NID8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA6IG51bGw7XG4gICAgICAgIGlmICgkZ2V0U2VsZWN0aW9uKCkgIT09IG51bGwgfHwgYWN0aXZlRWxlbWVudCAhPT0gbnVsbCAmJiBhY3RpdmVFbGVtZW50ID09PSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKSkge1xuICAgICAgICAgIHBhcmFncmFwaC5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIEhJU1RPUllfTUVSR0VfT1BUSU9OUyk7XG4gIH0gZWxzZSBpZiAoaW5pdGlhbEVkaXRvclN0YXRlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgaW5pdGlhbEVkaXRvclN0YXRlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkRWRpdG9yU3RhdGUgPSBlZGl0b3IucGFyc2VFZGl0b3JTdGF0ZShpbml0aWFsRWRpdG9yU3RhdGUpO1xuICAgICAgICAgIGVkaXRvci5zZXRFZGl0b3JTdGF0ZShwYXJzZWRFZGl0b3JTdGF0ZSwgSElTVE9SWV9NRVJHRV9PUFRJT05TKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAge1xuICAgICAgICAgIGVkaXRvci5zZXRFZGl0b3JTdGF0ZShpbml0aWFsRWRpdG9yU3RhdGUsIEhJU1RPUllfTUVSR0VfT1BUSU9OUyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gICAgICAgICAgICBpZiAocm9vdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgaW5pdGlhbEVkaXRvclN0YXRlKGVkaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgSElTVE9SWV9NRVJHRV9PUFRJT05TKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBMZXhpY2FsQ29tcG9zZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalComposer.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposerContext.dev.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LexicalComposerContext: () => (/* binding */ LexicalComposerContext),\n/* harmony export */   createLexicalComposerContext: () => (/* binding */ createLexicalComposerContext),\n/* harmony export */   useLexicalComposerContext: () => (/* binding */ useLexicalComposerContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LexicalComposerContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction createLexicalComposerContext(parent, theme) {\n  let parentContext = null;\n  if (parent != null) {\n    parentContext = parent[1];\n  }\n  function getTheme() {\n    if (theme != null) {\n      return theme;\n    }\n    return parentContext != null ? parentContext.getTheme() : null;\n  }\n  return {\n    getTheme\n  };\n}\nfunction useLexicalComposerContext() {\n  const composerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LexicalComposerContext);\n  if (composerContext == null) {\n    {\n      throw Error(`LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext`);\n    }\n  }\n  return composerContext;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxvREFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpREFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXZlZG9jcy8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0LmRldi5tanM/MTczMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gY3JlYXRlTGV4aWNhbENvbXBvc2VyQ29udGV4dChwYXJlbnQsIHRoZW1lKSB7XG4gIGxldCBwYXJlbnRDb250ZXh0ID0gbnVsbDtcbiAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgcGFyZW50Q29udGV4dCA9IHBhcmVudFsxXTtcbiAgfVxuICBmdW5jdGlvbiBnZXRUaGVtZSgpIHtcbiAgICBpZiAodGhlbWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoZW1lO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Q29udGV4dCAhPSBudWxsID8gcGFyZW50Q29udGV4dC5nZXRUaGVtZSgpIDogbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFRoZW1lXG4gIH07XG59XG5mdW5jdGlvbiB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCkge1xuICBjb25zdCBjb21wb3NlckNvbnRleHQgPSB1c2VDb250ZXh0KExleGljYWxDb21wb3NlckNvbnRleHQpO1xuICBpZiAoY29tcG9zZXJDb250ZXh0ID09IG51bGwpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0OiBjYW5ub3QgZmluZCBhIExleGljYWxDb21wb3NlckNvbnRleHRgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBvc2VyQ29udGV4dDtcbn1cblxuZXhwb3J0IHsgTGV4aWNhbENvbXBvc2VyQ29udGV4dCwgY3JlYXRlTGV4aWNhbENvbXBvc2VyQ29udGV4dCwgdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalContentEditable.dev.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalContentEditable.dev.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentEditable: () => (/* binding */ ContentEditable)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction ContentEditable({\n  ariaActiveDescendant,\n  ariaAutoComplete,\n  ariaControls,\n  ariaDescribedBy,\n  ariaExpanded,\n  ariaLabel,\n  ariaLabelledBy,\n  ariaMultiline,\n  ariaOwns,\n  ariaRequired,\n  autoCapitalize,\n  className,\n  id,\n  role = 'textbox',\n  spellCheck = true,\n  style,\n  tabIndex,\n  'data-testid': testid,\n  ...rest\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__.useLexicalComposerContext)();\n  const [isEditable, setEditable] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(rootElement => {\n    // defaultView is required for a root element.\n    // In multi-window setups, the defaultView may not exist at certain points.\n    if (rootElement && rootElement.ownerDocument && rootElement.ownerDocument.defaultView) {\n      editor.setRootElement(rootElement);\n    }\n  }, [editor]);\n  useLayoutEffectImpl(() => {\n    setEditable(editor.isEditable());\n    return editor.registerEditableListener(currentIsEditable => {\n      setEditable(currentIsEditable);\n    });\n  }, [editor]);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n    ...rest,\n    \"aria-activedescendant\": !isEditable ? undefined : ariaActiveDescendant,\n    \"aria-autocomplete\": !isEditable ? 'none' : ariaAutoComplete,\n    \"aria-controls\": !isEditable ? undefined : ariaControls,\n    \"aria-describedby\": ariaDescribedBy,\n    \"aria-expanded\": !isEditable ? undefined : role === 'combobox' ? !!ariaExpanded : undefined,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-multiline\": ariaMultiline,\n    \"aria-owns\": !isEditable ? undefined : ariaOwns,\n    \"aria-readonly\": !isEditable ? true : undefined,\n    \"aria-required\": ariaRequired,\n    autoCapitalize: autoCapitalize,\n    className: className,\n    contentEditable: isEditable,\n    \"data-testid\": testid,\n    id: id,\n    ref: ref,\n    role: role,\n    spellCheck: spellCheck,\n    style: style,\n    tabIndex: tabIndex\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0Y7QUFDUjtBQUNsQzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrREFBZSxHQUFHLDRDQUFTOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQixnR0FBeUI7QUFDNUMsb0NBQW9DLCtDQUFRO0FBQzVDLGNBQWMsa0RBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsc0JBQXNCLHNEQUFHO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUUyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdmVkb2NzLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb250ZW50RWRpdGFibGUuZGV2Lm1qcz9iMDdlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vLyBUaGlzIHdvcmthcm91bmQgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSBpbiBSZWFjdCAxOSxcbi8vIGJ1dCB3ZSBjdXJyZW50bHkgc3VwcG9ydCBSZWFjdCA+PTE3Lnhcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI2Mzk1XG5jb25zdCB1c2VMYXlvdXRFZmZlY3RJbXBsID0gQ0FOX1VTRV9ET00gPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gQ29udGVudEVkaXRhYmxlKHtcbiAgYXJpYUFjdGl2ZURlc2NlbmRhbnQsXG4gIGFyaWFBdXRvQ29tcGxldGUsXG4gIGFyaWFDb250cm9scyxcbiAgYXJpYURlc2NyaWJlZEJ5LFxuICBhcmlhRXhwYW5kZWQsXG4gIGFyaWFMYWJlbCxcbiAgYXJpYUxhYmVsbGVkQnksXG4gIGFyaWFNdWx0aWxpbmUsXG4gIGFyaWFPd25zLFxuICBhcmlhUmVxdWlyZWQsXG4gIGF1dG9DYXBpdGFsaXplLFxuICBjbGFzc05hbWUsXG4gIGlkLFxuICByb2xlID0gJ3RleHRib3gnLFxuICBzcGVsbENoZWNrID0gdHJ1ZSxcbiAgc3R5bGUsXG4gIHRhYkluZGV4LFxuICAnZGF0YS10ZXN0aWQnOiB0ZXN0aWQsXG4gIC4uLnJlc3Rcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIGNvbnN0IFtpc0VkaXRhYmxlLCBzZXRFZGl0YWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHJlZiA9IHVzZUNhbGxiYWNrKHJvb3RFbGVtZW50ID0+IHtcbiAgICAvLyBkZWZhdWx0VmlldyBpcyByZXF1aXJlZCBmb3IgYSByb290IGVsZW1lbnQuXG4gICAgLy8gSW4gbXVsdGktd2luZG93IHNldHVwcywgdGhlIGRlZmF1bHRWaWV3IG1heSBub3QgZXhpc3QgYXQgY2VydGFpbiBwb2ludHMuXG4gICAgaWYgKHJvb3RFbGVtZW50ICYmIHJvb3RFbGVtZW50Lm93bmVyRG9jdW1lbnQgJiYgcm9vdEVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldykge1xuICAgICAgZWRpdG9yLnNldFJvb3RFbGVtZW50KHJvb3RFbGVtZW50KTtcbiAgICB9XG4gIH0sIFtlZGl0b3JdKTtcbiAgdXNlTGF5b3V0RWZmZWN0SW1wbCgoKSA9PiB7XG4gICAgc2V0RWRpdGFibGUoZWRpdG9yLmlzRWRpdGFibGUoKSk7XG4gICAgcmV0dXJuIGVkaXRvci5yZWdpc3RlckVkaXRhYmxlTGlzdGVuZXIoY3VycmVudElzRWRpdGFibGUgPT4ge1xuICAgICAgc2V0RWRpdGFibGUoY3VycmVudElzRWRpdGFibGUpO1xuICAgIH0pO1xuICB9LCBbZWRpdG9yXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICAuLi5yZXN0LFxuICAgIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6ICFpc0VkaXRhYmxlID8gdW5kZWZpbmVkIDogYXJpYUFjdGl2ZURlc2NlbmRhbnQsXG4gICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiAhaXNFZGl0YWJsZSA/ICdub25lJyA6IGFyaWFBdXRvQ29tcGxldGUsXG4gICAgXCJhcmlhLWNvbnRyb2xzXCI6ICFpc0VkaXRhYmxlID8gdW5kZWZpbmVkIDogYXJpYUNvbnRyb2xzLFxuICAgIFwiYXJpYS1kZXNjcmliZWRieVwiOiBhcmlhRGVzY3JpYmVkQnksXG4gICAgXCJhcmlhLWV4cGFuZGVkXCI6ICFpc0VkaXRhYmxlID8gdW5kZWZpbmVkIDogcm9sZSA9PT0gJ2NvbWJvYm94JyA/ICEhYXJpYUV4cGFuZGVkIDogdW5kZWZpbmVkLFxuICAgIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsXG4gICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogYXJpYUxhYmVsbGVkQnksXG4gICAgXCJhcmlhLW11bHRpbGluZVwiOiBhcmlhTXVsdGlsaW5lLFxuICAgIFwiYXJpYS1vd25zXCI6ICFpc0VkaXRhYmxlID8gdW5kZWZpbmVkIDogYXJpYU93bnMsXG4gICAgXCJhcmlhLXJlYWRvbmx5XCI6ICFpc0VkaXRhYmxlID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICBcImFyaWEtcmVxdWlyZWRcIjogYXJpYVJlcXVpcmVkLFxuICAgIGF1dG9DYXBpdGFsaXplOiBhdXRvQ2FwaXRhbGl6ZSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICBjb250ZW50RWRpdGFibGU6IGlzRWRpdGFibGUsXG4gICAgXCJkYXRhLXRlc3RpZFwiOiB0ZXN0aWQsXG4gICAgaWQ6IGlkLFxuICAgIHJlZjogcmVmLFxuICAgIHJvbGU6IHJvbGUsXG4gICAgc3BlbGxDaGVjazogc3BlbGxDaGVjayxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgdGFiSW5kZXg6IHRhYkluZGV4XG4gIH0pO1xufVxuXG5leHBvcnQgeyBDb250ZW50RWRpdGFibGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalContentEditable.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LexicalErrorBoundary: () => (/* binding */ LexicalErrorBoundary),\n/* harmony export */   \"default\": () => (/* binding */ LexicalErrorBoundary)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\n\nvar changedArray = function changedArray(a, b) {\n  if (a === void 0) {\n    a = [];\n  }\n\n  if (b === void 0) {\n    b = [];\n  }\n\n  return a.length !== b.length || a.some(function (item, index) {\n    return !Object.is(item, b[index]);\n  });\n};\n\nvar initialState = {\n  error: null\n};\n\nvar ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ErrorBoundary, _React$Component);\n\n  function ErrorBoundary() {\n    var _this;\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n    _this.state = initialState;\n\n    _this.resetErrorBoundary = function () {\n      var _this$props;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n      _this.reset();\n    };\n\n    return _this;\n  }\n\n  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  };\n\n  var _proto = ErrorBoundary.prototype;\n\n  _proto.reset = function reset() {\n    this.setState(initialState);\n  };\n\n  _proto.componentDidCatch = function componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n\n    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var error = this.state.error;\n    var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n    // happens to *also* be in the resetKeys array, we'd end up resetting\n    // the error boundary immediately. This would likely trigger a second\n    // error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call\n    // of cDU after the error is set\n\n    if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onResetKe, _this$props3;\n\n      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n      this.reset();\n    }\n  };\n\n  _proto.render = function render() {\n    var error = this.state.error;\n    var _this$props4 = this.props,\n        fallbackRender = _this$props4.fallbackRender,\n        FallbackComponent = _this$props4.FallbackComponent,\n        fallback = _this$props4.fallback;\n\n    if (error !== null) {\n      var _props = {\n        error: error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n\n      if ( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(fallback)) {\n        return fallback;\n      } else if (typeof fallbackRender === 'function') {\n        return fallbackRender(_props);\n      } else if (FallbackComponent) {\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FallbackComponent, _props);\n      } else {\n        throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n      }\n    }\n\n    return this.props.children;\n  };\n\n  return ErrorBoundary;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction LexicalErrorBoundary({\n  children,\n  onError\n}) {\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ErrorBoundary, {\n    fallback: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n      style: {\n        border: '1px solid #f00',\n        color: '#f00',\n        padding: '8px'\n      },\n      children: \"An error was thrown.\"\n    }),\n    onError: onError,\n    children: children\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEVycm9yQm91bmRhcnkuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStCO0FBQ1M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5RUFBeUUsYUFBYTtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2RUFBNkUsZUFBZTtBQUM1RjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGlEQUFvQjtBQUM1QztBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUiw0QkFBNEIsZ0RBQW1CO0FBQy9DLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUMsQ0FBQyw0Q0FBZTs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNCQUFzQixzREFBRztBQUN6QiwyQkFBMkIsc0RBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFaUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXZlZG9jcy8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsRXJyb3JCb3VuZGFyeS5kZXYubWpzPzY3MDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG52YXIgY2hhbmdlZEFycmF5ID0gZnVuY3Rpb24gY2hhbmdlZEFycmF5KGEsIGIpIHtcbiAgaWYgKGEgPT09IHZvaWQgMCkge1xuICAgIGEgPSBbXTtcbiAgfVxuXG4gIGlmIChiID09PSB2b2lkIDApIHtcbiAgICBiID0gW107XG4gIH1cblxuICByZXR1cm4gYS5sZW5ndGggIT09IGIubGVuZ3RoIHx8IGEuc29tZShmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICByZXR1cm4gIU9iamVjdC5pcyhpdGVtLCBiW2luZGV4XSk7XG4gIH0pO1xufTtcblxudmFyIGluaXRpYWxTdGF0ZSA9IHtcbiAgZXJyb3I6IG51bGxcbn07XG5cbnZhciBFcnJvckJvdW5kYXJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKEVycm9yQm91bmRhcnksIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEVycm9yQm91bmRhcnkoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgX2FyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChfYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG5cbiAgICBfdGhpcy5yZXNldEVycm9yQm91bmRhcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnByb3BzLm9uUmVzZXQgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzKS5vblJlc2V0LmFwcGx5KF90aGlzJHByb3BzLCBhcmdzKTtcblxuICAgICAgX3RoaXMucmVzZXQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgRXJyb3JCb3VuZGFyeS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IGVycm9yXG4gICAgfTtcbiAgfTtcblxuICB2YXIgX3Byb3RvID0gRXJyb3JCb3VuZGFyeS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRDYXRjaCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZENhdGNoKGVycm9yLCBpbmZvKSB7XG4gICAgdmFyIF90aGlzJHByb3BzJG9uRXJyb3IsIF90aGlzJHByb3BzMjtcblxuICAgIChfdGhpcyRwcm9wcyRvbkVycm9yID0gKF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMpLm9uRXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwcm9wcyRvbkVycm9yLmNhbGwoX3RoaXMkcHJvcHMyLCBlcnJvciwgaW5mbyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgIHZhciBlcnJvciA9IHRoaXMuc3RhdGUuZXJyb3I7XG4gICAgdmFyIHJlc2V0S2V5cyA9IHRoaXMucHJvcHMucmVzZXRLZXlzOyAvLyBUaGVyZSdzIGFuIGVkZ2UgY2FzZSB3aGVyZSBpZiB0aGUgdGhpbmcgdGhhdCB0cmlnZ2VyZWQgdGhlIGVycm9yXG4gICAgLy8gaGFwcGVucyB0byAqYWxzbyogYmUgaW4gdGhlIHJlc2V0S2V5cyBhcnJheSwgd2UnZCBlbmQgdXAgcmVzZXR0aW5nXG4gICAgLy8gdGhlIGVycm9yIGJvdW5kYXJ5IGltbWVkaWF0ZWx5LiBUaGlzIHdvdWxkIGxpa2VseSB0cmlnZ2VyIGEgc2Vjb25kXG4gICAgLy8gZXJyb3IgdG8gYmUgdGhyb3duLlxuICAgIC8vIFNvIHdlIG1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IGNoZWNrIHRoZSByZXNldEtleXMgb24gdGhlIGZpcnN0IGNhbGxcbiAgICAvLyBvZiBjRFUgYWZ0ZXIgdGhlIGVycm9yIGlzIHNldFxuXG4gICAgaWYgKGVycm9yICE9PSBudWxsICYmIHByZXZTdGF0ZS5lcnJvciAhPT0gbnVsbCAmJiBjaGFuZ2VkQXJyYXkocHJldlByb3BzLnJlc2V0S2V5cywgcmVzZXRLZXlzKSkge1xuICAgICAgdmFyIF90aGlzJHByb3BzJG9uUmVzZXRLZSwgX3RoaXMkcHJvcHMzO1xuXG4gICAgICAoX3RoaXMkcHJvcHMkb25SZXNldEtlID0gKF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMpLm9uUmVzZXRLZXlzQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkb25SZXNldEtlLmNhbGwoX3RoaXMkcHJvcHMzLCBwcmV2UHJvcHMucmVzZXRLZXlzLCByZXNldEtleXMpO1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBlcnJvciA9IHRoaXMuc3RhdGUuZXJyb3I7XG4gICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgIGZhbGxiYWNrUmVuZGVyID0gX3RoaXMkcHJvcHM0LmZhbGxiYWNrUmVuZGVyLFxuICAgICAgICBGYWxsYmFja0NvbXBvbmVudCA9IF90aGlzJHByb3BzNC5GYWxsYmFja0NvbXBvbmVudCxcbiAgICAgICAgZmFsbGJhY2sgPSBfdGhpcyRwcm9wczQuZmFsbGJhY2s7XG5cbiAgICBpZiAoZXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHZhciBfcHJvcHMgPSB7XG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgcmVzZXRFcnJvckJvdW5kYXJ5OiB0aGlzLnJlc2V0RXJyb3JCb3VuZGFyeVxuICAgICAgfTtcblxuICAgICAgaWYgKCAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoZmFsbGJhY2spKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZhbGxiYWNrUmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1JlbmRlcihfcHJvcHMpO1xuICAgICAgfSBlbHNlIGlmIChGYWxsYmFja0NvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmFsbGJhY2tDb21wb25lbnQsIF9wcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlYWN0LWVycm9yLWJvdW5kYXJ5IHJlcXVpcmVzIGVpdGhlciBhIGZhbGxiYWNrLCBmYWxsYmFja1JlbmRlciwgb3IgRmFsbGJhY2tDb21wb25lbnQgcHJvcCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9O1xuXG4gIHJldHVybiBFcnJvckJvdW5kYXJ5O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIExleGljYWxFcnJvckJvdW5kYXJ5KHtcbiAgY2hpbGRyZW4sXG4gIG9uRXJyb3Jcbn0pIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goRXJyb3JCb3VuZGFyeSwge1xuICAgIGZhbGxiYWNrOiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjZjAwJyxcbiAgICAgICAgY29sb3I6ICcjZjAwJyxcbiAgICAgICAgcGFkZGluZzogJzhweCdcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogXCJBbiBlcnJvciB3YXMgdGhyb3duLlwiXG4gICAgfSksXG4gICAgb25FcnJvcjogb25FcnJvcixcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59XG5cbmV4cG9ydCB7IExleGljYWxFcnJvckJvdW5kYXJ5LCBMZXhpY2FsRXJyb3JCb3VuZGFyeSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HistoryPlugin: () => (/* binding */ HistoryPlugin),\n/* harmony export */   createEmptyHistoryState: () => (/* reexport safe */ _lexical_history__WEBPACK_IMPORTED_MODULE_0__.createEmptyHistoryState)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lexical/history */ \"(ssr)/./node_modules/@lexical/history/LexicalHistory.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useHistory(editor, externalHistoryState, delay = 1000) {\n  const historyState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => externalHistoryState || (0,_lexical_history__WEBPACK_IMPORTED_MODULE_0__.createEmptyHistoryState)(), [externalHistoryState]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    return (0,_lexical_history__WEBPACK_IMPORTED_MODULE_0__.registerHistory)(editor, historyState, delay);\n  }, [delay, editor, historyState]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction HistoryPlugin({\n  externalHistoryState\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__.useLexicalComposerContext)();\n  useHistory(editor, externalHistoryState);\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhpc3RvcnlQbHVnaW4uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRjtBQUNOO0FBQ2pCO0FBQ2hCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qiw4Q0FBTywrQkFBK0IseUVBQXVCO0FBQ3BGLEVBQUUsZ0RBQVM7QUFDWCxXQUFXLGlFQUFlO0FBQzFCLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQixnR0FBeUI7QUFDNUM7QUFDQTtBQUNBOztBQUV5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdmVkb2NzLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxIaXN0b3J5UGx1Z2luLmRldi5tanM/NTI4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0JztcbmltcG9ydCB7IGNyZWF0ZUVtcHR5SGlzdG9yeVN0YXRlLCByZWdpc3Rlckhpc3RvcnkgfSBmcm9tICdAbGV4aWNhbC9oaXN0b3J5JztcbmV4cG9ydCB7IGNyZWF0ZUVtcHR5SGlzdG9yeVN0YXRlIH0gZnJvbSAnQGxleGljYWwvaGlzdG9yeSc7XG5pbXBvcnQgeyB1c2VNZW1vLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gdXNlSGlzdG9yeShlZGl0b3IsIGV4dGVybmFsSGlzdG9yeVN0YXRlLCBkZWxheSA9IDEwMDApIHtcbiAgY29uc3QgaGlzdG9yeVN0YXRlID0gdXNlTWVtbygoKSA9PiBleHRlcm5hbEhpc3RvcnlTdGF0ZSB8fCBjcmVhdGVFbXB0eUhpc3RvcnlTdGF0ZSgpLCBbZXh0ZXJuYWxIaXN0b3J5U3RhdGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gcmVnaXN0ZXJIaXN0b3J5KGVkaXRvciwgaGlzdG9yeVN0YXRlLCBkZWxheSk7XG4gIH0sIFtkZWxheSwgZWRpdG9yLCBoaXN0b3J5U3RhdGVdKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBIaXN0b3J5UGx1Z2luKHtcbiAgZXh0ZXJuYWxIaXN0b3J5U3RhdGVcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIHVzZUhpc3RvcnkoZWRpdG9yLCBleHRlcm5hbEhpc3RvcnlTdGF0ZSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBIaXN0b3J5UGx1Z2luIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RichTextPlugin: () => (/* binding */ RichTextPlugin)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_react_useLexicalEditable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lexical/react/useLexicalEditable */ \"(ssr)/./node_modules/@lexical/react/useLexicalEditable.dev.mjs\");\n/* harmony import */ var _lexical_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/text */ \"(ssr)/./node_modules/@lexical/text/LexicalText.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _lexical_dragon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lexical/dragon */ \"(ssr)/./node_modules/@lexical/dragon/LexicalDragon.dev.mjs\");\n/* harmony import */ var _lexical_rich_text__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/rich-text */ \"(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read((0,_lexical_text__WEBPACK_IMPORTED_MODULE_3__.$canShowPlaceholderCurry)(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffectImpl(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n    resetCanShowPlaceholder();\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.mergeRegister)(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useDecorators(editor, ErrorBoundary) {\n  const [decorators, setDecorators] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => editor.getDecorators());\n\n  // Subscribe to changes\n  useLayoutEffectImpl(() => {\n    return editor.registerDecoratorListener(nextDecorators => {\n      (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(() => {\n        setDecorators(nextDecorators);\n      });\n    });\n  }, [editor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    // If the content editable mounts before the subscription is added, then\n    // nothing will be rendered on initial pass. We can get around that by\n    // ensuring that we set the value.\n    setDecorators(editor.getDecorators());\n  }, [editor]);\n\n  // Return decorators defined as React Portals\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const decoratedPortals = [];\n    const decoratorKeys = Object.keys(decorators);\n    for (let i = 0; i < decoratorKeys.length; i++) {\n      const nodeKey = decoratorKeys[i];\n      const reactDecorator = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ErrorBoundary, {\n        onError: e => editor._onError(e),\n        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n          fallback: null,\n          children: decorators[nodeKey]\n        })\n      });\n      const element = editor.getElementByKey(nodeKey);\n      if (element !== null) {\n        decoratedPortals.push( /*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(reactDecorator, element, nodeKey));\n      }\n    }\n    return decoratedPortals;\n  }, [ErrorBoundary, decorators, editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useRichTextSetup(editor) {\n  useLayoutEffectImpl(() => {\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.mergeRegister)((0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_5__.registerRichText)(editor), (0,_lexical_dragon__WEBPACK_IMPORTED_MODULE_6__.registerDragonSupport)(editor));\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction RichTextPlugin({\n  contentEditable,\n  placeholder,\n  ErrorBoundary\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_7__.useLexicalComposerContext)();\n  const decorators = useDecorators(editor, ErrorBoundary);\n  useRichTextSetup(editor);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [contentEditable, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Placeholder, {\n      content: placeholder\n    }), decorators]\n  });\n}\nfunction Placeholder({\n  content\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_7__.useLexicalComposerContext)();\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const editable = (0,_lexical_react_useLexicalEditable__WEBPACK_IMPORTED_MODULE_8__.useLexicalEditable)();\n  if (!showPlaceholder) {\n    return null;\n  }\n  if (typeof content === 'function') {\n    return content(editable);\n  } else {\n    return content;\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFJpY2hUZXh0UGx1Z2luLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRjtBQUNYO0FBQ2Q7QUFDVjtBQUNpQztBQUM1QjtBQUNJO0FBQ0E7QUFDRjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrREFBZSxHQUFHLDRDQUFTOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRSx1RUFBd0I7QUFDekY7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELCtDQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQWE7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsK0NBQVE7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0RBQVM7QUFDZjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxTQUFTLDhDQUFPO0FBQ2hCO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0EsMENBQTBDLHNEQUFHO0FBQzdDO0FBQ0EsK0JBQStCLHNEQUFHLENBQUMsMkNBQVE7QUFDM0M7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLDRDQUE0Qyx1REFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsNkRBQWEsQ0FBQyxvRUFBZ0IsVUFBVSxzRUFBcUI7O0FBRXhFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLGdHQUF5QjtBQUM1QztBQUNBO0FBQ0Esc0JBQXNCLHVEQUFJLENBQUMsdURBQVE7QUFDbkMsNkNBQTZDLHNEQUFHO0FBQ2hEO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLGdHQUF5QjtBQUM1QztBQUNBLG1CQUFtQixxRkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl2ZWRvY3MvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFJpY2hUZXh0UGx1Z2luLmRldi5tanM/ODI4OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0JztcbmltcG9ydCB7IHVzZUxleGljYWxFZGl0YWJsZSB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L3VzZUxleGljYWxFZGl0YWJsZSc7XG5pbXBvcnQgeyAkY2FuU2hvd1BsYWNlaG9sZGVyQ3VycnkgfSBmcm9tICdAbGV4aWNhbC90ZXh0JztcbmltcG9ydCB7IG1lcmdlUmVnaXN0ZXIgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZU1lbW8sIFN1c3BlbnNlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmx1c2hTeW5jLCBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsganN4LCBqc3hzLCBGcmFnbWVudCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IHJlZ2lzdGVyRHJhZ29uU3VwcG9ydCB9IGZyb20gJ0BsZXhpY2FsL2RyYWdvbic7XG5pbXBvcnQgeyByZWdpc3RlclJpY2hUZXh0IH0gZnJvbSAnQGxleGljYWwvcmljaC10ZXh0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vLyBUaGlzIHdvcmthcm91bmQgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSBpbiBSZWFjdCAxOSxcbi8vIGJ1dCB3ZSBjdXJyZW50bHkgc3VwcG9ydCBSZWFjdCA+PTE3Lnhcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI2Mzk1XG5jb25zdCB1c2VMYXlvdXRFZmZlY3RJbXBsID0gQ0FOX1VTRV9ET00gPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gY2FuU2hvd1BsYWNlaG9sZGVyRnJvbUN1cnJlbnRFZGl0b3JTdGF0ZShlZGl0b3IpIHtcbiAgY29uc3QgY3VycmVudENhblNob3dQbGFjZWhvbGRlciA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLnJlYWQoJGNhblNob3dQbGFjZWhvbGRlckN1cnJ5KGVkaXRvci5pc0NvbXBvc2luZygpKSk7XG4gIHJldHVybiBjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyO1xufVxuZnVuY3Rpb24gdXNlQ2FuU2hvd1BsYWNlaG9sZGVyKGVkaXRvcikge1xuICBjb25zdCBbY2FuU2hvd1BsYWNlaG9sZGVyLCBzZXRDYW5TaG93UGxhY2Vob2xkZXJdID0gdXNlU3RhdGUoKCkgPT4gY2FuU2hvd1BsYWNlaG9sZGVyRnJvbUN1cnJlbnRFZGl0b3JTdGF0ZShlZGl0b3IpKTtcbiAgdXNlTGF5b3V0RWZmZWN0SW1wbCgoKSA9PiB7XG4gICAgZnVuY3Rpb24gcmVzZXRDYW5TaG93UGxhY2Vob2xkZXIoKSB7XG4gICAgICBjb25zdCBjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyID0gY2FuU2hvd1BsYWNlaG9sZGVyRnJvbUN1cnJlbnRFZGl0b3JTdGF0ZShlZGl0b3IpO1xuICAgICAgc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKGN1cnJlbnRDYW5TaG93UGxhY2Vob2xkZXIpO1xuICAgIH1cbiAgICByZXNldENhblNob3dQbGFjZWhvbGRlcigpO1xuICAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCk7XG4gICAgfSksIGVkaXRvci5yZWdpc3RlckVkaXRhYmxlTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgcmVzZXRDYW5TaG93UGxhY2Vob2xkZXIoKTtcbiAgICB9KSk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgcmV0dXJuIGNhblNob3dQbGFjZWhvbGRlcjtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiB1c2VEZWNvcmF0b3JzKGVkaXRvciwgRXJyb3JCb3VuZGFyeSkge1xuICBjb25zdCBbZGVjb3JhdG9ycywgc2V0RGVjb3JhdG9yc10gPSB1c2VTdGF0ZSgoKSA9PiBlZGl0b3IuZ2V0RGVjb3JhdG9ycygpKTtcblxuICAvLyBTdWJzY3JpYmUgdG8gY2hhbmdlc1xuICB1c2VMYXlvdXRFZmZlY3RJbXBsKCgpID0+IHtcbiAgICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyRGVjb3JhdG9yTGlzdGVuZXIobmV4dERlY29yYXRvcnMgPT4ge1xuICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgc2V0RGVjb3JhdG9ycyhuZXh0RGVjb3JhdG9ycyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgW2VkaXRvcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIElmIHRoZSBjb250ZW50IGVkaXRhYmxlIG1vdW50cyBiZWZvcmUgdGhlIHN1YnNjcmlwdGlvbiBpcyBhZGRlZCwgdGhlblxuICAgIC8vIG5vdGhpbmcgd2lsbCBiZSByZW5kZXJlZCBvbiBpbml0aWFsIHBhc3MuIFdlIGNhbiBnZXQgYXJvdW5kIHRoYXQgYnlcbiAgICAvLyBlbnN1cmluZyB0aGF0IHdlIHNldCB0aGUgdmFsdWUuXG4gICAgc2V0RGVjb3JhdG9ycyhlZGl0b3IuZ2V0RGVjb3JhdG9ycygpKTtcbiAgfSwgW2VkaXRvcl0pO1xuXG4gIC8vIFJldHVybiBkZWNvcmF0b3JzIGRlZmluZWQgYXMgUmVhY3QgUG9ydGFsc1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgZGVjb3JhdGVkUG9ydGFscyA9IFtdO1xuICAgIGNvbnN0IGRlY29yYXRvcktleXMgPSBPYmplY3Qua2V5cyhkZWNvcmF0b3JzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29yYXRvcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGVLZXkgPSBkZWNvcmF0b3JLZXlzW2ldO1xuICAgICAgY29uc3QgcmVhY3REZWNvcmF0b3IgPSAvKiNfX1BVUkVfXyovanN4KEVycm9yQm91bmRhcnksIHtcbiAgICAgICAgb25FcnJvcjogZSA9PiBlZGl0b3IuX29uRXJyb3IoZSksXG4gICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KFN1c3BlbnNlLCB7XG4gICAgICAgICAgZmFsbGJhY2s6IG51bGwsXG4gICAgICAgICAgY2hpbGRyZW46IGRlY29yYXRvcnNbbm9kZUtleV1cbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkobm9kZUtleSk7XG4gICAgICBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICBkZWNvcmF0ZWRQb3J0YWxzLnB1c2goIC8qI19fUFVSRV9fKi9jcmVhdGVQb3J0YWwocmVhY3REZWNvcmF0b3IsIGVsZW1lbnQsIG5vZGVLZXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY29yYXRlZFBvcnRhbHM7XG4gIH0sIFtFcnJvckJvdW5kYXJ5LCBkZWNvcmF0b3JzLCBlZGl0b3JdKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiB1c2VSaWNoVGV4dFNldHVwKGVkaXRvcikge1xuICB1c2VMYXlvdXRFZmZlY3RJbXBsKCgpID0+IHtcbiAgICByZXR1cm4gbWVyZ2VSZWdpc3RlcihyZWdpc3RlclJpY2hUZXh0KGVkaXRvciksIHJlZ2lzdGVyRHJhZ29uU3VwcG9ydChlZGl0b3IpKTtcblxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBmb3IgaW5pdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2VkaXRvcl0pO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIFJpY2hUZXh0UGx1Z2luKHtcbiAgY29udGVudEVkaXRhYmxlLFxuICBwbGFjZWhvbGRlcixcbiAgRXJyb3JCb3VuZGFyeVxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgZGVjb3JhdG9ycyA9IHVzZURlY29yYXRvcnMoZWRpdG9yLCBFcnJvckJvdW5kYXJ5KTtcbiAgdXNlUmljaFRleHRTZXR1cChlZGl0b3IpO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeHMoRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogW2NvbnRlbnRFZGl0YWJsZSwgLyojX19QVVJFX18qL2pzeChQbGFjZWhvbGRlciwge1xuICAgICAgY29udGVudDogcGxhY2Vob2xkZXJcbiAgICB9KSwgZGVjb3JhdG9yc11cbiAgfSk7XG59XG5mdW5jdGlvbiBQbGFjZWhvbGRlcih7XG4gIGNvbnRlbnRcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIGNvbnN0IHNob3dQbGFjZWhvbGRlciA9IHVzZUNhblNob3dQbGFjZWhvbGRlcihlZGl0b3IpO1xuICBjb25zdCBlZGl0YWJsZSA9IHVzZUxleGljYWxFZGl0YWJsZSgpO1xuICBpZiAoIXNob3dQbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjb250ZW50KGVkaXRhYmxlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxufVxuXG5leHBvcnQgeyBSaWNoVGV4dFBsdWdpbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/useLexicalEditable.dev.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalEditable.dev.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ useLexicalEditable),\n/* harmony export */   useLexicalEditable: () => (/* binding */ useLexicalEditable)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Shortcut to Lexical subscriptions when values are used for render.\n * @param subscription - The function to create the {@link LexicalSubscription}. This function's identity must be stable (e.g. defined at module scope or with useCallback).\n */\nfunction useLexicalSubscription(subscription) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext)();\n  const initializedSubscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => subscription(editor), [editor, subscription]);\n  const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initializedSubscription.initialValueFn());\n  const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(valueRef.current);\n  useLayoutEffectImpl(() => {\n    const {\n      initialValueFn,\n      subscribe\n    } = initializedSubscription;\n    const currentValue = initialValueFn();\n    if (valueRef.current !== currentValue) {\n      valueRef.current = currentValue;\n      setValue(currentValue);\n    }\n    return subscribe(newValue => {\n      valueRef.current = newValue;\n      setValue(newValue);\n    });\n  }, [initializedSubscription, subscription]);\n  return value;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction subscription(editor) {\n  return {\n    initialValueFn: () => editor.isEditable(),\n    subscribe: callback => {\n      return editor.registerEditableListener(callback);\n    }\n  };\n}\n\n/**\n * Get the current value for {@link LexicalEditor.isEditable}\n * using {@link useLexicalSubscription}.\n * You should prefer this over manually observing the value with\n * {@link LexicalEditor.registerEditableListener},\n * which is a bit tricky to do correctly, particularly when using\n * React StrictMode (the default for development) or concurrency.\n */\nfunction useLexicalEditable() {\n  return useLexicalSubscription(subscription);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbEVkaXRhYmxlLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRjtBQUNKOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtEQUFlLEdBQUcsNENBQVM7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsMEJBQTBCO0FBQy9FO0FBQ0E7QUFDQSxtQkFBbUIsZ0dBQXlCO0FBQzVDLGtDQUFrQyw4Q0FBTztBQUN6QyxtQkFBbUIsNkNBQU07QUFDekIsNEJBQTRCLCtDQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QixVQUFVLDZCQUE2QjtBQUN2QztBQUNBLElBQUksNkNBQTZDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXZlZG9jcy8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC91c2VMZXhpY2FsRWRpdGFibGUuZGV2Lm1qcz9hZjVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLy8gVGhpcyB3b3JrYXJvdW5kIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkgaW4gUmVhY3QgMTksXG4vLyBidXQgd2UgY3VycmVudGx5IHN1cHBvcnQgUmVhY3QgPj0xNy54XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yNjM5NVxuY29uc3QgdXNlTGF5b3V0RWZmZWN0SW1wbCA9IENBTl9VU0VfRE9NID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogU2hvcnRjdXQgdG8gTGV4aWNhbCBzdWJzY3JpcHRpb25zIHdoZW4gdmFsdWVzIGFyZSB1c2VkIGZvciByZW5kZXIuXG4gKiBAcGFyYW0gc3Vic2NyaXB0aW9uIC0gVGhlIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUge0BsaW5rIExleGljYWxTdWJzY3JpcHRpb259LiBUaGlzIGZ1bmN0aW9uJ3MgaWRlbnRpdHkgbXVzdCBiZSBzdGFibGUgKGUuZy4gZGVmaW5lZCBhdCBtb2R1bGUgc2NvcGUgb3Igd2l0aCB1c2VDYWxsYmFjaykuXG4gKi9cbmZ1bmN0aW9uIHVzZUxleGljYWxTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICBjb25zdCBpbml0aWFsaXplZFN1YnNjcmlwdGlvbiA9IHVzZU1lbW8oKCkgPT4gc3Vic2NyaXB0aW9uKGVkaXRvciksIFtlZGl0b3IsIHN1YnNjcmlwdGlvbl0pO1xuICBjb25zdCB2YWx1ZVJlZiA9IHVzZVJlZihpbml0aWFsaXplZFN1YnNjcmlwdGlvbi5pbml0aWFsVmFsdWVGbigpKTtcbiAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSB1c2VTdGF0ZSh2YWx1ZVJlZi5jdXJyZW50KTtcbiAgdXNlTGF5b3V0RWZmZWN0SW1wbCgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgaW5pdGlhbFZhbHVlRm4sXG4gICAgICBzdWJzY3JpYmVcbiAgICB9ID0gaW5pdGlhbGl6ZWRTdWJzY3JpcHRpb247XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gaW5pdGlhbFZhbHVlRm4oKTtcbiAgICBpZiAodmFsdWVSZWYuY3VycmVudCAhPT0gY3VycmVudFZhbHVlKSB7XG4gICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gY3VycmVudFZhbHVlO1xuICAgICAgc2V0VmFsdWUoY3VycmVudFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1YnNjcmliZShuZXdWYWx1ZSA9PiB7XG4gICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV3VmFsdWU7XG4gICAgICBzZXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgfSk7XG4gIH0sIFtpbml0aWFsaXplZFN1YnNjcmlwdGlvbiwgc3Vic2NyaXB0aW9uXSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBzdWJzY3JpcHRpb24oZWRpdG9yKSB7XG4gIHJldHVybiB7XG4gICAgaW5pdGlhbFZhbHVlRm46ICgpID0+IGVkaXRvci5pc0VkaXRhYmxlKCksXG4gICAgc3Vic2NyaWJlOiBjYWxsYmFjayA9PiB7XG4gICAgICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyRWRpdGFibGVMaXN0ZW5lcihjYWxsYmFjayk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBmb3Ige0BsaW5rIExleGljYWxFZGl0b3IuaXNFZGl0YWJsZX1cbiAqIHVzaW5nIHtAbGluayB1c2VMZXhpY2FsU3Vic2NyaXB0aW9ufS5cbiAqIFlvdSBzaG91bGQgcHJlZmVyIHRoaXMgb3ZlciBtYW51YWxseSBvYnNlcnZpbmcgdGhlIHZhbHVlIHdpdGhcbiAqIHtAbGluayBMZXhpY2FsRWRpdG9yLnJlZ2lzdGVyRWRpdGFibGVMaXN0ZW5lcn0sXG4gKiB3aGljaCBpcyBhIGJpdCB0cmlja3kgdG8gZG8gY29ycmVjdGx5LCBwYXJ0aWN1bGFybHkgd2hlbiB1c2luZ1xuICogUmVhY3QgU3RyaWN0TW9kZSAodGhlIGRlZmF1bHQgZm9yIGRldmVsb3BtZW50KSBvciBjb25jdXJyZW5jeS5cbiAqL1xuZnVuY3Rpb24gdXNlTGV4aWNhbEVkaXRhYmxlKCkge1xuICByZXR1cm4gdXNlTGV4aWNhbFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xufVxuXG5leHBvcnQgeyB1c2VMZXhpY2FsRWRpdGFibGUgYXMgZGVmYXVsdCwgdXNlTGV4aWNhbEVkaXRhYmxlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/useLexicalEditable.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createHeadingNode: () => (/* binding */ $createHeadingNode),\n/* harmony export */   $createQuoteNode: () => (/* binding */ $createQuoteNode),\n/* harmony export */   $isHeadingNode: () => (/* binding */ $isHeadingNode),\n/* harmony export */   $isQuoteNode: () => (/* binding */ $isQuoteNode),\n/* harmony export */   DRAG_DROP_PASTE: () => (/* binding */ DRAG_DROP_PASTE),\n/* harmony export */   HeadingNode: () => (/* binding */ HeadingNode),\n/* harmony export */   QuoteNode: () => (/* binding */ QuoteNode),\n/* harmony export */   eventFiles: () => (/* binding */ eventFiles),\n/* harmony export */   registerRichText: () => (/* binding */ registerRichText)\n/* harmony export */ });\n/* harmony import */ var _lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/clipboard */ \"(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    };\n    // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DRAG_DROP_PASTE = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('DRAG_DROP_PASTE_FILE');\n/** @noInheritDoc */\nclass QuoteNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  static getType() {\n    return 'quote';\n  }\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.quote);\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: $convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createQuoteNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'quote'\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n  collapseAtStart() {\n    const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n}\nfunction $createQuoteNode() {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n/** @noInheritDoc */\nclass HeadingNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'heading';\n  }\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n  getTag() {\n    return this.__tag;\n  }\n\n  // View\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, className);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createHeadingNode(serializedNode.tag);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      tag: this.getTag(),\n      type: 'heading',\n      version: 1\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const newElement = anchorOffet === this.getTextContentSize() || !selection ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)() : $createHeadingNode(this.getTag());\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    if (anchorOffet === 0 && !this.isEmpty() && selection) {\n      const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n      paragraph.select();\n      this.replace(paragraph, true);\n    }\n    return newElement;\n  }\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n  extractWithChild() {\n    return true;\n  }\n}\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n  return false;\n}\nfunction $convertHeadingElement(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n    if (element.style !== null) {\n      node.setFormat(element.style.textAlign);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $convertBlockquoteElement(element) {\n  const node = $createQuoteNode();\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign);\n  }\n  return {\n    node\n  };\n}\nfunction $createHeadingNode(headingTag) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    const clipboardData = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, InputEvent) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, KeyboardEvent) ? null : event.clipboardData;\n    if (clipboardData != null && selection !== null) {\n      (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$insertDataTransferForRichText)(clipboardData, selection, editor);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\nasync function onCutForRichText(event, editor) {\n  await (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.copyToClipboard)(editor, (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent) ? event : null);\n  editor.update(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      selection.removeText();\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n}\n\n// Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain occasions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\nfunction eventFiles(event) {\n  let dataTransfer = null;\n  if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, DragEvent)) {\n    dataTransfer = event.dataTransfer;\n  } else if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent)) {\n    dataTransfer = event.clipboardData;\n  }\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\nfunction $handleIndentAndOutdent(indentOrOutdent) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    return false;\n  }\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n    const parentBlock = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parentNode => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(parentNode) && !parentNode.isInline());\n    if (parentBlock === null) {\n      continue;\n    }\n    const parentKey = parentBlock.getKey();\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n  return alreadyHandled.size > 0;\n}\nfunction $isTargetWithinDecorator(target) {\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(target);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node);\n}\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)().getChildrenSize();\n}\nfunction registerRichText(editor) {\n  const removeListener = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLICK_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      selection.clear();\n      return true;\n    }\n    return false;\n  }, 0), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_WORD_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (typeof eventOrText === 'string') {\n      if (selection !== null) {\n        selection.insertText(eventOrText);\n      }\n    } else {\n      if (selection === null) {\n        return false;\n      }\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$insertDataTransferForRichText)(dataTransfer, selection, editor);\n      } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n        return true;\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.REMOVE_TEXT_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_TEXT_COMMAND, format => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.formatText(format);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_ELEMENT_COMMAND, format => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      return false;\n    }\n    const nodes = selection.getNodes();\n    for (const node of nodes) {\n      const element = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parentNode => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(parentNode) && !parentNode.isInline());\n      if (element !== null) {\n        element.setFormat(format);\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.insertParagraph();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_TAB_COMMAND, () => {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$insertNodes)([(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTabNode)()]);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      block.setIndent(indent + 1);\n    });\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.OUTDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      if (indent > 0) {\n        block.setIndent(indent - 1);\n      }\n    });\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_UP_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const possibleNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentNode)(selection.focus, true);\n      if (!event.shiftKey && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n      const possibleNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentNode)(selection.focus, false);\n      if (!event.shiftKey && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_LEFT_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    if ((0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$shouldOverrideDefaultCharacterSelection)(selection, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$moveCharacter)(selection, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const isHoldingShift = event.shiftKey;\n    if ((0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$shouldOverrideDefaultCharacterSelection)(selection, false)) {\n      event.preventDefault();\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$moveCharacter)(selection, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (selection.isCollapsed() && anchor.offset === 0 && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(anchorNode)) {\n      const element = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$getNearestBlockElementAncestorOrThrow)(anchorNode);\n      if (element.getIndent() > 0) {\n        return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.OUTDENT_CONTENT_COMMAND, undefined);\n      }\n    }\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND, true);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND, false);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ENTER_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n      if (event.shiftKey) {\n        return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, undefined);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ESCAPE_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    editor.blur();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domNode);\n        if (node !== null) {\n          const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n          const normalizedSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(selection);\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(normalizedSelection);\n        }\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n      event.preventDefault();\n      return true;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (isFileTransfer && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (isFileTransfer && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n    if (eventRange !== null) {\n      const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(eventRange.node);\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECT_ALL_COMMAND, () => {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$selectAll)();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.COPY_COMMAND, event => {\n    (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.copyToClipboard)(editor, (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent) ? event : null);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    }\n\n    // if inputs then paste within the input ignore creating a new node on paste event\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isSelectionCapturedInDecoratorInput)(event.target)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection !== null) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmljaC10ZXh0L0xleGljYWxSaWNoVGV4dC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUY7QUFDUztBQUN3RTtBQUN5MkI7O0FBRS9nQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isc0RBQWE7QUFDckM7QUFDQSx3QkFBd0IsZ0RBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLHNFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQixzREFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxx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QUF1QiwwQkFBMEIsa0RBQWE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsNEVBQW1DO0FBQzNDO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUI7QUFDNUI7QUFDQTs7QUFFcUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXZlZG9jcy8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yaWNoLXRleHQvTGV4aWNhbFJpY2hUZXh0LmRldi5tanM/NzJhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7ICRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dCwgY29weVRvQ2xpcGJvYXJkIH0gZnJvbSAnQGxleGljYWwvY2xpcGJvYXJkJztcbmltcG9ydCB7ICRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24sICRtb3ZlQ2hhcmFjdGVyIH0gZnJvbSAnQGxleGljYWwvc2VsZWN0aW9uJztcbmltcG9ydCB7IGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIG9iamVjdEtsYXNzRXF1YWxzLCBtZXJnZVJlZ2lzdGVyLCAkZmluZE1hdGNoaW5nUGFyZW50LCAkZ2V0TmVhcmVzdEJsb2NrRWxlbWVudEFuY2VzdG9yT3JUaHJvdyB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUNvbW1hbmQsIEVsZW1lbnROb2RlLCAkY3JlYXRlUGFyYWdyYXBoTm9kZSwgJGFwcGx5Tm9kZVJlcGxhY2VtZW50LCBDTElDS19DT01NQU5ELCAkZ2V0U2VsZWN0aW9uLCAkaXNOb2RlU2VsZWN0aW9uLCBERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsICRpc1JhbmdlU2VsZWN0aW9uLCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiwgREVMRVRFX1dPUkRfQ09NTUFORCwgREVMRVRFX0xJTkVfQ09NTUFORCwgQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBSRU1PVkVfVEVYVF9DT01NQU5ELCBGT1JNQVRfVEVYVF9DT01NQU5ELCBGT1JNQVRfRUxFTUVOVF9DT01NQU5ELCAkaXNFbGVtZW50Tm9kZSwgSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCBJTlNFUlRfVEFCX0NPTU1BTkQsICRpbnNlcnROb2RlcywgJGNyZWF0ZVRhYk5vZGUsIElOREVOVF9DT05URU5UX0NPTU1BTkQsIE9VVERFTlRfQ09OVEVOVF9DT01NQU5ELCBLRVlfQVJST1dfVVBfQ09NTUFORCwgJGdldEFkamFjZW50Tm9kZSwgJGlzRGVjb3JhdG9yTm9kZSwgS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgS0VZX0FSUk9XX0xFRlRfQ09NTUFORCwgS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQsIEtFWV9CQUNLU1BBQ0VfQ09NTUFORCwgJGlzUm9vdE5vZGUsIEtFWV9ERUxFVEVfQ09NTUFORCwgS0VZX0VOVEVSX0NPTU1BTkQsIEtFWV9FU0NBUEVfQ09NTUFORCwgRFJPUF9DT01NQU5ELCAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZSwgJGNyZWF0ZVJhbmdlU2VsZWN0aW9uLCAkaXNUZXh0Tm9kZSwgJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMLCAkc2V0U2VsZWN0aW9uLCBEUkFHU1RBUlRfQ09NTUFORCwgRFJBR09WRVJfQ09NTUFORCwgU0VMRUNUX0FMTF9DT01NQU5ELCAkc2VsZWN0QWxsLCBDT1BZX0NPTU1BTkQsIENVVF9DT01NQU5ELCBQQVNURV9DT01NQU5ELCBpc1NlbGVjdGlvbkNhcHR1cmVkSW5EZWNvcmF0b3JJbnB1dCwgJGdldFJvb3QgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBjYXJldEZyb21Qb2ludCh4LCB5KSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG4gICAgaWYgKHJhbmdlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IHJhbmdlLnN0YXJ0Q29udGFpbmVyLFxuICAgICAgb2Zmc2V0OiByYW5nZS5zdGFydE9mZnNldFxuICAgIH07XG4gICAgLy8gQHRzLWlnbm9yZVxuICB9IGVsc2UgaWYgKGRvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gQHRzLWlnbm9yZSBGRiAtIG5vIHR5cGVzXG4gICAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuICAgIGlmIChyYW5nZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBub2RlOiByYW5nZS5vZmZzZXROb2RlLFxuICAgICAgb2Zmc2V0OiByYW5nZS5vZmZzZXRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIEdyYWNlZnVsbHkgaGFuZGxlIElFXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgZG9jdW1lbnRNb2RlID0gQ0FOX1VTRV9ET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBudWxsO1xuY29uc3QgQ0FOX1VTRV9CRUZPUkVfSU5QVVQgPSBDQU5fVVNFX0RPTSAmJiAnSW5wdXRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgPyAnZ2V0VGFyZ2V0UmFuZ2VzJyBpbiBuZXcgd2luZG93LklucHV0RXZlbnQoJ2lucHV0JykgOiBmYWxzZTtcbmNvbnN0IElTX1NBRkFSSSA9IENBTl9VU0VfRE9NICYmIC9WZXJzaW9uXFwvW1xcZC5dKy4qU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgSVNfSU9TID0gQ0FOX1VTRV9ET00gJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbTtcblxuLy8gS2VlcCB0aGVzZSBpbiBjYXNlIHdlIG5lZWQgdG8gdXNlIHRoZW0gaW4gdGhlIGZ1dHVyZS5cbi8vIGV4cG9ydCBjb25zdCBJU19XSU5ET1dTOiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgL1dpbi8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfQ0hST01FID0gQ0FOX1VTRV9ET00gJiYgL14oPz0uKkNocm9tZSkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBJU19BUFBMRV9XRUJLSVQgPSBDQU5fVVNFX0RPTSAmJiAvQXBwbGVXZWJLaXRcXC9bXFxkLl0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFJU19DSFJPTUU7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgRFJBR19EUk9QX1BBU1RFID0gY3JlYXRlQ29tbWFuZCgnRFJBR19EUk9QX1BBU1RFX0ZJTEUnKTtcbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBRdW90ZU5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAncXVvdGUnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBRdW90ZU5vZGUobm9kZS5fX2tleSk7XG4gIH1cbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgfVxuXG4gIC8vIFZpZXdcblxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Jsb2NrcXVvdGUnKTtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS5xdW90ZSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2txdW90ZTogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEJsb2NrcXVvdGVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50XG4gICAgfSA9IHN1cGVyLmV4cG9ydERPTShlZGl0b3IpO1xuICAgIGlmIChlbGVtZW50ICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICBlbGVtZW50LmFwcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZvcm1hdFR5cGUgPSB0aGlzLmdldEZvcm1hdFR5cGUoKTtcbiAgICAgIGVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gZm9ybWF0VHlwZTtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCk7XG4gICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGVsZW1lbnQuZGlyID0gZGlyZWN0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZVF1b3RlTm9kZSgpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXRJbmRlbnQoc2VyaWFsaXplZE5vZGUuaW5kZW50KTtcbiAgICBub2RlLnNldERpcmVjdGlvbihzZXJpYWxpemVkTm9kZS5kaXJlY3Rpb24pO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIHR5cGU6ICdxdW90ZSdcbiAgICB9O1xuICB9XG5cbiAgLy8gTXV0YXRpb25cblxuICBpbnNlcnROZXdBZnRlcihfLCByZXN0b3JlU2VsZWN0aW9uKSB7XG4gICAgY29uc3QgbmV3QmxvY2sgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCk7XG4gICAgbmV3QmxvY2suc2V0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgdGhpcy5pbnNlcnRBZnRlcihuZXdCbG9jaywgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgcmV0dXJuIG5ld0Jsb2NrO1xuICB9XG4gIGNvbGxhcHNlQXRTdGFydCgpIHtcbiAgICBjb25zdCBwYXJhZ3JhcGggPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gcGFyYWdyYXBoLmFwcGVuZChjaGlsZCkpO1xuICAgIHRoaXMucmVwbGFjZShwYXJhZ3JhcGgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiAkY3JlYXRlUXVvdGVOb2RlKCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBRdW90ZU5vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNRdW90ZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFF1b3RlTm9kZTtcbn1cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBIZWFkaW5nTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnaGVhZGluZyc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IEhlYWRpbmdOb2RlKG5vZGUuX190YWcsIG5vZGUuX19rZXkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHRhZywga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fdGFnID0gdGFnO1xuICB9XG4gIGdldFRhZygpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RhZztcbiAgfVxuXG4gIC8vIFZpZXdcblxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5fX3RhZztcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGNvbnN0IHRoZW1lID0gY29uZmlnLnRoZW1lO1xuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSB0aGVtZS5oZWFkaW5nO1xuICAgIGlmIChjbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbdGFnXTtcbiAgICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaDE6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaDI6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaDM6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaDQ6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaDU6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaDY6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgcDogbm9kZSA9PiB7XG4gICAgICAgIC8vIGRvbU5vZGUgaXMgYSA8cD4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICAgICAgICBjb25zdCBwYXJhZ3JhcGggPSBub2RlO1xuICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gcGFyYWdyYXBoLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsICYmIGlzR29vZ2xlRG9jc1RpdGxlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNpb246ICgpID0+ICh7XG4gICAgICAgICAgICAgIG5vZGU6IG51bGxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcHJpb3JpdHk6IDNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHNwYW46IG5vZGUgPT4ge1xuICAgICAgICBpZiAoaXNHb29nbGVEb2NzVGl0bGUobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udmVyc2lvbjogZG9tTm9kZSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm9kZTogJGNyZWF0ZUhlYWRpbmdOb2RlKCdoMScpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJpb3JpdHk6IDNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gc3VwZXIuZXhwb3J0RE9NKGVkaXRvcik7XG4gICAgaWYgKGVsZW1lbnQgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJykpO1xuICAgICAgfVxuICAgICAgY29uc3QgZm9ybWF0VHlwZSA9IHRoaXMuZ2V0Rm9ybWF0VHlwZSgpO1xuICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBmb3JtYXRUeXBlO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgZWxlbWVudC5kaXIgPSBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlSGVhZGluZ05vZGUoc2VyaWFsaXplZE5vZGUudGFnKTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICB0YWc6IHRoaXMuZ2V0VGFnKCksXG4gICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIC8vIE11dGF0aW9uXG4gIGluc2VydE5ld0FmdGVyKHNlbGVjdGlvbiwgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBhbmNob3JPZmZldCA9IHNlbGVjdGlvbiA/IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0IDogMDtcbiAgICBjb25zdCBuZXdFbGVtZW50ID0gYW5jaG9yT2ZmZXQgPT09IHRoaXMuZ2V0VGV4dENvbnRlbnRTaXplKCkgfHwgIXNlbGVjdGlvbiA/ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkgOiAkY3JlYXRlSGVhZGluZ05vZGUodGhpcy5nZXRUYWcoKSk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICBuZXdFbGVtZW50LnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIHRoaXMuaW5zZXJ0QWZ0ZXIobmV3RWxlbWVudCwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgaWYgKGFuY2hvck9mZmV0ID09PSAwICYmICF0aGlzLmlzRW1wdHkoKSAmJiBzZWxlY3Rpb24pIHtcbiAgICAgIGNvbnN0IHBhcmFncmFwaCA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICBwYXJhZ3JhcGguc2VsZWN0KCk7XG4gICAgICB0aGlzLnJlcGxhY2UocGFyYWdyYXBoLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH1cbiAgY29sbGFwc2VBdFN0YXJ0KCkge1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSAhdGhpcy5pc0VtcHR5KCkgPyAkY3JlYXRlSGVhZGluZ05vZGUodGhpcy5nZXRUYWcoKSkgOiAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gbmV3RWxlbWVudC5hcHBlbmQoY2hpbGQpKTtcbiAgICB0aGlzLnJlcGxhY2UobmV3RWxlbWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZXh0cmFjdFdpdGhDaGlsZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNHb29nbGVEb2NzVGl0bGUoZG9tTm9kZSkge1xuICBpZiAoZG9tTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3BhbicpIHtcbiAgICByZXR1cm4gZG9tTm9kZS5zdHlsZS5mb250U2l6ZSA9PT0gJzI2cHQnO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uICRjb252ZXJ0SGVhZGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbGV0IG5vZGUgPSBudWxsO1xuICBpZiAobm9kZU5hbWUgPT09ICdoMScgfHwgbm9kZU5hbWUgPT09ICdoMicgfHwgbm9kZU5hbWUgPT09ICdoMycgfHwgbm9kZU5hbWUgPT09ICdoNCcgfHwgbm9kZU5hbWUgPT09ICdoNScgfHwgbm9kZU5hbWUgPT09ICdoNicpIHtcbiAgICBub2RlID0gJGNyZWF0ZUhlYWRpbmdOb2RlKG5vZGVOYW1lKTtcbiAgICBpZiAoZWxlbWVudC5zdHlsZSAhPT0gbnVsbCkge1xuICAgICAgbm9kZS5zZXRGb3JtYXQoZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG5vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uICRjb252ZXJ0QmxvY2txdW90ZUVsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCBub2RlID0gJGNyZWF0ZVF1b3RlTm9kZSgpO1xuICBpZiAoZWxlbWVudC5zdHlsZSAhPT0gbnVsbCkge1xuICAgIG5vZGUuc2V0Rm9ybWF0KGVsZW1lbnQuc3R5bGUudGV4dEFsaWduKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVIZWFkaW5nTm9kZShoZWFkaW5nVGFnKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IEhlYWRpbmdOb2RlKGhlYWRpbmdUYWcpKTtcbn1cbmZ1bmN0aW9uICRpc0hlYWRpbmdOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBIZWFkaW5nTm9kZTtcbn1cbmZ1bmN0aW9uIG9uUGFzdGVGb3JSaWNoVGV4dChldmVudCwgZWRpdG9yKSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBjbGlwYm9hcmREYXRhID0gb2JqZWN0S2xhc3NFcXVhbHMoZXZlbnQsIElucHV0RXZlbnQpIHx8IG9iamVjdEtsYXNzRXF1YWxzKGV2ZW50LCBLZXlib2FyZEV2ZW50KSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGlmIChjbGlwYm9hcmREYXRhICE9IG51bGwgJiYgc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAkaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUmljaFRleHQoY2xpcGJvYXJkRGF0YSwgc2VsZWN0aW9uLCBlZGl0b3IpO1xuICAgIH1cbiAgfSwge1xuICAgIHRhZzogJ3Bhc3RlJ1xuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG9uQ3V0Rm9yUmljaFRleHQoZXZlbnQsIGVkaXRvcikge1xuICBhd2FpdCBjb3B5VG9DbGlwYm9hcmQoZWRpdG9yLCBvYmplY3RLbGFzc0VxdWFscyhldmVudCwgQ2xpcGJvYXJkRXZlbnQpID8gZXZlbnQgOiBudWxsKTtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBzZWxlY3Rpb24ucmVtb3ZlVGV4dCgpO1xuICAgIH0gZWxzZSBpZiAoJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBzZWxlY3Rpb24uZ2V0Tm9kZXMoKS5mb3JFYWNoKG5vZGUgPT4gbm9kZS5yZW1vdmUoKSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gQ2xpcGJvYXJkIG1heSBjb250YWluIGZpbGVzIHRoYXQgd2UgYXJlbid0IGFsbG93ZWQgdG8gcmVhZC4gV2hpbGUgdGhlIGV2ZW50IGlzIGFyZ3VhYmx5IHVzZWxlc3MsXG4vLyBpbiBjZXJ0YWluIG9jY2FzaW9ucywgd2Ugd2FudCB0byBrbm93IHdoZXRoZXIgaXQgd2FzIGEgZmlsZSB0cmFuc2ZlciwgYXMgb3Bwb3NlZCB0byB0ZXh0LiBXZVxuLy8gY29udHJvbCB0aGlzIHdpdGggdGhlIGZpcnN0IGJvb2xlYW4gZmxhZy5cbmZ1bmN0aW9uIGV2ZW50RmlsZXMoZXZlbnQpIHtcbiAgbGV0IGRhdGFUcmFuc2ZlciA9IG51bGw7XG4gIGlmIChvYmplY3RLbGFzc0VxdWFscyhldmVudCwgRHJhZ0V2ZW50KSkge1xuICAgIGRhdGFUcmFuc2ZlciA9IGV2ZW50LmRhdGFUcmFuc2ZlcjtcbiAgfSBlbHNlIGlmIChvYmplY3RLbGFzc0VxdWFscyhldmVudCwgQ2xpcGJvYXJkRXZlbnQpKSB7XG4gICAgZGF0YVRyYW5zZmVyID0gZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgfVxuICBpZiAoZGF0YVRyYW5zZmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFtmYWxzZSwgW10sIGZhbHNlXTtcbiAgfVxuICBjb25zdCB0eXBlcyA9IGRhdGFUcmFuc2Zlci50eXBlcztcbiAgY29uc3QgaGFzRmlsZXMgPSB0eXBlcy5pbmNsdWRlcygnRmlsZXMnKTtcbiAgY29uc3QgaGFzQ29udGVudCA9IHR5cGVzLmluY2x1ZGVzKCd0ZXh0L2h0bWwnKSB8fCB0eXBlcy5pbmNsdWRlcygndGV4dC9wbGFpbicpO1xuICByZXR1cm4gW2hhc0ZpbGVzLCBBcnJheS5mcm9tKGRhdGFUcmFuc2Zlci5maWxlcyksIGhhc0NvbnRlbnRdO1xufVxuZnVuY3Rpb24gJGhhbmRsZUluZGVudEFuZE91dGRlbnQoaW5kZW50T3JPdXRkZW50KSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFscmVhZHlIYW5kbGVkID0gbmV3IFNldCgpO1xuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGNvbnN0IGtleSA9IG5vZGUuZ2V0S2V5KCk7XG4gICAgaWYgKGFscmVhZHlIYW5kbGVkLmhhcyhrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50QmxvY2sgPSAkZmluZE1hdGNoaW5nUGFyZW50KG5vZGUsIHBhcmVudE5vZGUgPT4gJGlzRWxlbWVudE5vZGUocGFyZW50Tm9kZSkgJiYgIXBhcmVudE5vZGUuaXNJbmxpbmUoKSk7XG4gICAgaWYgKHBhcmVudEJsb2NrID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50S2V5ID0gcGFyZW50QmxvY2suZ2V0S2V5KCk7XG4gICAgaWYgKHBhcmVudEJsb2NrLmNhbkluZGVudCgpICYmICFhbHJlYWR5SGFuZGxlZC5oYXMocGFyZW50S2V5KSkge1xuICAgICAgYWxyZWFkeUhhbmRsZWQuYWRkKHBhcmVudEtleSk7XG4gICAgICBpbmRlbnRPck91dGRlbnQocGFyZW50QmxvY2spO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWxyZWFkeUhhbmRsZWQuc2l6ZSA+IDA7XG59XG5mdW5jdGlvbiAkaXNUYXJnZXRXaXRoaW5EZWNvcmF0b3IodGFyZ2V0KSB7XG4gIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZSh0YXJnZXQpO1xuICByZXR1cm4gJGlzRGVjb3JhdG9yTm9kZShub2RlKTtcbn1cbmZ1bmN0aW9uICRpc1NlbGVjdGlvbkF0RW5kT2ZSb290KHNlbGVjdGlvbikge1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgcmV0dXJuIGZvY3VzLmtleSA9PT0gJ3Jvb3QnICYmIGZvY3VzLm9mZnNldCA9PT0gJGdldFJvb3QoKS5nZXRDaGlsZHJlblNpemUoKTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyUmljaFRleHQoZWRpdG9yKSB7XG4gIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENMSUNLX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBzZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIDApLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgaXNCYWNrd2FyZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZWxlY3Rpb24uZGVsZXRlQ2hhcmFjdGVyKGlzQmFja3dhcmQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoREVMRVRFX1dPUkRfQ09NTUFORCwgaXNCYWNrd2FyZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZWxlY3Rpb24uZGVsZXRlV29yZChpc0JhY2t3YXJkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKERFTEVURV9MSU5FX0NPTU1BTkQsIGlzQmFja3dhcmQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VsZWN0aW9uLmRlbGV0ZUxpbmUoaXNCYWNrd2FyZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIGV2ZW50T3JUZXh0ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHR5cGVvZiBldmVudE9yVGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgc2VsZWN0aW9uLmluc2VydFRleHQoZXZlbnRPclRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IGV2ZW50T3JUZXh0LmRhdGFUcmFuc2ZlcjtcbiAgICAgIGlmIChkYXRhVHJhbnNmZXIgIT0gbnVsbCkge1xuICAgICAgICAkaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUmljaFRleHQoZGF0YVRyYW5zZmVyLCBzZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgICB9IGVsc2UgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGV2ZW50T3JUZXh0LmRhdGE7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmluc2VydFRleHQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoUkVNT1ZFX1RFWFRfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VsZWN0aW9uLnJlbW92ZVRleHQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEZPUk1BVF9URVhUX0NPTU1BTkQsIGZvcm1hdCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZWxlY3Rpb24uZm9ybWF0VGV4dChmb3JtYXQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoRk9STUFUX0VMRU1FTlRfQ09NTUFORCwgZm9ybWF0ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmICEkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSAkZmluZE1hdGNoaW5nUGFyZW50KG5vZGUsIHBhcmVudE5vZGUgPT4gJGlzRWxlbWVudE5vZGUocGFyZW50Tm9kZSkgJiYgIXBhcmVudE5vZGUuaXNJbmxpbmUoKSk7XG4gICAgICBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50LnNldEZvcm1hdChmb3JtYXQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKElOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQsIHNlbGVjdFN0YXJ0ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5pbnNlcnRMaW5lQnJlYWsoc2VsZWN0U3RhcnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZWxlY3Rpb24uaW5zZXJ0UGFyYWdyYXBoKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfVEFCX0NPTU1BTkQsICgpID0+IHtcbiAgICAkaW5zZXJ0Tm9kZXMoWyRjcmVhdGVUYWJOb2RlKCldKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKElOREVOVF9DT05URU5UX0NPTU1BTkQsICgpID0+IHtcbiAgICByZXR1cm4gJGhhbmRsZUluZGVudEFuZE91dGRlbnQoYmxvY2sgPT4ge1xuICAgICAgY29uc3QgaW5kZW50ID0gYmxvY2suZ2V0SW5kZW50KCk7XG4gICAgICBibG9jay5zZXRJbmRlbnQoaW5kZW50ICsgMSk7XG4gICAgfSk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChPVVRERU5UX0NPTlRFTlRfQ09NTUFORCwgKCkgPT4ge1xuICAgIHJldHVybiAkaGFuZGxlSW5kZW50QW5kT3V0ZGVudChibG9jayA9PiB7XG4gICAgICBjb25zdCBpbmRlbnQgPSBibG9jay5nZXRJbmRlbnQoKTtcbiAgICAgIGlmIChpbmRlbnQgPiAwKSB7XG4gICAgICAgIGJsb2NrLnNldEluZGVudChpbmRlbnQgLSAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19VUF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgISRpc1RhcmdldFdpdGhpbkRlY29yYXRvcihldmVudC50YXJnZXQpKSB7XG4gICAgICAvLyBJZiBzZWxlY3Rpb24gaXMgb24gYSBub2RlLCBsZXQncyB0cnkgYW5kIG1vdmUgc2VsZWN0aW9uXG4gICAgICAvLyBiYWNrIHRvIGJlaW5nIGEgcmFuZ2Ugc2VsZWN0aW9uLlxuICAgICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5vZGVzWzBdLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgcG9zc2libGVOb2RlID0gJGdldEFkamFjZW50Tm9kZShzZWxlY3Rpb24uZm9jdXMsIHRydWUpO1xuICAgICAgaWYgKCFldmVudC5zaGlmdEtleSAmJiAkaXNEZWNvcmF0b3JOb2RlKHBvc3NpYmxlTm9kZSkgJiYgIXBvc3NpYmxlTm9kZS5pc0lzb2xhdGVkKCkgJiYgIXBvc3NpYmxlTm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAgIHBvc3NpYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAvLyBJZiBzZWxlY3Rpb24gaXMgb24gYSBub2RlLCBsZXQncyB0cnkgYW5kIG1vdmUgc2VsZWN0aW9uXG4gICAgICAvLyBiYWNrIHRvIGJlaW5nIGEgcmFuZ2Ugc2VsZWN0aW9uLlxuICAgICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5vZGVzWzBdLnNlbGVjdE5leHQoMCwgMCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgaWYgKCRpc1NlbGVjdGlvbkF0RW5kT2ZSb290KHNlbGVjdGlvbikpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBwb3NzaWJsZU5vZGUgPSAkZ2V0QWRqYWNlbnROb2RlKHNlbGVjdGlvbi5mb2N1cywgZmFsc2UpO1xuICAgICAgaWYgKCFldmVudC5zaGlmdEtleSAmJiAkaXNEZWNvcmF0b3JOb2RlKHBvc3NpYmxlTm9kZSkgJiYgIXBvc3NpYmxlTm9kZS5pc0lzb2xhdGVkKCkgJiYgIXBvc3NpYmxlTm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAgIHBvc3NpYmxlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQVJST1dfTEVGVF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIC8vIElmIHNlbGVjdGlvbiBpcyBvbiBhIG5vZGUsIGxldCdzIHRyeSBhbmQgbW92ZSBzZWxlY3Rpb25cbiAgICAgIC8vIGJhY2sgdG8gYmVpbmcgYSByYW5nZSBzZWxlY3Rpb24uXG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbm9kZXNbMF0uc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbihzZWxlY3Rpb24sIHRydWUpKSB7XG4gICAgICBjb25zdCBpc0hvbGRpbmdTaGlmdCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICRtb3ZlQ2hhcmFjdGVyKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIHRydWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19SSUdIVF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgISRpc1RhcmdldFdpdGhpbkRlY29yYXRvcihldmVudC50YXJnZXQpKSB7XG4gICAgICAvLyBJZiBzZWxlY3Rpb24gaXMgb24gYSBub2RlLCBsZXQncyB0cnkgYW5kIG1vdmUgc2VsZWN0aW9uXG4gICAgICAvLyBiYWNrIHRvIGJlaW5nIGEgcmFuZ2Ugc2VsZWN0aW9uLlxuICAgICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG5vZGVzWzBdLnNlbGVjdE5leHQoMCwgMCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaXNIb2xkaW5nU2hpZnQgPSBldmVudC5zaGlmdEtleTtcbiAgICBpZiAoJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbihzZWxlY3Rpb24sIGZhbHNlKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICRtb3ZlQ2hhcmFjdGVyKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQkFDS1NQQUNFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBpZiAoJGlzVGFyZ2V0V2l0aGluRGVjb3JhdG9yKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvclxuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIGFuY2hvci5vZmZzZXQgPT09IDAgJiYgISRpc1Jvb3ROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3coYW5jaG9yTm9kZSk7XG4gICAgICBpZiAoZWxlbWVudC5nZXRJbmRlbnQoKSA+IDApIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoT1VUREVOVF9DT05URU5UX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgdHJ1ZSk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfREVMRVRFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBpZiAoJGlzVGFyZ2V0V2l0aGluRGVjb3JhdG9yKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybiBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgZmFsc2UpO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0VOVEVSX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChldmVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBiZWZvcmVpbnB1dCwgdGhlbiB3ZSBjYW4gYXZvaWQgYmxvY2tpbmdcbiAgICAgIC8vIHRoZSBkZWZhdWx0IGJlaGF2aW9yLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgaU9TIGNhblxuICAgICAgLy8gaW50ZXJjZXB0IHRoYXQgd2UncmUgYWN0dWFsbHkgaW5zZXJ0aW5nIGEgcGFyYWdyYXBoLFxuICAgICAgLy8gYW5kIGF1dG9jb21wbGV0ZSwgYXV0b2NhcGl0YWxpemUgZXRjIHdvcmsgYXMgaW50ZW5kZWQuXG4gICAgICAvLyBUaGlzIGNhbiBhbHNvIGNhdXNlIGEgc3RyYW5nZSBwZXJmb3JtYW5jZSBpc3N1ZSBpblxuICAgICAgLy8gU2FmYXJpLCB3aGVyZSB0aGVyZSBpcyBhIG5vdGljZWFibGUgcGF1c2UgZHVlIHRvXG4gICAgICAvLyBwcmV2ZW50aW5nIHRoZSBrZXkgZG93biBvZiBlbnRlci5cbiAgICAgIGlmICgoSVNfSU9TIHx8IElTX1NBRkFSSSB8fCBJU19BUFBMRV9XRUJLSVQpICYmIENBTl9VU0VfQkVGT1JFX0lOUFVUKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfRVNDQVBFX0NPTU1BTkQsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVkaXRvci5ibHVyKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChEUk9QX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBbLCBmaWxlc10gPSBldmVudEZpbGVzKGV2ZW50KTtcbiAgICBpZiAoZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgeCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICBjb25zdCB5ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIGNvbnN0IGV2ZW50UmFuZ2UgPSBjYXJldEZyb21Qb2ludCh4LCB5KTtcbiAgICAgIGlmIChldmVudFJhbmdlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBvZmZzZXQ6IGRvbU9mZnNldCxcbiAgICAgICAgICBub2RlOiBkb21Ob2RlXG4gICAgICAgIH0gPSBldmVudFJhbmdlO1xuICAgICAgICBjb25zdCBub2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoZG9tTm9kZSk7XG4gICAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24uYW5jaG9yLnNldChub2RlLmdldEtleSgpLCBkb21PZmZzZXQsICd0ZXh0Jyk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZm9jdXMuc2V0KG5vZGUuZ2V0S2V5KCksIGRvbU9mZnNldCwgJ3RleHQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCkuZ2V0S2V5KCk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBub2RlLmdldEluZGV4V2l0aGluUGFyZW50KCkgKyAxO1xuICAgICAgICAgICAgc2VsZWN0aW9uLmFuY2hvci5zZXQocGFyZW50S2V5LCBvZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZm9jdXMuc2V0KHBhcmVudEtleSwgb2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBub3JtYWxpemVkU2VsZWN0aW9uID0gJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMKHNlbGVjdGlvbik7XG4gICAgICAgICAgJHNldFNlbGVjdGlvbihub3JtYWxpemVkU2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKERSQUdfRFJPUF9QQVNURSwgZmlsZXMpO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChEUkFHU1RBUlRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IFtpc0ZpbGVUcmFuc2Zlcl0gPSBldmVudEZpbGVzKGV2ZW50KTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKGlzRmlsZVRyYW5zZmVyICYmICEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoRFJBR09WRVJfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IFtpc0ZpbGVUcmFuc2Zlcl0gPSBldmVudEZpbGVzKGV2ZW50KTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKGlzRmlsZVRyYW5zZmVyICYmICEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHggPSBldmVudC5jbGllbnRYO1xuICAgIGNvbnN0IHkgPSBldmVudC5jbGllbnRZO1xuICAgIGNvbnN0IGV2ZW50UmFuZ2UgPSBjYXJldEZyb21Qb2ludCh4LCB5KTtcbiAgICBpZiAoZXZlbnRSYW5nZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgbm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGV2ZW50UmFuZ2Uubm9kZSk7XG4gICAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShub2RlKSkge1xuICAgICAgICAvLyBTaG93IGJyb3dzZXIgY2FyZXQgYXMgdGhlIHVzZXIgaXMgZHJhZ2dpbmcgdGhlIG1lZGlhIGFjcm9zcyB0aGUgc2NyZWVuLiBXb24ndCB3b3JrXG4gICAgICAgIC8vIGZvciBEZWNvcmF0b3JOb2RlIG5vciBpdCdzIHJlbGV2YW50LlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFNFTEVDVF9BTExfQ09NTUFORCwgKCkgPT4ge1xuICAgICRzZWxlY3RBbGwoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENPUFlfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvcHlUb0NsaXBib2FyZChlZGl0b3IsIG9iamVjdEtsYXNzRXF1YWxzKGV2ZW50LCBDbGlwYm9hcmRFdmVudCkgPyBldmVudCA6IG51bGwpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ1VUX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBvbkN1dEZvclJpY2hUZXh0KGV2ZW50LCBlZGl0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoUEFTVEVfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IFssIGZpbGVzLCBoYXNUZXh0Q29udGVudF0gPSBldmVudEZpbGVzKGV2ZW50KTtcbiAgICBpZiAoZmlsZXMubGVuZ3RoID4gMCAmJiAhaGFzVGV4dENvbnRlbnQpIHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoRFJBR19EUk9QX1BBU1RFLCBmaWxlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBpZiBpbnB1dHMgdGhlbiBwYXN0ZSB3aXRoaW4gdGhlIGlucHV0IGlnbm9yZSBjcmVhdGluZyBhIG5ldyBub2RlIG9uIHBhc3RlIGV2ZW50XG4gICAgaWYgKGlzU2VsZWN0aW9uQ2FwdHVyZWRJbkRlY29yYXRvcklucHV0KGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgIG9uUGFzdGVGb3JSaWNoVGV4dChldmVudCwgZWRpdG9yKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSk7XG4gIHJldHVybiByZW1vdmVMaXN0ZW5lcjtcbn1cblxuZXhwb3J0IHsgJGNyZWF0ZUhlYWRpbmdOb2RlLCAkY3JlYXRlUXVvdGVOb2RlLCAkaXNIZWFkaW5nTm9kZSwgJGlzUXVvdGVOb2RlLCBEUkFHX0RST1BfUEFTVEUsIEhlYWRpbmdOb2RlLCBRdW90ZU5vZGUsIGV2ZW50RmlsZXMsIHJlZ2lzdGVyUmljaFRleHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/selection/LexicalSelection.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $addNodeStyle: () => (/* binding */ $addNodeStyle),\n/* harmony export */   $cloneWithProperties: () => (/* binding */ $cloneWithProperties),\n/* harmony export */   $getSelectionStyleValueForProperty: () => (/* binding */ $getSelectionStyleValueForProperty),\n/* harmony export */   $isAtNodeEnd: () => (/* binding */ $isAtNodeEnd),\n/* harmony export */   $isParentElementRTL: () => (/* binding */ $isParentElementRTL),\n/* harmony export */   $moveCaretSelection: () => (/* binding */ $moveCaretSelection),\n/* harmony export */   $moveCharacter: () => (/* binding */ $moveCharacter),\n/* harmony export */   $patchStyleText: () => (/* binding */ $patchStyleText),\n/* harmony export */   $selectAll: () => (/* binding */ $selectAll),\n/* harmony export */   $setBlocksType: () => (/* binding */ $setBlocksType),\n/* harmony export */   $shouldOverrideDefaultCharacterSelection: () => (/* binding */ $shouldOverrideDefaultCharacterSelection),\n/* harmony export */   $sliceSelectedTextNodeContent: () => (/* binding */ $sliceSelectedTextNodeContent),\n/* harmony export */   $trimTextContentFromAnchor: () => (/* binding */ $trimTextContentFromAnchor),\n/* harmony export */   $wrapNodes: () => (/* binding */ $wrapNodes),\n/* harmony export */   createDOMRange: () => (/* binding */ createDOMRange),\n/* harmony export */   createRectsFromDOMRange: () => (/* binding */ createRectsFromDOMRange),\n/* harmony export */   getStyleObjectFromCSS: () => (/* binding */ getStyleObjectFromCSS),\n/* harmony export */   trimTextContentFromAnchor: () => (/* binding */ trimTextContentFromAnchor)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $updateElementNodeProperties(target, source) {\n  target.__first = source.__first;\n  target.__last = source.__last;\n  target.__size = source.__size;\n  target.__format = source.__format;\n  target.__indent = source.__indent;\n  target.__dir = source.__dir;\n  return target;\n}\nfunction $updateTextNodeProperties(target, source) {\n  target.__format = source.__format;\n  target.__style = source.__style;\n  target.__mode = source.__mode;\n  target.__detail = source.__detail;\n  return target;\n}\nfunction $updateParagraphNodeProperties(target, source) {\n  target.__textFormat = source.__textFormat;\n  return target;\n}\n\n/**\n * Returns a copy of a node, but generates a new key for the copy.\n * @param node - The node to be cloned.\n * @returns The clone of the node.\n */\nfunction $cloneWithProperties(node) {\n  const constructor = node.constructor;\n  // @ts-expect-error\n  const clone = constructor.clone(node);\n  clone.__parent = node.__parent;\n  clone.__next = node.__next;\n  clone.__prev = node.__prev;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(clone)) {\n    return $updateElementNodeProperties(clone, node);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone)) {\n    return $updateTextNodeProperties(clone, node);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(node) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(clone)) {\n    return $updateParagraphNodeProperties(clone, node);\n  }\n  return clone;\n}\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !textNode.isSegmented() && !textNode.isToken() && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCharacterOffsets)(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    throw Error(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction $trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(key);\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (value instanceof Function) {\n      styles[key] = value(prevStyles[key]);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return;\n  }\n  const [anchor, focus] = anchorAndFocus;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n  if (selection.isCollapsed() && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    $patchStyle(selection, patch);\n    return;\n  }\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key;\n\n  // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  }\n\n  // This is the case where we only selected a single node\n  if (selectedNodes.length === 1) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && firstNode.canHaveFormat()) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;\n\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n\n      // The entire node is selected, so just format it\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n  } else {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && startOffset < firstNode.getTextContentSize() && firstNode.canHaveFormat()) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n        if (isBefore) {\n          anchor.set(firstNode.getKey(), startOffset, 'text');\n        } else {\n          focus.set(firstNode.getKey(), startOffset, 'text');\n        }\n      }\n      $patchStyle(firstNode, patch);\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(lastNode) && lastNode.canHaveFormat()) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n\n      // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      }\n\n      // if the entire last node isn't selected, split it\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      if (endOffset !== 0 || endType === 'element') {\n        $patchStyle(lastNode, patch);\n      }\n    }\n\n    // style all the text nodes in between\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(selectedNode) && selectedNode.canHaveFormat() && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\n */\nfunction $setBlocksType(selection, createElement) {\n  if (selection === null) {\n    return;\n  }\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  if (anchor !== null && anchor.key === 'root') {\n    const element = createElement();\n    const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n    const firstChild = root.getFirstChild();\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n    return;\n  }\n  const nodes = selection.getNodes();\n  const firstSelectedBlock = anchor !== null ? $getAncestor(anchor.getNode(), INTERNAL_$isBlock) : false;\n  if (firstSelectedBlock && nodes.indexOf(firstSelectedBlock) === -1) {\n    nodes.push(firstSelectedBlock);\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!INTERNAL_$isBlock(node)) {\n      continue;\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      throw Error(`Expected block node to be an ElementNode`);\n    }\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$hasAncestor)(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n        throw Error(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentNode)(selection.focus, isBackward);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(possibleNode) && !possibleNode.isIsolated() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\n\n/**\n * Expands the current Selection to cover all of the content in the editor.\n * @param selection - The current selection.\n */\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode)) {\n    firstType = 'text';\n  } else if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node)) {\n    return false;\n  }\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(firstChild) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */\nconst trimTextContentFromAnchor = $trimTextContentFromAnchor;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9UOztBQUVwVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0RBQVc7QUFDakI7QUFDQTtBQUNBLE1BQU0sb0RBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsbURB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O0FBQ2pCO0FBQ0EsSUFBSSxVQUFVLHVEQUFjO0FBQzVCO0FBQ0E7QUFDQSxNQUFNLG9EQUFXO0FBQ2pCO0FBQ0E7QUFDQSxJQUFJLFVBQVUsdURBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwREFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seURBQWdCO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPLHVEQUFjLFVBQVUsNERBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx5REFBZ0IsZ0JBQWdCLG9EQUFXO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsa0NBQWtDO0FBQzlEOztBQUVvWiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdmVkb2NzLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3NlbGVjdGlvbi9MZXhpY2FsU2VsZWN0aW9uLmRldi5tanM/YmQyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7ICRpc1RleHROb2RlLCAkaXNFbGVtZW50Tm9kZSwgJGlzUGFyYWdyYXBoTm9kZSwgJGdldENoYXJhY3Rlck9mZnNldHMsICRpc1Jvb3ROb2RlLCAkZ2V0Tm9kZUJ5S2V5LCAkZ2V0UHJldmlvdXNTZWxlY3Rpb24sICRjcmVhdGVUZXh0Tm9kZSwgJGlzUmFuZ2VTZWxlY3Rpb24sICRnZXRSb290LCAkaXNSb290T3JTaGFkb3dSb290LCAkaGFzQW5jZXN0b3IsICRpc0xlYWZOb2RlLCAkc2V0U2VsZWN0aW9uLCAkZ2V0QWRqYWNlbnROb2RlLCAkaXNEZWNvcmF0b3JOb2RlLCAkaXNMaW5lQnJlYWtOb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENTU19UT19TVFlMRVMgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gZ2V0RE9NVGV4dE5vZGUoZWxlbWVudCkge1xuICBsZXQgbm9kZSA9IGVsZW1lbnQ7XG4gIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RE9NSW5kZXhXaXRoaW5QYXJlbnQobm9kZSkge1xuICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5ldmVyIGhhcHBlbicpO1xuICB9XG4gIHJldHVybiBbcGFyZW50LCBBcnJheS5mcm9tKHBhcmVudC5jaGlsZE5vZGVzKS5pbmRleE9mKG5vZGUpXTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2VsZWN0aW9uIHJhbmdlIGZvciB0aGUgRE9NLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBhbmNob3JOb2RlIC0gVGhlIGFuY2hvciBub2RlIG9mIGEgc2VsZWN0aW9uLlxuICogQHBhcmFtIF9hbmNob3JPZmZzZXQgLSBUaGUgYW1vdW50IG9mIHNwYWNlIG9mZnNldCBmcm9tIHRoZSBhbmNob3IgdG8gdGhlIGZvY3VzLlxuICogQHBhcmFtIGZvY3VzTm9kZSAtIFRoZSBjdXJyZW50IGZvY3VzLlxuICogQHBhcmFtIF9mb2N1c09mZnNldCAtIFRoZSBhbW91bnQgb2Ygc3BhY2Ugb2Zmc2V0IGZyb20gdGhlIGZvY3VzIHRvIHRoZSBhbmNob3IuXG4gKiBAcmV0dXJucyBUaGUgcmFuZ2Ugb2Ygc2VsZWN0aW9uIGZvciB0aGUgRE9NIHRoYXQgd2FzIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURPTVJhbmdlKGVkaXRvciwgYW5jaG9yTm9kZSwgX2FuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBfZm9jdXNPZmZzZXQpIHtcbiAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yTm9kZS5nZXRLZXkoKTtcbiAgY29uc3QgZm9jdXNLZXkgPSBmb2N1c05vZGUuZ2V0S2V5KCk7XG4gIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgbGV0IGFuY2hvckRPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yS2V5KTtcbiAgbGV0IGZvY3VzRE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShmb2N1c0tleSk7XG4gIGxldCBhbmNob3JPZmZzZXQgPSBfYW5jaG9yT2Zmc2V0O1xuICBsZXQgZm9jdXNPZmZzZXQgPSBfZm9jdXNPZmZzZXQ7XG4gIGlmICgkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSkge1xuICAgIGFuY2hvckRPTSA9IGdldERPTVRleHROb2RlKGFuY2hvckRPTSk7XG4gIH1cbiAgaWYgKCRpc1RleHROb2RlKGZvY3VzTm9kZSkpIHtcbiAgICBmb2N1c0RPTSA9IGdldERPTVRleHROb2RlKGZvY3VzRE9NKTtcbiAgfVxuICBpZiAoYW5jaG9yTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGZvY3VzTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGFuY2hvckRPTSA9PT0gbnVsbCB8fCBmb2N1c0RPTSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChhbmNob3JET00ubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICBbYW5jaG9yRE9NLCBhbmNob3JPZmZzZXRdID0gZ2V0RE9NSW5kZXhXaXRoaW5QYXJlbnQoYW5jaG9yRE9NKTtcbiAgfVxuICBpZiAoZm9jdXNET00ubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICBbZm9jdXNET00sIGZvY3VzT2Zmc2V0XSA9IGdldERPTUluZGV4V2l0aGluUGFyZW50KGZvY3VzRE9NKTtcbiAgfVxuICBjb25zdCBmaXJzdENoaWxkID0gYW5jaG9yRE9NLmZpcnN0Q2hpbGQ7XG4gIGlmIChhbmNob3JET00gPT09IGZvY3VzRE9NICYmIGZpcnN0Q2hpbGQgIT0gbnVsbCAmJiBmaXJzdENoaWxkLm5vZGVOYW1lID09PSAnQlInICYmIGFuY2hvck9mZnNldCA9PT0gMCAmJiBmb2N1c09mZnNldCA9PT0gMCkge1xuICAgIGZvY3VzT2Zmc2V0ID0gMTtcbiAgfVxuICB0cnkge1xuICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0KTtcbiAgICByYW5nZS5zZXRFbmQoZm9jdXNET00sIGZvY3VzT2Zmc2V0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChyYW5nZS5jb2xsYXBzZWQgJiYgKGFuY2hvck9mZnNldCAhPT0gZm9jdXNPZmZzZXQgfHwgYW5jaG9yS2V5ICE9PSBmb2N1c0tleSkpIHtcbiAgICAvLyBSYW5nZSBpcyBiYWNrd2FyZHMsIHdlIG5lZWQgdG8gcmV2ZXJzZSBpdFxuICAgIHJhbmdlLnNldFN0YXJ0KGZvY3VzRE9NLCBmb2N1c09mZnNldCk7XG4gICAgcmFuZ2Uuc2V0RW5kKGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gcmFuZ2U7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBET01SZWN0cywgZ2VuZXJhbGx5IHVzZWQgdG8gaGVscCB0aGUgZWRpdG9yIGZpbmQgYSBzcGVjaWZpYyBsb2NhdGlvbiBvbiB0aGUgc2NyZWVuLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvclxuICogQHBhcmFtIHJhbmdlIC0gQSBmcmFnbWVudCBvZiBhIGRvY3VtZW50IHRoYXQgY2FuIGNvbnRhaW4gbm9kZXMgYW5kIHBhcnRzIG9mIHRleHQgbm9kZXMuXG4gKiBAcmV0dXJucyBUaGUgc2VsZWN0aW9uUmVjdHMgYXMgYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgaWYgKHJvb3RFbGVtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IHJvb3RSZWN0ID0gcm9vdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHJvb3RFbGVtZW50KTtcbiAgY29uc3Qgcm9vdFBhZGRpbmcgPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCk7XG4gIGNvbnN0IHNlbGVjdGlvblJlY3RzID0gQXJyYXkuZnJvbShyYW5nZS5nZXRDbGllbnRSZWN0cygpKTtcbiAgbGV0IHNlbGVjdGlvblJlY3RzTGVuZ3RoID0gc2VsZWN0aW9uUmVjdHMubGVuZ3RoO1xuICAvL3NvcnQgcmVjdHMgZnJvbSB0b3AgbGVmdCB0byBib3R0b20gcmlnaHQuXG4gIHNlbGVjdGlvblJlY3RzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB0b3AgPSBhLnRvcCAtIGIudG9wO1xuICAgIC8vIFNvbWUgcmVjdHMgbWF0Y2ggcG9zaXRpb24gY2xvc2VseSwgYnV0IG5vdCBwZXJmZWN0bHksXG4gICAgLy8gc28gd2UgZ2l2ZSBhIDNweCB0b2xlcmFuY2UuXG4gICAgaWYgKE1hdGguYWJzKHRvcCkgPD0gMykge1xuICAgICAgcmV0dXJuIGEubGVmdCAtIGIubGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIHRvcDtcbiAgfSk7XG4gIGxldCBwcmV2UmVjdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rpb25SZWN0c0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uUmVjdCA9IHNlbGVjdGlvblJlY3RzW2ldO1xuICAgIC8vIEV4Y2x1ZGUgcmVjdHMgdGhhdCBvdmVybGFwIHByZWNlZGluZyBSZWN0cyBpbiB0aGUgc29ydGVkIGxpc3QuXG4gICAgY29uc3QgaXNPdmVybGFwcGluZ1JlY3QgPSBwcmV2UmVjdCAmJiBwcmV2UmVjdC50b3AgPD0gc2VsZWN0aW9uUmVjdC50b3AgJiYgcHJldlJlY3QudG9wICsgcHJldlJlY3QuaGVpZ2h0ID4gc2VsZWN0aW9uUmVjdC50b3AgJiYgcHJldlJlY3QubGVmdCArIHByZXZSZWN0LndpZHRoID4gc2VsZWN0aW9uUmVjdC5sZWZ0O1xuICAgIC8vIEV4Y2x1ZGUgc2VsZWN0aW9ucyB0aGF0IHNwYW4gdGhlIGVudGlyZSBlbGVtZW50XG4gICAgY29uc3Qgc2VsZWN0aW9uU3BhbnNFbGVtZW50ID0gc2VsZWN0aW9uUmVjdC53aWR0aCArIHJvb3RQYWRkaW5nID09PSByb290UmVjdC53aWR0aDtcbiAgICBpZiAoaXNPdmVybGFwcGluZ1JlY3QgfHwgc2VsZWN0aW9uU3BhbnNFbGVtZW50KSB7XG4gICAgICBzZWxlY3Rpb25SZWN0cy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgIHNlbGVjdGlvblJlY3RzTGVuZ3RoLS07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcHJldlJlY3QgPSBzZWxlY3Rpb25SZWN0O1xuICB9XG4gIHJldHVybiBzZWxlY3Rpb25SZWN0cztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgc3R5bGVzIGFuZCB0aGVpciB2YWx1ZXMgcHJvdmlkZWQgaW4gdGhlIENTUyBzdHJpbmcuXG4gKiBAcGFyYW0gY3NzIC0gVGhlIENTUyBzdHJpbmcgb2Ygc3R5bGVzIGFuZCB0aGVpciB2YWx1ZXMuXG4gKiBAcmV0dXJucyBUaGUgc3R5bGVPYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHN0eWxlcyBhbmQgdGhlaXIgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRTdHlsZU9iamVjdEZyb21SYXdDU1MoY3NzKSB7XG4gIGNvbnN0IHN0eWxlT2JqZWN0ID0ge307XG4gIGNvbnN0IHN0eWxlcyA9IGNzcy5zcGxpdCgnOycpO1xuICBmb3IgKGNvbnN0IHN0eWxlIG9mIHN0eWxlcykge1xuICAgIGlmIChzdHlsZSAhPT0gJycpIHtcbiAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHN0eWxlLnNwbGl0KC86KFteXSspLyk7IC8vIHNwbGl0IG9uIGZpcnN0IGNvbG9uXG4gICAgICBpZiAoa2V5ICYmIHZhbHVlKSB7XG4gICAgICAgIHN0eWxlT2JqZWN0W2tleS50cmltKCldID0gdmFsdWUudHJpbSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVPYmplY3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBDU1Mgc3RyaW5nLCByZXR1cm5zIGFuIG9iamVjdCBmcm9tIHRoZSBzdHlsZSBjYWNoZS5cbiAqIEBwYXJhbSBjc3MgLSBUaGUgQ1NTIHByb3BlcnR5IGFzIGEgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBDU1MgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlT2JqZWN0RnJvbUNTUyhjc3MpIHtcbiAgbGV0IHZhbHVlID0gQ1NTX1RPX1NUWUxFUy5nZXQoY3NzKTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFN0eWxlT2JqZWN0RnJvbVJhd0NTUyhjc3MpO1xuICAgIENTU19UT19TVFlMRVMuc2V0KGNzcywgdmFsdWUpO1xuICB9XG4gIHtcbiAgICAvLyBGcmVlemUgdGhlIHZhbHVlIGluIERFViB0byBwcmV2ZW50IGFjY2lkZW50YWwgbXV0YXRpb25zXG4gICAgT2JqZWN0LmZyZWV6ZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIENTUyBzdHlsZXMgZnJvbSB0aGUgc3R5bGUgb2JqZWN0LlxuICogQHBhcmFtIHN0eWxlcyAtIFRoZSBzdHlsZSBvYmplY3QgY29udGFpbmluZyB0aGUgc3R5bGVzIHRvIGdldC5cbiAqIEByZXR1cm5zIEEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIENTUyBzdHlsZXMgYW5kIHRoZWlyIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q1NTRnJvbVN0eWxlT2JqZWN0KHN0eWxlcykge1xuICBsZXQgY3NzID0gJyc7XG4gIGZvciAoY29uc3Qgc3R5bGUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBjc3MgKz0gYCR7c3R5bGV9OiAke3N0eWxlc1tzdHlsZV19O2A7XG4gICAgfVxuICB9XG4gIHJldHVybiBjc3M7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uICR1cGRhdGVFbGVtZW50Tm9kZVByb3BlcnRpZXModGFyZ2V0LCBzb3VyY2UpIHtcbiAgdGFyZ2V0Ll9fZmlyc3QgPSBzb3VyY2UuX19maXJzdDtcbiAgdGFyZ2V0Ll9fbGFzdCA9IHNvdXJjZS5fX2xhc3Q7XG4gIHRhcmdldC5fX3NpemUgPSBzb3VyY2UuX19zaXplO1xuICB0YXJnZXQuX19mb3JtYXQgPSBzb3VyY2UuX19mb3JtYXQ7XG4gIHRhcmdldC5fX2luZGVudCA9IHNvdXJjZS5fX2luZGVudDtcbiAgdGFyZ2V0Ll9fZGlyID0gc291cmNlLl9fZGlyO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gJHVwZGF0ZVRleHROb2RlUHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSkge1xuICB0YXJnZXQuX19mb3JtYXQgPSBzb3VyY2UuX19mb3JtYXQ7XG4gIHRhcmdldC5fX3N0eWxlID0gc291cmNlLl9fc3R5bGU7XG4gIHRhcmdldC5fX21vZGUgPSBzb3VyY2UuX19tb2RlO1xuICB0YXJnZXQuX19kZXRhaWwgPSBzb3VyY2UuX19kZXRhaWw7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiAkdXBkYXRlUGFyYWdyYXBoTm9kZVByb3BlcnRpZXModGFyZ2V0LCBzb3VyY2UpIHtcbiAgdGFyZ2V0Ll9fdGV4dEZvcm1hdCA9IHNvdXJjZS5fX3RleHRGb3JtYXQ7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGNvcHkgb2YgYSBub2RlLCBidXQgZ2VuZXJhdGVzIGEgbmV3IGtleSBmb3IgdGhlIGNvcHkuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNsb25lZC5cbiAqIEByZXR1cm5zIFRoZSBjbG9uZSBvZiB0aGUgbm9kZS5cbiAqL1xuZnVuY3Rpb24gJGNsb25lV2l0aFByb3BlcnRpZXMobm9kZSkge1xuICBjb25zdCBjb25zdHJ1Y3RvciA9IG5vZGUuY29uc3RydWN0b3I7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgY29uc3QgY2xvbmUgPSBjb25zdHJ1Y3Rvci5jbG9uZShub2RlKTtcbiAgY2xvbmUuX19wYXJlbnQgPSBub2RlLl9fcGFyZW50O1xuICBjbG9uZS5fX25leHQgPSBub2RlLl9fbmV4dDtcbiAgY2xvbmUuX19wcmV2ID0gbm9kZS5fX3ByZXY7XG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiAkaXNFbGVtZW50Tm9kZShjbG9uZSkpIHtcbiAgICByZXR1cm4gJHVwZGF0ZUVsZW1lbnROb2RlUHJvcGVydGllcyhjbG9uZSwgbm9kZSk7XG4gIH1cbiAgaWYgKCRpc1RleHROb2RlKG5vZGUpICYmICRpc1RleHROb2RlKGNsb25lKSkge1xuICAgIHJldHVybiAkdXBkYXRlVGV4dE5vZGVQcm9wZXJ0aWVzKGNsb25lLCBub2RlKTtcbiAgfVxuICBpZiAoJGlzUGFyYWdyYXBoTm9kZShub2RlKSAmJiAkaXNQYXJhZ3JhcGhOb2RlKGNsb25lKSkge1xuICAgIHJldHVybiAkdXBkYXRlUGFyYWdyYXBoTm9kZVByb3BlcnRpZXMoY2xvbmUsIG5vZGUpO1xuICB9XG4gIHJldHVybiBjbG9uZTtcbn1cblxuLyoqXG4gKiBHZW5lcmFsbHkgdXNlZCB0byBhcHBlbmQgdGV4dCBjb250ZW50IHRvIEhUTUwgYW5kIEpTT04uIEdyYWJzIHRoZSB0ZXh0IGNvbnRlbnQgYW5kIFwic2xpY2VzXCJcbiAqIGl0IHRvIGJlIGdlbmVyYXRlZCBpbnRvIHRoZSBuZXcgVGV4dE5vZGUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBjb250YWluaW5nIHRoZSBub2RlIHdob3NlIFRleHROb2RlIGlzIHRvIGJlIGVkaXRlZC5cbiAqIEBwYXJhbSB0ZXh0Tm9kZSAtIFRoZSBUZXh0Tm9kZSB0byBiZSBlZGl0ZWQuXG4gKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBUZXh0Tm9kZS5cbiAqL1xuZnVuY3Rpb24gJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQoc2VsZWN0aW9uLCB0ZXh0Tm9kZSkge1xuICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICBpZiAodGV4dE5vZGUuaXNTZWxlY3RlZChzZWxlY3Rpb24pICYmICF0ZXh0Tm9kZS5pc1NlZ21lbnRlZCgpICYmICF0ZXh0Tm9kZS5pc1Rva2VuKCkgJiYgYW5jaG9yQW5kRm9jdXMgIT09IG51bGwpIHtcbiAgICBjb25zdCBbYW5jaG9yLCBmb2N1c10gPSBhbmNob3JBbmRGb2N1cztcbiAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgY29uc3QgaXNBbmNob3IgPSB0ZXh0Tm9kZS5pcyhhbmNob3JOb2RlKTtcbiAgICBjb25zdCBpc0ZvY3VzID0gdGV4dE5vZGUuaXMoZm9jdXNOb2RlKTtcbiAgICBpZiAoaXNBbmNob3IgfHwgaXNGb2N1cykge1xuICAgICAgY29uc3QgW2FuY2hvck9mZnNldCwgZm9jdXNPZmZzZXRdID0gJGdldENoYXJhY3Rlck9mZnNldHMoc2VsZWN0aW9uKTtcbiAgICAgIGNvbnN0IGlzU2FtZSA9IGFuY2hvck5vZGUuaXMoZm9jdXNOb2RlKTtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSB0ZXh0Tm9kZS5pcyhpc0JhY2t3YXJkID8gZm9jdXNOb2RlIDogYW5jaG9yTm9kZSk7XG4gICAgICBjb25zdCBpc0xhc3QgPSB0ZXh0Tm9kZS5pcyhpc0JhY2t3YXJkID8gYW5jaG9yTm9kZSA6IGZvY3VzTm9kZSk7XG4gICAgICBsZXQgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgbGV0IGVuZE9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpc1NhbWUpIHtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgICBlbmRPZmZzZXQgPSBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGlzQmFja3dhcmQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIGVuZE9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAoaXNMYXN0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGlzQmFja3dhcmQgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICBlbmRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgICB0ZXh0Tm9kZS5fX3RleHQgPSB0ZXh0Tm9kZS5fX3RleHQuc2xpY2Uoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICByZXR1cm4gdGV4dE5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0Tm9kZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBhdCB0aGUgZW5kIG9mIHRoZSBub2RlLlxuICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IG9mIHRoZSBzZWxlY3Rpb24gdG8gdGVzdC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHBvaW50IG9mZnNldCBpcyBpbiB0aGUgbGFzdCBwb3NzaWJsZSBwb3NpdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNBdE5vZGVFbmQocG9pbnQpIHtcbiAgaWYgKHBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHJldHVybiBwb2ludC5vZmZzZXQgPT09IHBvaW50LmdldE5vZGUoKS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgfVxuICBjb25zdCBub2RlID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgdGhyb3cgRXJyb3IoYGlzQXROb2RlRW5kOiBub2RlIG11c3QgYmUgYSBUZXh0Tm9kZSBvciBFbGVtZW50Tm9kZWApO1xuICB9XG4gIHJldHVybiBwb2ludC5vZmZzZXQgPT09IG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCk7XG59XG5cbi8qKlxuICogVHJpbXMgdGV4dCBmcm9tIGEgbm9kZSBpbiBvcmRlciB0byBzaG9ydGVuIGl0LCBlZy4gdG8gZW5mb3JjZSBhIHRleHQncyBtYXggbGVuZ3RoLiBJZiBpdCBkZWxldGVzIHRleHRcbiAqIHRoYXQgaXMgYW4gYW5jZXN0b3Igb2YgdGhlIGFuY2hvciB0aGVuIGl0IHdpbGwgbGVhdmUgMiBpbmRlbnRzLCBvdGhlcndpc2UsIGlmIG5vIHRleHQgY29udGVudCBleGlzdHMsIGl0IGRlbGV0ZXNcbiAqIHRoZSBUZXh0Tm9kZS4gSXQgd2lsbCBtb3ZlIHRoZSBmb2N1cyB0byBlaXRoZXIgdGhlIGVuZCBvZiBhbnkgbGVmdCBvdmVyIHRleHQgb3IgYmVnaW5uaW5nIG9mIGEgbmV3IFRleHROb2RlLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBhbmNob3IgLSBUaGUgYW5jaG9yIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiwgd2hlcmUgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgcG9pbnRpbmcuXG4gKiBAcGFyYW0gZGVsQ291bnQgLSBUaGUgYW1vdW50IG9mIGNoYXJhY3RlcnMgdG8gZGVsZXRlLiBVc2VmdWwgYXMgYSBkeW5hbWljIHZhcmlhYmxlIGVnLiB0ZXh0Q29udGVudFNpemUgLSBtYXhMZW5ndGg7XG4gKi9cbmZ1bmN0aW9uICR0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yKGVkaXRvciwgYW5jaG9yLCBkZWxDb3VudCkge1xuICAvLyBXb3JrIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGFuY2hvciBwb2ludFxuICBsZXQgY3VycmVudE5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICBsZXQgcmVtYWluaW5nID0gZGVsQ291bnQ7XG4gIGlmICgkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBkZXNjZW5kYW50Tm9kZSA9IGN1cnJlbnROb2RlLmdldERlc2NlbmRhbnRCeUluZGV4KGFuY2hvci5vZmZzZXQpO1xuICAgIGlmIChkZXNjZW5kYW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgY3VycmVudE5vZGUgPSBkZXNjZW5kYW50Tm9kZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHJlbWFpbmluZyA+IDAgJiYgY3VycmVudE5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgICBjb25zdCBsYXN0RGVzY2VuZGFudCA9IGN1cnJlbnROb2RlLmdldExhc3REZXNjZW5kYW50KCk7XG4gICAgICBpZiAobGFzdERlc2NlbmRhbnQgIT09IG51bGwpIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBsYXN0RGVzY2VuZGFudDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5leHROb2RlID0gY3VycmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgbGV0IGFkZGl0aW9uYWxFbGVtZW50V2hpdGVzcGFjZSA9IDA7XG4gICAgaWYgKG5leHROb2RlID09PSBudWxsKSB7XG4gICAgICBsZXQgcGFyZW50ID0gY3VycmVudE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgbGV0IHBhcmVudFNpYmxpbmcgPSBwYXJlbnQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICB3aGlsZSAocGFyZW50U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50U2libGluZyA9IHBhcmVudC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgYWRkaXRpb25hbEVsZW1lbnRXaGl0ZXNwYWNlID0gcGFyZW50LmlzSW5saW5lKCkgPyAwIDogMjtcbiAgICAgICAgbmV4dE5vZGUgPSBwYXJlbnRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgdGV4dCA9IGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgLy8gSWYgdGhlIHRleHQgaXMgZW1wdHksIHdlIG5lZWQgdG8gY29uc2lkZXIgYWRkaW5nIGluIHR3byBsaW5lIGJyZWFrcyB0byBtYXRjaFxuICAgIC8vIHRoZSBjb250ZW50IGlmIHdlIHdlcmUgdG8gZ2V0IGl0IGZyb20gaXRzIHBhcmVudC5cbiAgICBpZiAodGV4dCA9PT0gJycgJiYgJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmICFjdXJyZW50Tm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyBiZSBoYW5kbGVkIGluIGNvcmU/XG4gICAgICB0ZXh0ID0gJ1xcblxcbic7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnROb2RlU2l6ZSA9IHRleHQubGVuZ3RoO1xuICAgIGlmICghJGlzVGV4dE5vZGUoY3VycmVudE5vZGUpIHx8IHJlbWFpbmluZyA+PSBjdXJyZW50Tm9kZVNpemUpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGN1cnJlbnROb2RlLmdldFBhcmVudCgpO1xuICAgICAgY3VycmVudE5vZGUucmVtb3ZlKCk7XG4gICAgICBpZiAocGFyZW50ICE9IG51bGwgJiYgcGFyZW50LmdldENoaWxkcmVuU2l6ZSgpID09PSAwICYmICEkaXNSb290Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIHJlbWFpbmluZyAtPSBjdXJyZW50Tm9kZVNpemUgKyBhZGRpdGlvbmFsRWxlbWVudFdoaXRlc3BhY2U7XG4gICAgICBjdXJyZW50Tm9kZSA9IG5leHROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBrZXkgPSBjdXJyZW50Tm9kZS5nZXRLZXkoKTtcbiAgICAgIC8vIFNlZSBpZiB3ZSBjYW4ganVzdCByZXZlcnQgaXQgdG8gd2hhdCB3YXMgaW4gdGhlIGxhc3QgZWRpdG9yIHN0YXRlXG4gICAgICBjb25zdCBwcmV2VGV4dENvbnRlbnQgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgICAgY29uc3QgcHJldk5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KGtleSk7XG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZShwcmV2Tm9kZSkgJiYgcHJldk5vZGUuaXNTaW1wbGVUZXh0KCkpIHtcbiAgICAgICAgICByZXR1cm4gcHJldk5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gY3VycmVudE5vZGVTaXplIC0gcmVtYWluaW5nO1xuICAgICAgY29uc3Qgc2xpY2VkVGV4dCA9IHRleHQuc2xpY2UoMCwgb2Zmc2V0KTtcbiAgICAgIGlmIChwcmV2VGV4dENvbnRlbnQgIT09IG51bGwgJiYgcHJldlRleHRDb250ZW50ICE9PSB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IGN1cnJlbnROb2RlO1xuICAgICAgICBpZiAoIWN1cnJlbnROb2RlLmlzU2ltcGxlVGV4dCgpKSB7XG4gICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUocHJldlRleHRDb250ZW50KTtcbiAgICAgICAgICBjdXJyZW50Tm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgICAgICB0YXJnZXQgPSB0ZXh0Tm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRUZXh0Q29udGVudChwcmV2VGV4dENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBwcmV2U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgICBjb25zdCBwcmV2T2Zmc2V0ID0gcHJldlNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0O1xuICAgICAgICAgIHRhcmdldC5zZWxlY3QocHJldk9mZnNldCwgcHJldk9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudE5vZGUuaXNTaW1wbGVUZXh0KCkpIHtcbiAgICAgICAgLy8gU3BsaXQgdGV4dFxuICAgICAgICBjb25zdCBpc1NlbGVjdGVkID0gYW5jaG9yLmtleSA9PT0ga2V5O1xuICAgICAgICBsZXQgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgICAgICAgLy8gTW92ZSBvZmZzZXQgdG8gZW5kIGlmIGl0J3MgbGVzcyB0aGFuIHRoZSByZW1haW5pbmcgbnVtYmVyLCBvdGhlcndpc2VcbiAgICAgICAgLy8gd2UnbGwgaGF2ZSBhIG5lZ2F0aXZlIHNwbGl0U3RhcnQuXG4gICAgICAgIGlmIChhbmNob3JPZmZzZXQgPCByZW1haW5pbmcpIHtcbiAgICAgICAgICBhbmNob3JPZmZzZXQgPSBjdXJyZW50Tm9kZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BsaXRTdGFydCA9IGlzU2VsZWN0ZWQgPyBhbmNob3JPZmZzZXQgLSByZW1haW5pbmcgOiAwO1xuICAgICAgICBjb25zdCBzcGxpdEVuZCA9IGlzU2VsZWN0ZWQgPyBhbmNob3JPZmZzZXQgOiBvZmZzZXQ7XG4gICAgICAgIGlmIChpc1NlbGVjdGVkICYmIHNwbGl0U3RhcnQgPT09IDApIHtcbiAgICAgICAgICBjb25zdCBbZXhjZXNzTm9kZV0gPSBjdXJyZW50Tm9kZS5zcGxpdFRleHQoc3BsaXRTdGFydCwgc3BsaXRFbmQpO1xuICAgICAgICAgIGV4Y2Vzc05vZGUucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgWywgZXhjZXNzTm9kZV0gPSBjdXJyZW50Tm9kZS5zcGxpdFRleHQoc3BsaXRTdGFydCwgc3BsaXRFbmQpO1xuICAgICAgICAgIGV4Y2Vzc05vZGUucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKHNsaWNlZFRleHQpO1xuICAgICAgICBjdXJyZW50Tm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgIH1cbiAgICAgIHJlbWFpbmluZyA9IDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgVGV4dE5vZGUncyBzdHlsZSBvYmplY3QgYW5kIGFkZHMgdGhlIHN0eWxlcyB0byB0aGUgQ1NTLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgVGV4dE5vZGUgdG8gYWRkIHN0eWxlcyB0by5cbiAqL1xuZnVuY3Rpb24gJGFkZE5vZGVTdHlsZShub2RlKSB7XG4gIGNvbnN0IENTU1RleHQgPSBub2RlLmdldFN0eWxlKCk7XG4gIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlT2JqZWN0RnJvbVJhd0NTUyhDU1NUZXh0KTtcbiAgQ1NTX1RPX1NUWUxFUy5zZXQoQ1NTVGV4dCwgc3R5bGVzKTtcbn1cbmZ1bmN0aW9uICRwYXRjaFN0eWxlKHRhcmdldCwgcGF0Y2gpIHtcbiAgY29uc3QgcHJldlN0eWxlcyA9IGdldFN0eWxlT2JqZWN0RnJvbUNTUygnZ2V0U3R5bGUnIGluIHRhcmdldCA/IHRhcmdldC5nZXRTdHlsZSgpIDogdGFyZ2V0LnN0eWxlKTtcbiAgY29uc3QgbmV3U3R5bGVzID0gT2JqZWN0LmVudHJpZXMocGF0Y2gpLnJlZHVjZSgoc3R5bGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgc3R5bGVzW2tleV0gPSB2YWx1ZShwcmV2U3R5bGVzW2tleV0pO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZSBzdHlsZXNba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfSwge1xuICAgIC4uLnByZXZTdHlsZXNcbiAgfSB8fCB7fSk7XG4gIGNvbnN0IG5ld0NTU1RleHQgPSBnZXRDU1NGcm9tU3R5bGVPYmplY3QobmV3U3R5bGVzKTtcbiAgdGFyZ2V0LnNldFN0eWxlKG5ld0NTU1RleHQpO1xuICBDU1NfVE9fU1RZTEVTLnNldChuZXdDU1NUZXh0LCBuZXdTdHlsZXMpO1xufVxuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHByb3ZpZGVkIHN0eWxlcyB0byB0aGUgVGV4dE5vZGVzIGluIHRoZSBwcm92aWRlZCBTZWxlY3Rpb24uXG4gKiBXaWxsIHVwZGF0ZSBwYXJ0aWFsbHkgc2VsZWN0ZWQgVGV4dE5vZGVzIGJ5IHNwbGl0dGluZyB0aGUgVGV4dE5vZGUgYW5kIGFwcGx5aW5nXG4gKiB0aGUgc3R5bGVzIHRvIHRoZSBhcHByb3ByaWF0ZSBvbmUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGVkIG5vZGUocykgdG8gdXBkYXRlLlxuICogQHBhcmFtIHBhdGNoIC0gVGhlIHBhdGNoIHRvIGFwcGx5LCB3aGljaCBjYW4gaW5jbHVkZSBtdWx0aXBsZSBzdHlsZXMuIFxcXFx7Q1NTUHJvcGVydHk6IHZhbHVlXFxcXH0gLiBDYW4gYWxzbyBhY2NlcHQgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gJHBhdGNoU3R5bGVUZXh0KHNlbGVjdGlvbiwgcGF0Y2gpIHtcbiAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBzZWxlY3RlZE5vZGVzTGVuZ3RoID0gc2VsZWN0ZWROb2Rlcy5sZW5ndGg7XG4gIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gIGlmIChhbmNob3JBbmRGb2N1cyA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbYW5jaG9yLCBmb2N1c10gPSBhbmNob3JBbmRGb2N1cztcbiAgY29uc3QgbGFzdEluZGV4ID0gc2VsZWN0ZWROb2Rlc0xlbmd0aCAtIDE7XG4gIGxldCBmaXJzdE5vZGUgPSBzZWxlY3RlZE5vZGVzWzBdO1xuICBsZXQgbGFzdE5vZGUgPSBzZWxlY3RlZE5vZGVzW2xhc3RJbmRleF07XG4gIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiAkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgJHBhdGNoU3R5bGUoc2VsZWN0aW9uLCBwYXRjaCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZpcnN0Tm9kZVRleHQgPSBmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgY29uc3QgZmlyc3ROb2RlVGV4dExlbmd0aCA9IGZpcnN0Tm9kZVRleHQubGVuZ3RoO1xuICBjb25zdCBmb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgbGV0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IGlzQmVmb3JlID0gYW5jaG9yLmlzQmVmb3JlKGZvY3VzKTtcbiAgbGV0IHN0YXJ0T2Zmc2V0ID0gaXNCZWZvcmUgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgbGV0IGVuZE9mZnNldCA9IGlzQmVmb3JlID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gIGNvbnN0IHN0YXJ0VHlwZSA9IGlzQmVmb3JlID8gYW5jaG9yLnR5cGUgOiBmb2N1cy50eXBlO1xuICBjb25zdCBlbmRUeXBlID0gaXNCZWZvcmUgPyBmb2N1cy50eXBlIDogYW5jaG9yLnR5cGU7XG4gIGNvbnN0IGVuZEtleSA9IGlzQmVmb3JlID8gZm9jdXMua2V5IDogYW5jaG9yLmtleTtcblxuICAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZXJlIHRoZSB1c2VyIG9ubHkgc2VsZWN0ZWQgdGhlIHZlcnkgZW5kIG9mIHRoZVxuICAvLyBmaXJzdCBub2RlIHNvIHdlIGRvbid0IHdhbnQgdG8gaW5jbHVkZSBpdCBpbiB0aGUgZm9ybWF0dGluZyBjaGFuZ2UuXG4gIGlmICgkaXNUZXh0Tm9kZShmaXJzdE5vZGUpICYmIHN0YXJ0T2Zmc2V0ID09PSBmaXJzdE5vZGVUZXh0TGVuZ3RoKSB7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBmaXJzdE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICBpZiAoJGlzVGV4dE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAvLyB3ZSBiYXNpY2FsbHkgbWFrZSB0aGUgc2Vjb25kIG5vZGUgdGhlIGZpcnN0Tm9kZSwgY2hhbmdpbmcgb2Zmc2V0cyBhY2NvcmRpbmdseVxuICAgICAgYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgIGZpcnN0Tm9kZSA9IG5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgaXMgdGhlIGNhc2Ugd2hlcmUgd2Ugb25seSBzZWxlY3RlZCBhIHNpbmdsZSBub2RlXG4gIGlmIChzZWxlY3RlZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICgkaXNUZXh0Tm9kZShmaXJzdE5vZGUpICYmIGZpcnN0Tm9kZS5jYW5IYXZlRm9ybWF0KCkpIHtcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gc3RhcnRUeXBlID09PSAnZWxlbWVudCcgPyAwIDogYW5jaG9yT2Zmc2V0ID4gZm9jdXNPZmZzZXQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICAgIGVuZE9mZnNldCA9IGVuZFR5cGUgPT09ICdlbGVtZW50JyA/IGZpcnN0Tm9kZVRleHRMZW5ndGggOiBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuXG4gICAgICAvLyBObyBhY3R1YWwgdGV4dCBpcyBzZWxlY3RlZCwgc28gZG8gbm90aGluZy5cbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gZW5kT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGVudGlyZSBub2RlIGlzIHNlbGVjdGVkLCBzbyBqdXN0IGZvcm1hdCBpdFxuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAwICYmIGVuZE9mZnNldCA9PT0gZmlyc3ROb2RlVGV4dExlbmd0aCkge1xuICAgICAgICAkcGF0Y2hTdHlsZShmaXJzdE5vZGUsIHBhdGNoKTtcbiAgICAgICAgZmlyc3ROb2RlLnNlbGVjdChzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBub2RlIGlzIHBhcnRpYWxseSBzZWxlY3RlZCwgc28gc3BsaXQgaXQgaW50byB0d28gbm9kZXNcbiAgICAgICAgLy8gYW5kIHN0eWxlIHRoZSBzZWxlY3RlZCBvbmUuXG4gICAgICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHN0YXJ0T2Zmc2V0ID09PSAwID8gc3BsaXROb2Rlc1swXSA6IHNwbGl0Tm9kZXNbMV07XG4gICAgICAgICRwYXRjaFN0eWxlKHJlcGxhY2VtZW50LCBwYXRjaCk7XG4gICAgICAgIHJlcGxhY2VtZW50LnNlbGVjdCgwLCBlbmRPZmZzZXQgLSBzdGFydE9mZnNldCk7XG4gICAgICB9XG4gICAgfSAvLyBtdWx0aXBsZSBub2RlcyBzZWxlY3RlZC5cbiAgfSBlbHNlIHtcbiAgICBpZiAoJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSAmJiBzdGFydE9mZnNldCA8IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSAmJiBmaXJzdE5vZGUuY2FuSGF2ZUZvcm1hdCgpKSB7XG4gICAgICBpZiAoc3RhcnRPZmZzZXQgIT09IDApIHtcbiAgICAgICAgLy8gdGhlIGVudGlyZSBmaXJzdCBub2RlIGlzbid0IHNlbGVjdGVkLCBzbyBzcGxpdCBpdFxuICAgICAgICBmaXJzdE5vZGUgPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0KVsxXTtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAoaXNCZWZvcmUpIHtcbiAgICAgICAgICBhbmNob3Iuc2V0KGZpcnN0Tm9kZS5nZXRLZXkoKSwgc3RhcnRPZmZzZXQsICd0ZXh0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9jdXMuc2V0KGZpcnN0Tm9kZS5nZXRLZXkoKSwgc3RhcnRPZmZzZXQsICd0ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICRwYXRjaFN0eWxlKGZpcnN0Tm9kZSwgcGF0Y2gpO1xuICAgIH1cbiAgICBpZiAoJGlzVGV4dE5vZGUobGFzdE5vZGUpICYmIGxhc3ROb2RlLmNhbkhhdmVGb3JtYXQoKSkge1xuICAgICAgY29uc3QgbGFzdE5vZGVUZXh0ID0gbGFzdE5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgIGNvbnN0IGxhc3ROb2RlVGV4dExlbmd0aCA9IGxhc3ROb2RlVGV4dC5sZW5ndGg7XG5cbiAgICAgIC8vIFRoZSBsYXN0IG5vZGUgbWlnaHQgbm90IGFjdHVhbGx5IGJlIHRoZSBlbmQgbm9kZVxuICAgICAgLy9cbiAgICAgIC8vIElmIG5vdCwgYXNzdW1lIHRoZSBsYXN0IG5vZGUgaXMgZnVsbHktc2VsZWN0ZWQgdW5sZXNzIHRoZSBlbmQgb2Zmc2V0IGlzXG4gICAgICAvLyB6ZXJvLlxuICAgICAgaWYgKGxhc3ROb2RlLl9fa2V5ICE9PSBlbmRLZXkgJiYgZW5kT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgIGVuZE9mZnNldCA9IGxhc3ROb2RlVGV4dExlbmd0aDtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlIGVudGlyZSBsYXN0IG5vZGUgaXNuJ3Qgc2VsZWN0ZWQsIHNwbGl0IGl0XG4gICAgICBpZiAoZW5kT2Zmc2V0ICE9PSBsYXN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICAgICAgW2xhc3ROb2RlXSA9IGxhc3ROb2RlLnNwbGl0VGV4dChlbmRPZmZzZXQpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZE9mZnNldCAhPT0gMCB8fCBlbmRUeXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgICAgJHBhdGNoU3R5bGUobGFzdE5vZGUsIHBhdGNoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdHlsZSBhbGwgdGhlIHRleHQgbm9kZXMgaW4gYmV0d2VlblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFzdEluZGV4OyBpKyspIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IHNlbGVjdGVkTm9kZXNbaV07XG4gICAgICBjb25zdCBzZWxlY3RlZE5vZGVLZXkgPSBzZWxlY3RlZE5vZGUuZ2V0S2V5KCk7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUoc2VsZWN0ZWROb2RlKSAmJiBzZWxlY3RlZE5vZGUuY2FuSGF2ZUZvcm1hdCgpICYmIHNlbGVjdGVkTm9kZUtleSAhPT0gZmlyc3ROb2RlLmdldEtleSgpICYmIHNlbGVjdGVkTm9kZUtleSAhPT0gbGFzdE5vZGUuZ2V0S2V5KCkgJiYgIXNlbGVjdGVkTm9kZS5pc1Rva2VuKCkpIHtcbiAgICAgICAgJHBhdGNoU3R5bGUoc2VsZWN0ZWROb2RlLCBwYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vKipcbiAqIENvbnZlcnRzIGFsbCBub2RlcyBpbiB0aGUgc2VsZWN0aW9uIHRoYXQgYXJlIG9mIG9uZSBibG9jayB0eXBlIHRvIGFub3RoZXIuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGVkIGJsb2NrcyB0byBiZSBjb252ZXJ0ZWQuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudCAtIFRoZSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIG5vZGUuIGVnLiAkY3JlYXRlUGFyYWdyYXBoTm9kZS5cbiAqL1xuZnVuY3Rpb24gJHNldEJsb2Nrc1R5cGUoc2VsZWN0aW9uLCBjcmVhdGVFbGVtZW50KSB7XG4gIGlmIChzZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbmRQb2ludHMoKTtcbiAgY29uc3QgYW5jaG9yID0gYW5jaG9yQW5kRm9jdXMgPyBhbmNob3JBbmRGb2N1c1swXSA6IG51bGw7XG4gIGlmIChhbmNob3IgIT09IG51bGwgJiYgYW5jaG9yLmtleSA9PT0gJ3Jvb3QnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gcm9vdC5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgIGZpcnN0Q2hpbGQucmVwbGFjZShlbGVtZW50LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdC5hcHBlbmQoZWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBmaXJzdFNlbGVjdGVkQmxvY2sgPSBhbmNob3IgIT09IG51bGwgPyAkZ2V0QW5jZXN0b3IoYW5jaG9yLmdldE5vZGUoKSwgSU5URVJOQUxfJGlzQmxvY2spIDogZmFsc2U7XG4gIGlmIChmaXJzdFNlbGVjdGVkQmxvY2sgJiYgbm9kZXMuaW5kZXhPZihmaXJzdFNlbGVjdGVkQmxvY2spID09PSAtMSkge1xuICAgIG5vZGVzLnB1c2goZmlyc3RTZWxlY3RlZEJsb2NrKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICghSU5URVJOQUxfJGlzQmxvY2sobm9kZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgYmxvY2sgbm9kZSB0byBiZSBhbiBFbGVtZW50Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gY3JlYXRlRWxlbWVudCgpO1xuICAgIHRhcmdldEVsZW1lbnQuc2V0Rm9ybWF0KG5vZGUuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICB0YXJnZXRFbGVtZW50LnNldEluZGVudChub2RlLmdldEluZGVudCgpKTtcbiAgICBub2RlLnJlcGxhY2UodGFyZ2V0RWxlbWVudCwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzUG9pbnRBdHRhY2hlZChwb2ludCkge1xuICByZXR1cm4gcG9pbnQuZ2V0Tm9kZSgpLmlzQXR0YWNoZWQoKTtcbn1cbmZ1bmN0aW9uICRyZW1vdmVQYXJlbnRFbXB0eUVsZW1lbnRzKHN0YXJ0aW5nTm9kZSkge1xuICBsZXQgbm9kZSA9IHN0YXJ0aW5nTm9kZTtcbiAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgISRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICBjb25zdCBsYXRlc3QgPSBub2RlLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIGlmIChsYXRlc3QuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgIG5vZGUucmVtb3ZlKHRydWUpO1xuICAgIH1cbiAgICBub2RlID0gcGFyZW50Tm9kZTtcbiAgfVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBXcmFwcyBhbGwgbm9kZXMgaW4gdGhlIHNlbGVjdGlvbiBpbnRvIGFub3RoZXIgbm9kZSBvZiB0aGUgdHlwZSByZXR1cm5lZCBieSBjcmVhdGVFbGVtZW50LlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gb2Ygbm9kZXMgdG8gYmUgd3JhcHBlZC5cbiAqIEBwYXJhbSBjcmVhdGVFbGVtZW50IC0gQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIHdyYXBwaW5nIEVsZW1lbnROb2RlLiBlZy4gJGNyZWF0ZVBhcmFncmFwaE5vZGUuXG4gKiBAcGFyYW0gd3JhcHBpbmdFbGVtZW50IC0gQW4gZWxlbWVudCB0byBhcHBlbmQgdGhlIHdyYXBwZWQgc2VsZWN0aW9uIGFuZCBpdHMgY2hpbGRyZW4gdG8uXG4gKi9cbmZ1bmN0aW9uICR3cmFwTm9kZXMoc2VsZWN0aW9uLCBjcmVhdGVFbGVtZW50LCB3cmFwcGluZ0VsZW1lbnQgPSBudWxsKSB7XG4gIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gIGNvbnN0IGFuY2hvciA9IGFuY2hvckFuZEZvY3VzID8gYW5jaG9yQW5kRm9jdXNbMF0gOiBudWxsO1xuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcbiAgaWYgKGFuY2hvciAhPT0gbnVsbCAmJiAobm9kZXNMZW5ndGggPT09IDAgfHwgbm9kZXNMZW5ndGggPT09IDEgJiYgYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBhbmNob3IuZ2V0Tm9kZSgpLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IGFuY2hvci50eXBlID09PSAndGV4dCcgPyBhbmNob3IuZ2V0Tm9kZSgpLmdldFBhcmVudE9yVGhyb3coKSA6IGFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0YXJnZXQuZ2V0Q2hpbGRyZW4oKTtcbiAgICBsZXQgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICBlbGVtZW50LnNldEZvcm1hdCh0YXJnZXQuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICBlbGVtZW50LnNldEluZGVudCh0YXJnZXQuZ2V0SW5kZW50KCkpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gZWxlbWVudC5hcHBlbmQoY2hpbGQpKTtcbiAgICBpZiAod3JhcHBpbmdFbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gd3JhcHBpbmdFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICB9XG4gICAgdGFyZ2V0LnJlcGxhY2UoZWxlbWVudCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCB0b3BMZXZlbE5vZGUgPSBudWxsO1xuICBsZXQgZGVzY2VuZGFudHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIC8vIERldGVybWluZSB3aGV0aGVyIHdyYXBwaW5nIGhhcyB0byBiZSBicm9rZW4gZG93biBpbnRvIG11bHRpcGxlIGNodW5rcy4gVGhpcyBjYW4gaGFwcGVuIGlmIHRoZVxuICAgIC8vIHVzZXIgc2VsZWN0ZWQgbXVsdGlwbGUgUm9vdC1saWtlIG5vZGVzIHRoYXQgaGF2ZSB0byBiZSB0cmVhdGVkIHNlcGFyYXRlbHkgYXMgaWYgdGhleSBhcmVcbiAgICAvLyB0aGVpciBvd24gYnJhbmNoLiBJLmUuIHlvdSBkb24ndCB3YW50IHRvIHdyYXAgYSB3aG9sZSB0YWJsZSwgYnV0IHJhdGhlciB0aGUgY29udGVudHMgb2YgZWFjaFxuICAgIC8vIG9mIGVhY2ggb2YgdGhlIGNlbGwgbm9kZXMuXG4gICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICAgICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzLmxlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50KTtcbiAgICAgIGRlc2NlbmRhbnRzID0gW107XG4gICAgICB0b3BMZXZlbE5vZGUgPSBub2RlO1xuICAgIH0gZWxzZSBpZiAodG9wTGV2ZWxOb2RlID09PSBudWxsIHx8IHRvcExldmVsTm9kZSAhPT0gbnVsbCAmJiAkaGFzQW5jZXN0b3Iobm9kZSwgdG9wTGV2ZWxOb2RlKSkge1xuICAgICAgZGVzY2VuZGFudHMucHVzaChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHdyYXBOb2Rlc0ltcGwoc2VsZWN0aW9uLCBkZXNjZW5kYW50cywgZGVzY2VuZGFudHMubGVuZ3RoLCBjcmVhdGVFbGVtZW50LCB3cmFwcGluZ0VsZW1lbnQpO1xuICAgICAgZGVzY2VuZGFudHMgPSBbbm9kZV07XG4gICAgfVxuICB9XG4gICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzLmxlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50KTtcbn1cblxuLyoqXG4gKiBXcmFwcyBlYWNoIG5vZGUgaW50byBhIG5ldyBFbGVtZW50Tm9kZS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIG9mIG5vZGVzIHRvIHdyYXAuXG4gKiBAcGFyYW0gbm9kZXMgLSBBbiBhcnJheSBvZiBub2RlcywgZ2VuZXJhbGx5IHRoZSBkZXNjZW5kYW50cyBvZiB0aGUgc2VsZWN0aW9uLlxuICogQHBhcmFtIG5vZGVzTGVuZ3RoIC0gVGhlIGxlbmd0aCBvZiBub2Rlcy5cbiAqIEBwYXJhbSBjcmVhdGVFbGVtZW50IC0gQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIHdyYXBwaW5nIEVsZW1lbnROb2RlLiBlZy4gJGNyZWF0ZVBhcmFncmFwaE5vZGUuXG4gKiBAcGFyYW0gd3JhcHBpbmdFbGVtZW50IC0gQW4gZWxlbWVudCB0byB3cmFwIGFsbCB0aGUgbm9kZXMgaW50by5cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgbm9kZXMsIG5vZGVzTGVuZ3RoLCBjcmVhdGVFbGVtZW50LCB3cmFwcGluZ0VsZW1lbnQgPSBudWxsKSB7XG4gIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZmlyc3ROb2RlID0gbm9kZXNbMF07XG4gIGNvbnN0IGVsZW1lbnRNYXBwaW5nID0gbmV3IE1hcCgpO1xuICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAvLyBUaGUgYmVsb3cgbG9naWMgaXMgdG8gZmluZCB0aGUgcmlnaHQgdGFyZ2V0IGZvciB1cyB0b1xuICAvLyBlaXRoZXIgaW5zZXJ0QWZ0ZXIvaW5zZXJ0QmVmb3JlL2FwcGVuZCB0aGUgY29ycmVzcG9uZGluZ1xuICAvLyBlbGVtZW50cyB0by4gVGhpcyBpcyBtYWRlIG1vcmUgY29tcGxpY2F0ZWQgZHVlIHRvIG5lc3RlZFxuICAvLyBzdHJ1Y3R1cmVzLlxuICBsZXQgdGFyZ2V0ID0gJGlzRWxlbWVudE5vZGUoZmlyc3ROb2RlKSA/IGZpcnN0Tm9kZSA6IGZpcnN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIGlmICh0YXJnZXQuaXNJbmxpbmUoKSkge1xuICAgIHRhcmdldCA9IHRhcmdldC5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cbiAgbGV0IHRhcmdldElzUHJldlNpYmxpbmcgPSBmYWxzZTtcbiAgd2hpbGUgKHRhcmdldCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGFyZ2V0LmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGlmIChwcmV2U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgdGFyZ2V0ID0gcHJldlNpYmxpbmc7XG4gICAgICB0YXJnZXRJc1ByZXZTaWJsaW5nID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0YXJnZXQgPSB0YXJnZXQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KHRhcmdldCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCBlbXB0eUVsZW1lbnRzID0gbmV3IFNldCgpO1xuXG4gIC8vIEZpbmQgYW55IHRvcCBsZXZlbCBlbXB0eSBlbGVtZW50c1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgIGVtcHR5RWxlbWVudHMuYWRkKG5vZGUuZ2V0S2V5KCkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBtb3ZlZE5vZGVzID0gbmV3IFNldCgpO1xuXG4gIC8vIE1vdmUgb3V0IGFsbCBsZWFmIG5vZGVzIGludG8gb3VyIGVsZW1lbnRzIGFycmF5LlxuICAvLyBJZiB3ZSBmaW5kIGEgdG9wIGxldmVsIGVtcHR5IGVsZW1lbnQsIGFsc28gbW92ZSBtYWtlXG4gIC8vIGFuIGVsZW1lbnQgZm9yIHRoYXQuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBsZXQgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBpZiAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC5pc0lubGluZSgpKSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgfVxuICAgIGlmIChwYXJlbnQgIT09IG51bGwgJiYgJGlzTGVhZk5vZGUobm9kZSkgJiYgIW1vdmVkTm9kZXMuaGFzKG5vZGUuZ2V0S2V5KCkpKSB7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBwYXJlbnQuZ2V0S2V5KCk7XG4gICAgICBpZiAoZWxlbWVudE1hcHBpbmcuZ2V0KHBhcmVudEtleSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gY3JlYXRlRWxlbWVudCgpO1xuICAgICAgICB0YXJnZXRFbGVtZW50LnNldEZvcm1hdChwYXJlbnQuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRJbmRlbnQocGFyZW50LmdldEluZGVudCgpKTtcbiAgICAgICAgZWxlbWVudHMucHVzaCh0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgZWxlbWVudE1hcHBpbmcuc2V0KHBhcmVudEtleSwgdGFyZ2V0RWxlbWVudCk7XG4gICAgICAgIC8vIE1vdmUgbm9kZSBhbmQgaXRzIHNpYmxpbmdzIHRvIHRoZSBuZXdcbiAgICAgICAgLy8gZWxlbWVudC5cbiAgICAgICAgcGFyZW50LmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgdGFyZ2V0RWxlbWVudC5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgIG1vdmVkTm9kZXMuYWRkKGNoaWxkLmdldEtleSgpKTtcbiAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICAvLyBTa2lwIG5lc3RlZCBsZWFmIG5vZGVzIGlmIHRoZSBwYXJlbnQgaGFzIGFscmVhZHkgYmVlbiBtb3ZlZFxuICAgICAgICAgICAgY2hpbGQuZ2V0Q2hpbGRyZW5LZXlzKCkuZm9yRWFjaChrZXkgPT4gbW92ZWROb2Rlcy5hZGQoa2V5KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgJHJlbW92ZVBhcmVudEVtcHR5RWxlbWVudHMocGFyZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVtcHR5RWxlbWVudHMuaGFzKG5vZGUuZ2V0S2V5KCkpKSB7XG4gICAgICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBub2RlIGluIGVtcHR5RWxlbWVudHMgdG8gYmUgYW4gRWxlbWVudE5vZGVgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgICB0YXJnZXRFbGVtZW50LnNldEZvcm1hdChub2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gICAgICB0YXJnZXRFbGVtZW50LnNldEluZGVudChub2RlLmdldEluZGVudCgpKTtcbiAgICAgIGVsZW1lbnRzLnB1c2godGFyZ2V0RWxlbWVudCk7XG4gICAgICBub2RlLnJlbW92ZSh0cnVlKTtcbiAgICB9XG4gIH1cbiAgaWYgKHdyYXBwaW5nRWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIHdyYXBwaW5nRWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGxldCBsYXN0RWxlbWVudCA9IG51bGw7XG5cbiAgLy8gSWYgb3VyIHRhcmdldCBpcyBSb290LWxpa2UsIGxldCdzIHNlZSBpZiB3ZSBjYW4gcmUtYWRqdXN0XG4gIC8vIHNvIHRoYXQgdGhlIHRhcmdldCBpcyB0aGUgZmlyc3QgY2hpbGQgaW5zdGVhZC5cbiAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QodGFyZ2V0KSkge1xuICAgIGlmICh0YXJnZXRJc1ByZXZTaWJsaW5nKSB7XG4gICAgICBpZiAod3JhcHBpbmdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHRhcmdldC5pbnNlcnRBZnRlcih3cmFwcGluZ0VsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGVsZW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgIHRhcmdldC5pbnNlcnRBZnRlcihlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmaXJzdENoaWxkID0gdGFyZ2V0LmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgICB0YXJnZXQgPSBmaXJzdENoaWxkO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0Q2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHdyYXBwaW5nRWxlbWVudCkge1xuICAgICAgICAgIHRhcmdldC5hcHBlbmQod3JhcHBpbmdFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICB0YXJnZXQuYXBwZW5kKGVsZW1lbnQpO1xuICAgICAgICAgICAgbGFzdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHdyYXBwaW5nRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUoZWxlbWVudCk7XG4gICAgICAgICAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh3cmFwcGluZ0VsZW1lbnQpIHtcbiAgICAgIHRhcmdldC5pbnNlcnRBZnRlcih3cmFwcGluZ0VsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gZWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIoZWxlbWVudCk7XG4gICAgICAgIGxhc3RFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgcHJldlNlbGVjdGlvbiA9ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgaXNQb2ludEF0dGFjaGVkKHByZXZTZWxlY3Rpb24uYW5jaG9yKSAmJiBpc1BvaW50QXR0YWNoZWQocHJldlNlbGVjdGlvbi5mb2N1cykpIHtcbiAgICAkc2V0U2VsZWN0aW9uKHByZXZTZWxlY3Rpb24uY2xvbmUoKSk7XG4gIH0gZWxzZSBpZiAobGFzdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICBsYXN0RWxlbWVudC5zZWxlY3RFbmQoKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZGVmYXVsdCBjaGFyYWN0ZXIgc2VsZWN0aW9uIHNob3VsZCBiZSBvdmVycmlkZGVuLiBVc2VkIHdpdGggRGVjb3JhdG9yTm9kZXNcbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIHdob3NlIGRlZmF1bHQgY2hhcmFjdGVyIHNlbGVjdGlvbiBtYXkgbmVlZCB0byBiZSBvdmVycmlkZGVuLlxuICogQHBhcmFtIGlzQmFja3dhcmQgLSBJcyB0aGUgc2VsZWN0aW9uIGJhY2t3YXJkcyAodGhlIGZvY3VzIGNvbWVzIGJlZm9yZSB0aGUgYW5jaG9yKT9cbiAqIEByZXR1cm5zIHRydWUgaWYgaXQgc2hvdWxkIGJlIG92ZXJyaWRkZW4sIGZhbHNlIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbihzZWxlY3Rpb24sIGlzQmFja3dhcmQpIHtcbiAgY29uc3QgcG9zc2libGVOb2RlID0gJGdldEFkamFjZW50Tm9kZShzZWxlY3Rpb24uZm9jdXMsIGlzQmFja3dhcmQpO1xuICByZXR1cm4gJGlzRGVjb3JhdG9yTm9kZShwb3NzaWJsZU5vZGUpICYmICFwb3NzaWJsZU5vZGUuaXNJc29sYXRlZCgpIHx8ICRpc0VsZW1lbnROb2RlKHBvc3NpYmxlTm9kZSkgJiYgIXBvc3NpYmxlTm9kZS5pc0lubGluZSgpICYmICFwb3NzaWJsZU5vZGUuY2FuQmVFbXB0eSgpO1xufVxuXG4vKipcbiAqIE1vdmVzIHRoZSBzZWxlY3Rpb24gYWNjb3JkaW5nIHRvIHRoZSBhcmd1bWVudHMuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGVkIHRleHQgb3Igbm9kZXMuXG4gKiBAcGFyYW0gaXNIb2xkaW5nU2hpZnQgLSBJcyB0aGUgc2hpZnQga2V5IGJlaW5nIGhlbGQgZG93biBkdXJpbmcgdGhlIG9wZXJhdGlvbi5cbiAqIEBwYXJhbSBpc0JhY2t3YXJkIC0gSXMgdGhlIHNlbGVjdGlvbiBzZWxlY3RlZCBiYWNrd2FyZHMgKHRoZSBmb2N1cyBjb21lcyBiZWZvcmUgdGhlIGFuY2hvcik/XG4gKiBAcGFyYW0gZ3JhbnVsYXJpdHkgLSBUaGUgZGlzdGFuY2UgdG8gYWRqdXN0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gJG1vdmVDYXJldFNlbGVjdGlvbihzZWxlY3Rpb24sIGlzSG9sZGluZ1NoaWZ0LCBpc0JhY2t3YXJkLCBncmFudWxhcml0eSkge1xuICBzZWxlY3Rpb24ubW9kaWZ5KGlzSG9sZGluZ1NoaWZ0ID8gJ2V4dGVuZCcgOiAnbW92ZScsIGlzQmFja3dhcmQsIGdyYW51bGFyaXR5KTtcbn1cblxuLyoqXG4gKiBUZXN0cyBhIHBhcmVudCBlbGVtZW50IGZvciByaWdodCB0byBsZWZ0IGRpcmVjdGlvbi5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIHdob3NlIHBhcmVudCBpcyB0byBiZSB0ZXN0ZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzZWxlY3Rpb25zJyBwYXJlbnQgZWxlbWVudCBoYXMgYSBkaXJlY3Rpb24gb2YgJ3J0bCcgKHJpZ2h0IHRvIGxlZnQpLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uICRpc1BhcmVudEVsZW1lbnRSVEwoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgcGFyZW50ID0gJGlzUm9vdE5vZGUoYW5jaG9yTm9kZSkgPyBhbmNob3JOb2RlIDogYW5jaG9yTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIHJldHVybiBwYXJlbnQuZ2V0RGlyZWN0aW9uKCkgPT09ICdydGwnO1xufVxuXG4vKipcbiAqIE1vdmVzIHNlbGVjdGlvbiBieSBjaGFyYWN0ZXIgYWNjb3JkaW5nIHRvIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIG9mIHRoZSBjaGFyYWN0ZXJzIHRvIG1vdmUuXG4gKiBAcGFyYW0gaXNIb2xkaW5nU2hpZnQgLSBJcyB0aGUgc2hpZnQga2V5IGJlaW5nIGhlbGQgZG93biBkdXJpbmcgdGhlIG9wZXJhdGlvbi5cbiAqIEBwYXJhbSBpc0JhY2t3YXJkIC0gSXMgdGhlIHNlbGVjdGlvbiBiYWNrd2FyZCAodGhlIGZvY3VzIGNvbWVzIGJlZm9yZSB0aGUgYW5jaG9yKT9cbiAqL1xuZnVuY3Rpb24gJG1vdmVDaGFyYWN0ZXIoc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgaXNCYWNrd2FyZCkge1xuICBjb25zdCBpc1JUTCA9ICRpc1BhcmVudEVsZW1lbnRSVEwoc2VsZWN0aW9uKTtcbiAgJG1vdmVDYXJldFNlbGVjdGlvbihzZWxlY3Rpb24sIGlzSG9sZGluZ1NoaWZ0LCBpc0JhY2t3YXJkID8gIWlzUlRMIDogaXNSVEwsICdjaGFyYWN0ZXInKTtcbn1cblxuLyoqXG4gKiBFeHBhbmRzIHRoZSBjdXJyZW50IFNlbGVjdGlvbiB0byBjb3ZlciBhbGwgb2YgdGhlIGNvbnRlbnQgaW4gdGhlIGVkaXRvci5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uICRzZWxlY3RBbGwoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgdG9wUGFyZW50ID0gYW5jaG9yTm9kZS5nZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCk7XG4gIGNvbnN0IHJvb3QgPSB0b3BQYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICBsZXQgZmlyc3ROb2RlID0gcm9vdC5nZXRGaXJzdERlc2NlbmRhbnQoKTtcbiAgbGV0IGxhc3ROb2RlID0gcm9vdC5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICBsZXQgZmlyc3RUeXBlID0gJ2VsZW1lbnQnO1xuICBsZXQgbGFzdFR5cGUgPSAnZWxlbWVudCc7XG4gIGxldCBsYXN0T2Zmc2V0ID0gMDtcbiAgaWYgKCRpc1RleHROb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICBmaXJzdFR5cGUgPSAndGV4dCc7XG4gIH0gZWxzZSBpZiAoISRpc0VsZW1lbnROb2RlKGZpcnN0Tm9kZSkgJiYgZmlyc3ROb2RlICE9PSBudWxsKSB7XG4gICAgZmlyc3ROb2RlID0gZmlyc3ROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgfVxuICBpZiAoJGlzVGV4dE5vZGUobGFzdE5vZGUpKSB7XG4gICAgbGFzdFR5cGUgPSAndGV4dCc7XG4gICAgbGFzdE9mZnNldCA9IGxhc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICB9IGVsc2UgaWYgKCEkaXNFbGVtZW50Tm9kZShsYXN0Tm9kZSkgJiYgbGFzdE5vZGUgIT09IG51bGwpIHtcbiAgICBsYXN0Tm9kZSA9IGxhc3ROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgfVxuICBpZiAoZmlyc3ROb2RlICYmIGxhc3ROb2RlKSB7XG4gICAgYW5jaG9yLnNldChmaXJzdE5vZGUuZ2V0S2V5KCksIDAsIGZpcnN0VHlwZSk7XG4gICAgZm9jdXMuc2V0KGxhc3ROb2RlLmdldEtleSgpLCBsYXN0T2Zmc2V0LCBsYXN0VHlwZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgQ1NTIHByb3BlcnR5IGZvciBOb2RlcywgaWYgc2V0LiBJZiBub3Qgc2V0LCBpdCByZXR1cm5zIHRoZSBkZWZhdWx0VmFsdWUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHdob3NlIHN0eWxlIHZhbHVlIHRvIGdldC5cbiAqIEBwYXJhbSBzdHlsZVByb3BlcnR5IC0gVGhlIENTUyBzdHlsZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHByb3BlcnR5LlxuICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBmb3Igbm9kZS5cbiAqL1xuZnVuY3Rpb24gJGdldE5vZGVTdHlsZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgc3R5bGVQcm9wZXJ0eSwgZGVmYXVsdFZhbHVlKSB7XG4gIGNvbnN0IGNzcyA9IG5vZGUuZ2V0U3R5bGUoKTtcbiAgY29uc3Qgc3R5bGVPYmplY3QgPSBnZXRTdHlsZU9iamVjdEZyb21DU1MoY3NzKTtcbiAgaWYgKHN0eWxlT2JqZWN0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0W3N0eWxlUHJvcGVydHldIHx8IGRlZmF1bHRWYWx1ZTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBDU1MgcHJvcGVydHkgZm9yIFRleHROb2RlcyBpbiB0aGUgU2VsZWN0aW9uLCBpZiBzZXQuIElmIG5vdCBzZXQsIGl0IHJldHVybnMgdGhlIGRlZmF1bHRWYWx1ZS5cbiAqIElmIGFsbCBUZXh0Tm9kZXMgZG8gbm90IGhhdmUgdGhlIHNhbWUgdmFsdWUsIGl0IHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gb2YgVGV4dE5vZGVzIHdob3NlIHZhbHVlIHRvIGZpbmQuXG4gKiBAcGFyYW0gc3R5bGVQcm9wZXJ0eSAtIFRoZSBDU1Mgc3R5bGUgcHJvcGVydHkuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBwcm9wZXJ0eSwgZGVmYXVsdHMgdG8gYW4gZW1wdHkgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBmb3IgdGhlIHNlbGVjdGVkIFRleHROb2Rlcy5cbiAqL1xuZnVuY3Rpb24gJGdldFNlbGVjdGlvblN0eWxlVmFsdWVGb3JQcm9wZXJ0eShzZWxlY3Rpb24sIHN0eWxlUHJvcGVydHksIGRlZmF1bHRWYWx1ZSA9ICcnKSB7XG4gIGxldCBzdHlsZVZhbHVlID0gbnVsbDtcbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGlzQmFja3dhcmQgPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpO1xuICBjb25zdCBlbmRPZmZzZXQgPSBpc0JhY2t3YXJkID8gZm9jdXMub2Zmc2V0IDogYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgZW5kTm9kZSA9IGlzQmFja3dhcmQgPyBmb2N1cy5nZXROb2RlKCkgOiBhbmNob3IuZ2V0Tm9kZSgpO1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBzZWxlY3Rpb24uc3R5bGUgIT09ICcnKSB7XG4gICAgY29uc3QgY3NzID0gc2VsZWN0aW9uLnN0eWxlO1xuICAgIGNvbnN0IHN0eWxlT2JqZWN0ID0gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKGNzcyk7XG4gICAgaWYgKHN0eWxlT2JqZWN0ICE9PSBudWxsICYmIHN0eWxlUHJvcGVydHkgaW4gc3R5bGVPYmplY3QpIHtcbiAgICAgIHJldHVybiBzdHlsZU9iamVjdFtzdHlsZVByb3BlcnR5XTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgIC8vIGlmIG5vIGFjdHVhbCBjaGFyYWN0ZXJzIGluIHRoZSBlbmQgbm9kZSBhcmUgc2VsZWN0ZWQsIHdlIGRvbid0XG4gICAgLy8gaW5jbHVkZSBpdCBpbiB0aGUgc2VsZWN0aW9uIGZvciBwdXJwb3NlcyBvZiBkZXRlcm1pbmluZyBzdHlsZVxuICAgIC8vIHZhbHVlXG4gICAgaWYgKGkgIT09IDAgJiYgZW5kT2Zmc2V0ID09PSAwICYmIG5vZGUuaXMoZW5kTm9kZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IG5vZGVTdHlsZVZhbHVlID0gJGdldE5vZGVTdHlsZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgc3R5bGVQcm9wZXJ0eSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgIGlmIChzdHlsZVZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHN0eWxlVmFsdWUgPSBub2RlU3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGVWYWx1ZSAhPT0gbm9kZVN0eWxlVmFsdWUpIHtcbiAgICAgICAgLy8gbXVsdGlwbGUgdGV4dCBub2RlcyBhcmUgaW4gdGhlIHNlbGVjdGlvbiBhbmQgdGhleSBkb24ndCBhbGxcbiAgICAgICAgLy8gaGF2ZSB0aGUgc2FtZSBzdHlsZS5cbiAgICAgICAgc3R5bGVWYWx1ZSA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlVmFsdWUgPT09IG51bGwgPyBkZWZhdWx0VmFsdWUgOiBzdHlsZVZhbHVlO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZm9yIGludGVybmFsIHVzZSBvZiB0aGUgbGlicmFyeS5cbiAqIFBsZWFzZSBkbyBub3QgdXNlIGl0IGFzIGl0IG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAqL1xuZnVuY3Rpb24gSU5URVJOQUxfJGlzQmxvY2sobm9kZSkge1xuICBpZiAoJGlzRGVjb3JhdG9yTm9kZShub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpIHx8ICRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZmlyc3RDaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICBjb25zdCBpc0xlYWZFbGVtZW50ID0gZmlyc3RDaGlsZCA9PT0gbnVsbCB8fCAkaXNMaW5lQnJlYWtOb2RlKGZpcnN0Q2hpbGQpIHx8ICRpc1RleHROb2RlKGZpcnN0Q2hpbGQpIHx8IGZpcnN0Q2hpbGQuaXNJbmxpbmUoKTtcbiAgcmV0dXJuICFub2RlLmlzSW5saW5lKCkgJiYgbm9kZS5jYW5CZUVtcHR5KCkgIT09IGZhbHNlICYmIGlzTGVhZkVsZW1lbnQ7XG59XG5mdW5jdGlvbiAkZ2V0QW5jZXN0b3Iobm9kZSwgcHJlZGljYXRlKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC5nZXRQYXJlbnQoKSAhPT0gbnVsbCAmJiAhcHJlZGljYXRlKHBhcmVudCkpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG4gIHJldHVybiBwcmVkaWNhdGUocGFyZW50KSA/IHBhcmVudCA6IG51bGw7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8ge0BsaW5rICR0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yfSBieSBAbGV4aWNhbC9lc2xpbnQtcGx1Z2luIHJ1bGVzLW9mLWxleGljYWwgKi9cbmNvbnN0IHRyaW1UZXh0Q29udGVudEZyb21BbmNob3IgPSAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvcjtcblxuZXhwb3J0IHsgJGFkZE5vZGVTdHlsZSwgJGNsb25lV2l0aFByb3BlcnRpZXMsICRnZXRTZWxlY3Rpb25TdHlsZVZhbHVlRm9yUHJvcGVydHksICRpc0F0Tm9kZUVuZCwgJGlzUGFyZW50RWxlbWVudFJUTCwgJG1vdmVDYXJldFNlbGVjdGlvbiwgJG1vdmVDaGFyYWN0ZXIsICRwYXRjaFN0eWxlVGV4dCwgJHNlbGVjdEFsbCwgJHNldEJsb2Nrc1R5cGUsICRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24sICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50LCAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvciwgJHdyYXBOb2RlcywgY3JlYXRlRE9NUmFuZ2UsIGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlLCBnZXRTdHlsZU9iamVjdEZyb21DU1MsIHRyaW1UZXh0Q29udGVudEZyb21BbmNob3IgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/text/LexicalText.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/text/LexicalText.dev.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $canShowPlaceholder: () => (/* binding */ $canShowPlaceholder),\n/* harmony export */   $canShowPlaceholderCurry: () => (/* binding */ $canShowPlaceholderCurry),\n/* harmony export */   $findTextIntersectionFromCharacters: () => (/* binding */ $findTextIntersectionFromCharacters),\n/* harmony export */   $isRootTextContentEmpty: () => (/* binding */ $isRootTextContentEmpty),\n/* harmony export */   $isRootTextContentEmptyCurry: () => (/* binding */ $isRootTextContentEmptyCurry),\n/* harmony export */   $rootTextContent: () => (/* binding */ $rootTextContent),\n/* harmony export */   registerLexicalTextEntity: () => (/* binding */ registerLexicalTextEntity)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\nfunction $rootTextContent() {\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  return root.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(topBlock)) {\n      return false;\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(topBlock)) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $replaceWithSimpleText = node => {\n    const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const $textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    let prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          $replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n    let prevMatchLengthToSkip = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              $replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling) && prevSibling.isTextEntity()) {\n        prevMatchLengthToSkip += match.end;\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start + prevMatchLengthToSkip, match.end + prevMatchLengthToSkip);\n      }\n      if (!(nodeToReplace !== undefined)) {\n        throw Error(`${'nodeToReplace'} should not be undefined. You may want to check splitOffsets passed to the splitText.`);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n      prevMatchLengthToSkip = 0;\n      prevSibling = replacementNode;\n    }\n  };\n  const $reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      $replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling) && prevSibling.isTextEntity()) {\n      $replaceWithSimpleText(prevSibling);\n      $replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling) && nextSibling.isTextEntity()) {\n      $replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        $replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode, $textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, $reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGV4dC9MZXhpY2FsVGV4dC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStIOztBQUUvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBLFFBQVEseURBQWdCO0FBQ3hCO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCLFdBQVcseURBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBLGFBQWEsb0RBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsb0RBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9EQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSw2Q0FBUTtBQUN4RTtBQUNBO0FBQ0E7O0FBRWtNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl2ZWRvY3MvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGV4dC9MZXhpY2FsVGV4dC5kZXYubWpzP2Y5YjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkZ2V0Um9vdCwgJGlzRGVjb3JhdG9yTm9kZSwgJGlzRWxlbWVudE5vZGUsICRpc1BhcmFncmFwaE5vZGUsICRpc1RleHROb2RlLCBUZXh0Tm9kZSwgJGNyZWF0ZVRleHROb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByb290J3MgdGV4dCBjb250ZW50LlxuICogQHJldHVybnMgVGhlIHJvb3QncyB0ZXh0IGNvbnRlbnQuXG4gKi9cbmZ1bmN0aW9uICRyb290VGV4dENvbnRlbnQoKSB7XG4gIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICByZXR1cm4gcm9vdC5nZXRUZXh0Q29udGVudCgpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcm9vdCBoYXMgYW55IHRleHQgY29udGVudCBhbmQgY2FuIHRyaW0gYW55IHdoaXRlc3BhY2UgaWYgaXQgZG9lcy5cbiAqIEBwYXJhbSBpc0VkaXRvckNvbXBvc2luZyAtIElzIHRoZSBlZGl0b3IgaW4gY29tcG9zaXRpb24gbW9kZSBkdWUgdG8gYW4gYWN0aXZlIElucHV0IE1ldGhvZCBFZGl0b3I/XG4gKiBAcGFyYW0gdHJpbSAtIFNob3VsZCB0aGUgcm9vdCB0ZXh0IGhhdmUgaXRzIHdoaXRlc3BhY2VkIHRyaW1tZWQ/IERlZmF1bHRzIHRvIHRydWUuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRleHQgY29udGVudCBpcyBlbXB0eSwgZmFsc2UgaWYgdGhlcmUgaXMgdGV4dCBvciBpc0VkaXRvckNvbXBvc2luZyBpcyB0cnVlLlxuICovXG5mdW5jdGlvbiAkaXNSb290VGV4dENvbnRlbnRFbXB0eShpc0VkaXRvckNvbXBvc2luZywgdHJpbSA9IHRydWUpIHtcbiAgaWYgKGlzRWRpdG9yQ29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCB0ZXh0ID0gJHJvb3RUZXh0Q29udGVudCgpO1xuICBpZiAodHJpbSkge1xuICAgIHRleHQgPSB0ZXh0LnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdGV4dCA9PT0gJyc7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMge0BsaW5rICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5fVxuICogQHBhcmFtIGlzRWRpdG9yQ29tcG9zaW5nIC0gSXMgdGhlIGVkaXRvciBpbiBjb21wb3NpdGlvbiBtb2RlIGR1ZSB0byBhbiBhY3RpdmUgSW5wdXQgTWV0aG9kIEVkaXRvcj9cbiAqIEBwYXJhbSB0cmltIC0gU2hvdWxkIHRoZSByb290IHRleHQgaGF2ZSBpdHMgd2hpdGVzcGFjZWQgdHJpbW1lZD8gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyAkaXNSb290VGV4dENvbnRlbnRFbXB0eSBiYXNlZCBvbiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5Q3VycnkoaXNFZGl0b3JDb21wb3NpbmcsIHRyaW0pIHtcbiAgcmV0dXJuICgpID0+ICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5KGlzRWRpdG9yQ29tcG9zaW5nLCB0cmltKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGlucHV0IHNob3VsZCBzaG93IHRoZSBwbGFjZWhvbGRlci4gSWYgYW55dGhpbmcgaXMgaW5cbiAqIGluIHRoZSByb290IHRoZSBwbGFjZWhvbGRlciBzaG91bGQgbm90IGJlIHNob3duLlxuICogQHBhcmFtIGlzQ29tcG9zaW5nIC0gSXMgdGhlIGVkaXRvciBpbiBjb21wb3NpdGlvbiBtb2RlIGR1ZSB0byBhbiBhY3RpdmUgSW5wdXQgTWV0aG9kIEVkaXRvcj9cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IHNob3VsZCBzaG93IHRoZSBwbGFjZWhvbGRlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkY2FuU2hvd1BsYWNlaG9sZGVyKGlzQ29tcG9zaW5nKSB7XG4gIGlmICghJGlzUm9vdFRleHRDb250ZW50RW1wdHkoaXNDb21wb3NpbmcsIGZhbHNlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgY29uc3QgY2hpbGRyZW4gPSByb290LmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvcEJsb2NrID0gY2hpbGRyZW5baV07XG4gICAgaWYgKCRpc0RlY29yYXRvck5vZGUodG9wQmxvY2spKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkaXNFbGVtZW50Tm9kZSh0b3BCbG9jaykpIHtcbiAgICAgIGlmICghJGlzUGFyYWdyYXBoTm9kZSh0b3BCbG9jaykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRvcEJsb2NrLl9faW5kZW50ICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvcEJsb2NrQ2hpbGRyZW4gPSB0b3BCbG9jay5nZXRDaGlsZHJlbigpO1xuICAgICAgY29uc3QgdG9wQmxvY2tDaGlsZHJlbkxlbmd0aCA9IHRvcEJsb2NrQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0b3BCbG9ja0NoaWxkcmVuTGVuZ3RoOyBzKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSB0b3BCbG9ja0NoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoISRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyB7QGxpbmsgJGNhblNob3dQbGFjZWhvbGRlcn1cbiAqIEBwYXJhbSBpc0VkaXRvckNvbXBvc2luZyAtIElzIHRoZSBlZGl0b3IgaW4gY29tcG9zaXRpb24gbW9kZSBkdWUgdG8gYW4gYWN0aXZlIElucHV0IE1ldGhvZCBFZGl0b3I/XG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgJGNhblNob3dQbGFjZWhvbGRlciB3aXRoIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gJGNhblNob3dQbGFjZWhvbGRlckN1cnJ5KGlzRWRpdG9yQ29tcG9zaW5nKSB7XG4gIHJldHVybiAoKSA9PiAkY2FuU2hvd1BsYWNlaG9sZGVyKGlzRWRpdG9yQ29tcG9zaW5nKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIEZpbmRzIGEgVGV4dE5vZGUgd2l0aCBhIHNpemUgbGFyZ2VyIHRoYW4gdGFyZ2V0Q2hhcmFjdGVycyBhbmQgcmV0dXJuc1xuICogdGhlIG5vZGUgYWxvbmcgd2l0aCB0aGUgcmVtYWluaW5nIGxlbmd0aCBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSByb290IC0gVGhlIFJvb3ROb2RlLlxuICogQHBhcmFtIHRhcmdldENoYXJhY3RlcnMgLSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgd2hvc2UgVGV4dE5vZGUgbXVzdCBiZSBsYXJnZXIgdGhhbi5cbiAqIEByZXR1cm5zIFRoZSBUZXh0Tm9kZSBhbmQgdGhlIGludGVyc2VjdGlvbnMgb2Zmc2V0LCBvciBudWxsIGlmIG5vIFRleHROb2RlIGlzIGZvdW5kLlxuICovXG5mdW5jdGlvbiAkZmluZFRleHRJbnRlcnNlY3Rpb25Gcm9tQ2hhcmFjdGVycyhyb290LCB0YXJnZXRDaGFyYWN0ZXJzKSB7XG4gIGxldCBub2RlID0gcm9vdC5nZXRGaXJzdENoaWxkKCk7XG4gIGxldCBjdXJyZW50Q2hhcmFjdGVycyA9IDA7XG4gIG1haW5Mb29wOiB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IGNoYXJhY3RlcnMgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXJzICsgY2hhcmFjdGVycyA+IHRhcmdldENoYXJhY3RlcnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIG9mZnNldDogdGFyZ2V0Q2hhcmFjdGVycyAtIGN1cnJlbnRDaGFyYWN0ZXJzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjdXJyZW50Q2hhcmFjdGVycyArPSBjaGFyYWN0ZXJzO1xuICAgIH1cbiAgICBjb25zdCBzaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBub2RlID0gc2libGluZztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAocGFyZW50U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gcGFyZW50U2libGluZztcbiAgICAgICAgY29udGludWUgbWFpbkxvb3A7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIHR1cGxlIHRoYXQgY2FuIGJlIHJlc3RlZCAoLi4uKSBpbnRvIG1lcmdlUmVnaXN0ZXIgdG8gY2xlYW4gdXBcbiAqIG5vZGUgdHJhbnNmb3JtcyBsaXN0ZW5lcnMgdGhhdCB0cmFuc2Zvcm1zIHRleHQgaW50byBhbm90aGVyIG5vZGUsIGVnLiBhIEhhc2h0YWdOb2RlLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoXG4gICAgICAuLi5yZWdpc3RlckxleGljYWxUZXh0RW50aXR5KGVkaXRvciwgZ2V0TWF0Y2gsIHRhcmdldE5vZGUsIGNyZWF0ZU5vZGUpLFxuICAgICk7XG4gIH0sIFtjcmVhdGVOb2RlLCBlZGl0b3IsIGdldE1hdGNoLCB0YXJnZXROb2RlXSk7XG4gKiBgYGBcbiAqIFdoZXJlIHRhcmdldE5vZGUgaXMgdGhlIHR5cGUgb2Ygbm9kZSBjb250YWluaW5nIHRoZSB0ZXh0IHlvdSB3YW50IHRvIHRyYW5zZm9ybSAobGlrZSBhIHRleHQgaW5wdXQpLFxuICogdGhlbiBnZXRNYXRjaCB1c2VzIGEgcmVnZXggdG8gZmluZCBhIG1hdGNoaW5nIHRleHQgYW5kIGNyZWF0ZXMgdGhlIHByb3BlciBub2RlIHRvIGluY2x1ZGUgdGhlIG1hdGNoaW5nIHRleHQuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yLlxuICogQHBhcmFtIGdldE1hdGNoIC0gRmluZHMgYSBtYXRjaGluZyBzdHJpbmcgdGhhdCBzYXRpc2ZpZXMgYSByZWdleCBleHByZXNzaW9uLlxuICogQHBhcmFtIHRhcmdldE5vZGUgLSBUaGUgbm9kZSB0eXBlIHRoYXQgY29udGFpbnMgdGV4dCB0byBtYXRjaCB3aXRoLiBlZy4gSGFzaHRhZ05vZGVcbiAqIEBwYXJhbSBjcmVhdGVOb2RlIC0gQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgbm9kZSB0byBjb250YWluIHRoZSBtYXRjaGVkIHRleHQuIGVnIGNyZWF0ZUhhc2h0YWdOb2RlXG4gKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBwbGFpbiB0ZXh0IGFuZCByZXZlcnNlIG5vZGUgdHJhbnNmb3JtIGxpc3RlbmVycy5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJMZXhpY2FsVGV4dEVudGl0eShlZGl0b3IsIGdldE1hdGNoLCB0YXJnZXROb2RlLCBjcmVhdGVOb2RlKSB7XG4gIGNvbnN0IGlzVGFyZ2V0Tm9kZSA9IG5vZGUgPT4ge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgdGFyZ2V0Tm9kZTtcbiAgfTtcbiAgY29uc3QgJHJlcGxhY2VXaXRoU2ltcGxlVGV4dCA9IG5vZGUgPT4ge1xuICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKG5vZGUuZ2V0VGV4dENvbnRlbnQoKSk7XG4gICAgdGV4dE5vZGUuc2V0Rm9ybWF0KG5vZGUuZ2V0Rm9ybWF0KCkpO1xuICAgIG5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gIH07XG4gIGNvbnN0IGdldE1vZGUgPSBub2RlID0+IHtcbiAgICByZXR1cm4gbm9kZS5nZXRMYXRlc3QoKS5fX21vZGU7XG4gIH07XG4gIGNvbnN0ICR0ZXh0Tm9kZVRyYW5zZm9ybSA9IG5vZGUgPT4ge1xuICAgIGlmICghbm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcHJldlNpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGxldCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgbGV0IG1hdGNoO1xuICAgIGlmICgkaXNUZXh0Tm9kZShwcmV2U2libGluZykpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzVGV4dCA9IHByZXZTaWJsaW5nLmdldFRleHRDb250ZW50KCk7XG4gICAgICBjb25zdCBjb21iaW5lZFRleHQgPSBwcmV2aW91c1RleHQgKyB0ZXh0O1xuICAgICAgY29uc3QgcHJldk1hdGNoID0gZ2V0TWF0Y2goY29tYmluZWRUZXh0KTtcbiAgICAgIGlmIChpc1RhcmdldE5vZGUocHJldlNpYmxpbmcpKSB7XG4gICAgICAgIGlmIChwcmV2TWF0Y2ggPT09IG51bGwgfHwgZ2V0TW9kZShwcmV2U2libGluZykgIT09IDApIHtcbiAgICAgICAgICAkcmVwbGFjZVdpdGhTaW1wbGVUZXh0KHByZXZTaWJsaW5nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZGlmZiA9IHByZXZNYXRjaC5lbmQgLSBwcmV2aW91c1RleHQubGVuZ3RoO1xuICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY29uY2F0VGV4dCA9IHRleHQuc2xpY2UoMCwgZGlmZik7XG4gICAgICAgICAgICBjb25zdCBuZXdUZXh0Q29udGVudCA9IHByZXZpb3VzVGV4dCArIGNvbmNhdFRleHQ7XG4gICAgICAgICAgICBwcmV2U2libGluZy5zZWxlY3QoKTtcbiAgICAgICAgICAgIHByZXZTaWJsaW5nLnNldFRleHRDb250ZW50KG5ld1RleHRDb250ZW50KTtcbiAgICAgICAgICAgIGlmIChkaWZmID09PSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nVGV4dCA9IHRleHQuc2xpY2UoZGlmZik7XG4gICAgICAgICAgICAgIG5vZGUuc2V0VGV4dENvbnRlbnQocmVtYWluaW5nVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZXZNYXRjaCA9PT0gbnVsbCB8fCBwcmV2TWF0Y2guc3RhcnQgPCBwcmV2aW91c1RleHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHByZXZNYXRjaExlbmd0aFRvU2tpcCA9IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBtYXRjaCA9IGdldE1hdGNoKHRleHQpO1xuICAgICAgbGV0IG5leHRUZXh0ID0gbWF0Y2ggPT09IG51bGwgPyAnJyA6IHRleHQuc2xpY2UobWF0Y2guZW5kKTtcbiAgICAgIHRleHQgPSBuZXh0VGV4dDtcbiAgICAgIGlmIChuZXh0VGV4dCA9PT0gJycpIHtcbiAgICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSBjdXJyZW50Tm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICBpZiAoJGlzVGV4dE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgbmV4dFRleHQgPSBjdXJyZW50Tm9kZS5nZXRUZXh0Q29udGVudCgpICsgbmV4dFNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgICBjb25zdCBuZXh0TWF0Y2ggPSBnZXRNYXRjaChuZXh0VGV4dCk7XG4gICAgICAgICAgaWYgKG5leHRNYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlzVGFyZ2V0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgICAgICAgICAgJHJlcGxhY2VXaXRoU2ltcGxlVGV4dChuZXh0U2libGluZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXh0U2libGluZy5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5leHRNYXRjaC5zdGFydCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaC5zdGFydCA9PT0gMCAmJiAkaXNUZXh0Tm9kZShwcmV2U2libGluZykgJiYgcHJldlNpYmxpbmcuaXNUZXh0RW50aXR5KCkpIHtcbiAgICAgICAgcHJldk1hdGNoTGVuZ3RoVG9Ta2lwICs9IG1hdGNoLmVuZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgbm9kZVRvUmVwbGFjZTtcbiAgICAgIGlmIChtYXRjaC5zdGFydCA9PT0gMCkge1xuICAgICAgICBbbm9kZVRvUmVwbGFjZSwgY3VycmVudE5vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KG1hdGNoLmVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbLCBub2RlVG9SZXBsYWNlLCBjdXJyZW50Tm9kZV0gPSBjdXJyZW50Tm9kZS5zcGxpdFRleHQobWF0Y2guc3RhcnQgKyBwcmV2TWF0Y2hMZW5ndGhUb1NraXAsIG1hdGNoLmVuZCArIHByZXZNYXRjaExlbmd0aFRvU2tpcCk7XG4gICAgICB9XG4gICAgICBpZiAoIShub2RlVG9SZXBsYWNlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGAkeydub2RlVG9SZXBsYWNlJ30gc2hvdWxkIG5vdCBiZSB1bmRlZmluZWQuIFlvdSBtYXkgd2FudCB0byBjaGVjayBzcGxpdE9mZnNldHMgcGFzc2VkIHRvIHRoZSBzcGxpdFRleHQuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXBsYWNlbWVudE5vZGUgPSBjcmVhdGVOb2RlKG5vZGVUb1JlcGxhY2UpO1xuICAgICAgcmVwbGFjZW1lbnROb2RlLnNldEZvcm1hdChub2RlVG9SZXBsYWNlLmdldEZvcm1hdCgpKTtcbiAgICAgIG5vZGVUb1JlcGxhY2UucmVwbGFjZShyZXBsYWNlbWVudE5vZGUpO1xuICAgICAgaWYgKGN1cnJlbnROb2RlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHJldk1hdGNoTGVuZ3RoVG9Ta2lwID0gMDtcbiAgICAgIHByZXZTaWJsaW5nID0gcmVwbGFjZW1lbnROb2RlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgJHJldmVyc2VOb2RlVHJhbnNmb3JtID0gbm9kZSA9PiB7XG4gICAgY29uc3QgdGV4dCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBjb25zdCBtYXRjaCA9IGdldE1hdGNoKHRleHQpO1xuICAgIGlmIChtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaC5zdGFydCAhPT0gMCkge1xuICAgICAgJHJlcGxhY2VXaXRoU2ltcGxlVGV4dChub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRleHQubGVuZ3RoID4gbWF0Y2guZW5kKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgc3BsaXQgb3V0IHRoZSByZXN0IG9mIHRoZSB0ZXh0IGFzIHNpbXBsZSB0ZXh0XG4gICAgICBub2RlLnNwbGl0VGV4dChtYXRjaC5lbmQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmV2U2libGluZyA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgaWYgKCRpc1RleHROb2RlKHByZXZTaWJsaW5nKSAmJiBwcmV2U2libGluZy5pc1RleHRFbnRpdHkoKSkge1xuICAgICAgJHJlcGxhY2VXaXRoU2ltcGxlVGV4dChwcmV2U2libGluZyk7XG4gICAgICAkcmVwbGFjZVdpdGhTaW1wbGVUZXh0KG5vZGUpO1xuICAgIH1cbiAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICBpZiAoJGlzVGV4dE5vZGUobmV4dFNpYmxpbmcpICYmIG5leHRTaWJsaW5nLmlzVGV4dEVudGl0eSgpKSB7XG4gICAgICAkcmVwbGFjZVdpdGhTaW1wbGVUZXh0KG5leHRTaWJsaW5nKTtcblxuICAgICAgLy8gVGhpcyBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY29udmVydGVkIGluIHRoZSBwcmV2aW91cyBibG9ja1xuICAgICAgaWYgKGlzVGFyZ2V0Tm9kZShub2RlKSkge1xuICAgICAgICAkcmVwbGFjZVdpdGhTaW1wbGVUZXh0KG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlUGxhaW5UZXh0VHJhbnNmb3JtID0gZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybShUZXh0Tm9kZSwgJHRleHROb2RlVHJhbnNmb3JtKTtcbiAgY29uc3QgcmVtb3ZlUmV2ZXJzZU5vZGVUcmFuc2Zvcm0gPSBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKHRhcmdldE5vZGUsICRyZXZlcnNlTm9kZVRyYW5zZm9ybSk7XG4gIHJldHVybiBbcmVtb3ZlUGxhaW5UZXh0VHJhbnNmb3JtLCByZW1vdmVSZXZlcnNlTm9kZVRyYW5zZm9ybV07XG59XG5cbmV4cG9ydCB7ICRjYW5TaG93UGxhY2Vob2xkZXIsICRjYW5TaG93UGxhY2Vob2xkZXJDdXJyeSwgJGZpbmRUZXh0SW50ZXJzZWN0aW9uRnJvbUNoYXJhY3RlcnMsICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5LCAkaXNSb290VGV4dENvbnRlbnRFbXB0eUN1cnJ5LCAkcm9vdFRleHRDb250ZW50LCByZWdpc3RlckxleGljYWxUZXh0RW50aXR5IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/text/LexicalText.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@lexical/utils/LexicalUtils.dev.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $dfs: () => (/* binding */ $dfs),\n/* harmony export */   $filter: () => (/* binding */ $filter),\n/* harmony export */   $findMatchingParent: () => (/* binding */ $findMatchingParent),\n/* harmony export */   $getNearestBlockElementAncestorOrThrow: () => (/* binding */ $getNearestBlockElementAncestorOrThrow),\n/* harmony export */   $getNearestNodeOfType: () => (/* binding */ $getNearestNodeOfType),\n/* harmony export */   $getNextRightPreorderNode: () => (/* binding */ $getNextRightPreorderNode),\n/* harmony export */   $insertFirst: () => (/* binding */ $insertFirst),\n/* harmony export */   $insertNodeToNearestRoot: () => (/* binding */ $insertNodeToNearestRoot),\n/* harmony export */   $isEditorIsNestedEditor: () => (/* binding */ $isEditorIsNestedEditor),\n/* harmony export */   $restoreEditorState: () => (/* binding */ $restoreEditorState),\n/* harmony export */   $splitNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode),\n/* harmony export */   $wrapNodeInElement: () => (/* binding */ $wrapNodeInElement),\n/* harmony export */   CAN_USE_BEFORE_INPUT: () => (/* binding */ CAN_USE_BEFORE_INPUT),\n/* harmony export */   CAN_USE_DOM: () => (/* binding */ CAN_USE_DOM),\n/* harmony export */   IS_ANDROID: () => (/* binding */ IS_ANDROID),\n/* harmony export */   IS_ANDROID_CHROME: () => (/* binding */ IS_ANDROID_CHROME),\n/* harmony export */   IS_APPLE: () => (/* binding */ IS_APPLE),\n/* harmony export */   IS_APPLE_WEBKIT: () => (/* binding */ IS_APPLE_WEBKIT),\n/* harmony export */   IS_CHROME: () => (/* binding */ IS_CHROME),\n/* harmony export */   IS_FIREFOX: () => (/* binding */ IS_FIREFOX),\n/* harmony export */   IS_IOS: () => (/* binding */ IS_IOS),\n/* harmony export */   IS_SAFARI: () => (/* binding */ IS_SAFARI),\n/* harmony export */   addClassNamesToElement: () => (/* binding */ addClassNamesToElement),\n/* harmony export */   calculateZoomLevel: () => (/* binding */ calculateZoomLevel),\n/* harmony export */   isBlockDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode),\n/* harmony export */   isHTMLAnchorElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement),\n/* harmony export */   isHTMLElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement),\n/* harmony export */   isInlineDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode),\n/* harmony export */   isMimeType: () => (/* binding */ isMimeType),\n/* harmony export */   markSelection: () => (/* binding */ markSelection),\n/* harmony export */   mediaFileReader: () => (/* binding */ mediaFileReader),\n/* harmony export */   mergeRegister: () => (/* binding */ mergeRegister),\n/* harmony export */   objectKlassEquals: () => (/* binding */ objectKlassEquals),\n/* harmony export */   positionNodeOnRange: () => (/* binding */ positionNodeOnRange),\n/* harmony export */   registerNestedElementResolver: () => (/* binding */ registerNestedElementResolver),\n/* harmony export */   removeClassNamesFromElement: () => (/* binding */ removeClassNamesFromElement)\n/* harmony export */ });\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction positionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: rootLeft,\n      top: rootTop\n    } = rootDOMNode.getBoundingClientRect();\n    const parentDOMNode_ = parentDOMNode;\n    const rects = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.createRectsFromDOMRange)(editor, range);\n    if (!wrapperNode.isConnected) {\n      parentDOMNode_.append(wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - rootLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - rootTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(currentParentDOMNode instanceof HTMLElement)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));\n      if (differentAnchorDOM || differentFocusDOM) {\n        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());\n        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());\n        // TODO handle selection beyond the common TextNode\n        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === 'SPAN' && focusHTMLElement.tagName === 'SPAN') {\n          const range = document.createRange();\n          let firstHTMLElement;\n          let firstOffset;\n          let lastHTMLElement;\n          let lastOffset;\n          if (focus.isBefore(anchor)) {\n            firstHTMLElement = focusHTMLElement;\n            firstOffset = focus.offset;\n            lastHTMLElement = anchorHTMLElement;\n            lastOffset = anchor.offset;\n          } else {\n            firstHTMLElement = anchorHTMLElement;\n            firstOffset = anchor.offset;\n            lastHTMLElement = focusHTMLElement;\n            lastOffset = focus.offset;\n          }\n          const firstTextNode = firstHTMLElement.firstChild;\n          if (!(firstTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          const lastTextNode = lastHTMLElement.firstChild;\n          if (!(lastTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          range.setStart(firstTextNode, firstOffset);\n          range.setEnd(lastTextNode, lastOffset);\n          removeRangeListener();\n          removeRangeListener = positionNodeOnRange(editor, range, domNodes => {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.zIndex !== '-1') {\n                domNodeStyle.zIndex = '-1';\n              }\n              if (domNodeStyle.pointerEvents !== 'none') {\n                domNodeStyle.pointerEvents = 'none';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n            if (onReposition !== undefined) {\n              onReposition(domNodes);\n            }\n          });\n        }\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), removeRangeListener, () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the ending node) so long as it exists\n */\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)()).getLatest();\n  const end = endingNode || ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(start) ? start.getLastDescendant() || start : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to paret and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  let node = startingNode;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() > 0) {\n    node = node.getLastChild();\n  } else {\n    let sibling = null;\n    while (sibling === null && node !== null) {\n      sibling = node.getPreviousSibling();\n      if (sibling === null) {\n        node = node.getParent();\n      } else {\n        node = sibling;\n      }\n    }\n  }\n  return node;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.$cloneWithProperties)(node);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone)) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n        throw Error(`Expected node be a TextNode`);\n      }\n      clone.__text = node.__text;\n    }\n    nodeMap.set(key, clone);\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode)(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n      root.append(node);\n    }\n    const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  if (IS_FIREFOX) {\n    return 1;\n  }\n  let zoom = 1;\n  while (element) {\n    zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n    element = element.parentElement;\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdXRpbHMvTGV4aWNhbFV0aWxzLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUY7QUFDc0g7QUFDL0Y7O0FBRTFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGtCQUFrQiwyRUFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFhO0FBQ3JDLFdBQVcsMERBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc1JBQXNSLDZDQUFRO0FBQzlSLDRRQUE0USw2Q0FBUTtBQUNwUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9DQUFvQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxpQ0FB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb2tCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl2ZWRvY3MvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdXRpbHMvTGV4aWNhbFV0aWxzLmRldi5tanM/YjlmMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlLCAkY2xvbmVXaXRoUHJvcGVydGllcyB9IGZyb20gJ0BsZXhpY2FsL3NlbGVjdGlvbic7XG5pbXBvcnQgeyAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgVGV4dE5vZGUsICRnZXRSb290LCAkaXNFbGVtZW50Tm9kZSwgJGlzVGV4dE5vZGUsICRzZXRTZWxlY3Rpb24sICRnZXRQcmV2aW91c1NlbGVjdGlvbiwgJGlzUm9vdE9yU2hhZG93Um9vdCwgJHNwbGl0Tm9kZSwgJGNyZWF0ZVBhcmFncmFwaE5vZGUgfSBmcm9tICdsZXhpY2FsJztcbmV4cG9ydCB7ICRzcGxpdE5vZGUsIGlzQmxvY2tEb21Ob2RlLCBpc0hUTUxBbmNob3JFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc0lubGluZURvbU5vZGUgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSQxID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBkb2N1bWVudE1vZGUgPSBDQU5fVVNFX0RPTSQxICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogbnVsbDtcbmNvbnN0IElTX0FQUExFJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfRklSRUZPWCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBDQU5fVVNFX0JFRk9SRV9JTlBVVCQxID0gQ0FOX1VTRV9ET00kMSAmJiAnSW5wdXRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgPyAnZ2V0VGFyZ2V0UmFuZ2VzJyBpbiBuZXcgd2luZG93LklucHV0RXZlbnQoJ2lucHV0JykgOiBmYWxzZTtcbmNvbnN0IElTX1NBRkFSSSQxID0gQ0FOX1VTRV9ET00kMSAmJiAvVmVyc2lvblxcL1tcXGQuXSsuKlNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IElTX0lPUyQxID0gQ0FOX1VTRV9ET00kMSAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xuY29uc3QgSVNfQU5EUk9JRCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvQW5kcm9pZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLy8gS2VlcCB0aGVzZSBpbiBjYXNlIHdlIG5lZWQgdG8gdXNlIHRoZW0gaW4gdGhlIGZ1dHVyZS5cbi8vIGV4cG9ydCBjb25zdCBJU19XSU5ET1dTOiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgL1dpbi8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfQ0hST01FJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9eKD89LipDaHJvbWUpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gZXhwb3J0IGNvbnN0IGNhblVzZVRleHRJbnB1dEV2ZW50OiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbmNvbnN0IElTX0FORFJPSURfQ0hST01FJDEgPSBDQU5fVVNFX0RPTSQxICYmIElTX0FORFJPSUQkMSAmJiBJU19DSFJPTUUkMTtcbmNvbnN0IElTX0FQUExFX1dFQktJVCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvQXBwbGVXZWJLaXRcXC9bXFxkLl0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFJU19DSFJPTUUkMTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc05hbWVzKC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgcnZhbCA9IFtdO1xuICBmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG4gICAgaWYgKGNsYXNzTmFtZSAmJiB0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZm9yIChjb25zdCBbc10gb2YgY2xhc3NOYW1lLm1hdGNoQWxsKC9cXFMrL2cpKSB7XG4gICAgICAgIHJ2YWwucHVzaChzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgYWxsIGZ1bmN0aW9ucyBwYXNzZWQgd2hlbiBjYWxsZWQuIEl0IGlzIGdlbmVyYWxseSB1c2VkXG4gKiB0byByZWdpc3RlciBtdWx0aXBsZSBsZXhpY2FsIGxpc3RlbmVycyBhbmQgdGhlbiB0ZWFyIHRoZW0gZG93biB3aXRoIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGwsIHN1Y2hcbiAqIGFzIFJlYWN0J3MgdXNlRWZmZWN0IGhvb2suXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKFxuICogICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoLi4ucmVnaXN0ZXJDb21tYW5kMSBsb2dpYyksXG4gKiAgICAgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZCguLi5yZWdpc3RlckNvbW1hbmQyIGxvZ2ljKSxcbiAqICAgICBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKC4uLnJlZ2lzdGVyQ29tbWFuZDMgbG9naWMpXG4gKiAgIClcbiAqIH0sIFtlZGl0b3JdKVxuICogYGBgXG4gKiBJbiB0aGlzIGNhc2UsIHVzZUVmZmVjdCBpcyByZXR1cm5pbmcgdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IG1lcmdlUmVnaXN0ZXIgYXMgYSBjbGVhbnVwXG4gKiBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBlaXRoZXIgdGhlIHVzZUVmZmVjdCBydW5zIGFnYWluIChkdWUgdG8gb25lIG9mIGl0cyBkZXBlbmRlbmNpZXNcbiAqIHVwZGF0aW5nKSBvciB0aGUgY29tcG9uZW50IGl0IHJlc2lkZXMgaW4gdW5tb3VudHMuXG4gKiBOb3RlIHRoZSBmdW5jdGlvbnMgZG9uJ3QgbmVjY2VzYXJpbHkgbmVlZCB0byBiZSBpbiBhbiBhcnJheSBhcyBhbGwgYXJndW1lbnRzXG4gKiBhcmUgY29uc2lkZXJlZCB0byBiZSB0aGUgZnVuYyBhcmd1bWVudCBhbmQgc3ByZWFkIGZyb20gdGhlcmUuXG4gKiBUaGUgb3JkZXIgb2YgY2xlYW51cCBpcyB0aGUgcmV2ZXJzZSBvZiB0aGUgYXJndW1lbnQgb3JkZXIuIEdlbmVyYWxseSBpdCBpc1xuICogZXhwZWN0ZWQgdGhhdCB0aGUgZmlyc3QgXCJhY3F1aXJlXCIgd2lsbCBiZSBcInJlbGVhc2VkXCIgbGFzdCAoTElGTyBvcmRlciksXG4gKiBiZWNhdXNlIGEgbGF0ZXIgc3RlcCBtYXkgaGF2ZSBzb21lIGRlcGVuZGVuY3kgb24gYW4gZWFybGllciBvbmUuXG4gKiBAcGFyYW0gZnVuYyAtIEFuIGFycmF5IG9mIGNsZWFudXAgZnVuY3Rpb25zIG1lYW50IHRvIGJlIGV4ZWN1dGVkIGJ5IHRoZSByZXR1cm5lZCBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHRoZSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBhbGwgdGhlIHBhc3NlZCBjbGVhbnVwIGZ1bmN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VSZWdpc3RlciguLi5mdW5jKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IGZ1bmMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGZ1bmNbaV0oKTtcbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgdGhlIHJlZmVyZW5jZXMgYW5kIG1ha2UgZnV0dXJlIGNhbGxzIGEgbm8tb3BcbiAgICBmdW5jLmxlbmd0aCA9IDA7XG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcHgodmFsdWUpIHtcbiAgcmV0dXJuIGAke3ZhbHVlfXB4YDtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBtdXRhdGlvbk9ic2VydmVyQ29uZmlnID0ge1xuICBhdHRyaWJ1dGVzOiB0cnVlLFxuICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICBjaGlsZExpc3Q6IHRydWUsXG4gIHN1YnRyZWU6IHRydWVcbn07XG5mdW5jdGlvbiBwb3NpdGlvbk5vZGVPblJhbmdlKGVkaXRvciwgcmFuZ2UsIG9uUmVwb3NpdGlvbikge1xuICBsZXQgcm9vdERPTU5vZGUgPSBudWxsO1xuICBsZXQgcGFyZW50RE9NTm9kZSA9IG51bGw7XG4gIGxldCBvYnNlcnZlciA9IG51bGw7XG4gIGxldCBsYXN0Tm9kZXMgPSBbXTtcbiAgY29uc3Qgd3JhcHBlck5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZnVuY3Rpb24gcG9zaXRpb24oKSB7XG4gICAgaWYgKCEocm9vdERPTU5vZGUgIT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgVW5leHBlY3RlZCBudWxsIHJvb3RET01Ob2RlYCk7XG4gICAgfVxuICAgIGlmICghKHBhcmVudERPTU5vZGUgIT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgVW5leHBlY3RlZCBudWxsIHBhcmVudERPTU5vZGVgKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbGVmdDogcm9vdExlZnQsXG4gICAgICB0b3A6IHJvb3RUb3BcbiAgICB9ID0gcm9vdERPTU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgcGFyZW50RE9NTm9kZV8gPSBwYXJlbnRET01Ob2RlO1xuICAgIGNvbnN0IHJlY3RzID0gY3JlYXRlUmVjdHNGcm9tRE9NUmFuZ2UoZWRpdG9yLCByYW5nZSk7XG4gICAgaWYgKCF3cmFwcGVyTm9kZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgcGFyZW50RE9NTm9kZV8uYXBwZW5kKHdyYXBwZXJOb2RlKTtcbiAgICB9XG4gICAgbGV0IGhhc1JlcG9zaXRpb25lZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgIC8vIFRyeSB0byByZXVzZSB0aGUgcHJldmlvdXNseSBjcmVhdGVkIE5vZGUgd2hlbiBwb3NzaWJsZSwgbm8gbmVlZCB0b1xuICAgICAgLy8gcmVtb3ZlL2NyZWF0ZSBvbiB0aGUgbW9zdCBjb21tb24gY2FzZSByZXBvc2l0aW9uIGNhc2VcbiAgICAgIGNvbnN0IHJlY3ROb2RlID0gbGFzdE5vZGVzW2ldIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29uc3QgcmVjdE5vZGVTdHlsZSA9IHJlY3ROb2RlLnN0eWxlO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgcmVjdE5vZGVTdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBsZWZ0ID0gcHgocmVjdC5sZWZ0IC0gcm9vdExlZnQpO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUubGVmdCAhPT0gbGVmdCkge1xuICAgICAgICByZWN0Tm9kZVN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9wID0gcHgocmVjdC50b3AgLSByb290VG9wKTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLnRvcCAhPT0gdG9wKSB7XG4gICAgICAgIHJlY3ROb2RlLnN0eWxlLnRvcCA9IHRvcDtcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdpZHRoID0gcHgocmVjdC53aWR0aCk7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS53aWR0aCAhPT0gd2lkdGgpIHtcbiAgICAgICAgcmVjdE5vZGUuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhlaWdodCA9IHB4KHJlY3QuaGVpZ2h0KTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgIHJlY3ROb2RlLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWN0Tm9kZS5wYXJlbnROb2RlICE9PSB3cmFwcGVyTm9kZSkge1xuICAgICAgICB3cmFwcGVyTm9kZS5hcHBlbmQocmVjdE5vZGUpO1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbGFzdE5vZGVzW2ldID0gcmVjdE5vZGU7XG4gICAgfVxuICAgIHdoaWxlIChsYXN0Tm9kZXMubGVuZ3RoID4gcmVjdHMubGVuZ3RoKSB7XG4gICAgICBsYXN0Tm9kZXMucG9wKCk7XG4gICAgfVxuICAgIGlmIChoYXNSZXBvc2l0aW9uZWQpIHtcbiAgICAgIG9uUmVwb3NpdGlvbihsYXN0Tm9kZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHBhcmVudERPTU5vZGUgPSBudWxsO1xuICAgIHJvb3RET01Ob2RlID0gbnVsbDtcbiAgICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgb2JzZXJ2ZXIgPSBudWxsO1xuICAgIHdyYXBwZXJOb2RlLnJlbW92ZSgpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBsYXN0Tm9kZXMpIHtcbiAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgfVxuICAgIGxhc3ROb2RlcyA9IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHJlc3RhcnQoKSB7XG4gICAgY29uc3QgY3VycmVudFJvb3RET01Ob2RlID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gICAgaWYgKGN1cnJlbnRSb290RE9NTm9kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFBhcmVudERPTU5vZGUgPSBjdXJyZW50Um9vdERPTU5vZGUucGFyZW50RWxlbWVudDtcbiAgICBpZiAoIShjdXJyZW50UGFyZW50RE9NTm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICB9XG4gICAgc3RvcCgpO1xuICAgIHJvb3RET01Ob2RlID0gY3VycmVudFJvb3RET01Ob2RlO1xuICAgIHBhcmVudERPTU5vZGUgPSBjdXJyZW50UGFyZW50RE9NTm9kZTtcbiAgICBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICBjb25zdCBuZXh0Um9vdERPTU5vZGUgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICAgIGNvbnN0IG5leHRQYXJlbnRET01Ob2RlID0gbmV4dFJvb3RET01Ob2RlICYmIG5leHRSb290RE9NTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgaWYgKG5leHRSb290RE9NTm9kZSAhPT0gcm9vdERPTU5vZGUgfHwgbmV4dFBhcmVudERPTU5vZGUgIT09IHBhcmVudERPTU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIGlmICghd3JhcHBlck5vZGUuY29udGFpbnMobXV0YXRpb24udGFyZ2V0KSkge1xuICAgICAgICAgIC8vIFRPRE8gdGhyb3R0bGVcbiAgICAgICAgICByZXR1cm4gcG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoY3VycmVudFBhcmVudERPTU5vZGUsIG11dGF0aW9uT2JzZXJ2ZXJDb25maWcpO1xuICAgIHBvc2l0aW9uKCk7XG4gIH1cbiAgY29uc3QgcmVtb3ZlUm9vdExpc3RlbmVyID0gZWRpdG9yLnJlZ2lzdGVyUm9vdExpc3RlbmVyKHJlc3RhcnQpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHJlbW92ZVJvb3RMaXN0ZW5lcigpO1xuICAgIHN0b3AoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBtYXJrU2VsZWN0aW9uKGVkaXRvciwgb25SZXBvc2l0aW9uKSB7XG4gIGxldCBwcmV2aW91c0FuY2hvck5vZGUgPSBudWxsO1xuICBsZXQgcHJldmlvdXNBbmNob3JPZmZzZXQgPSBudWxsO1xuICBsZXQgcHJldmlvdXNGb2N1c05vZGUgPSBudWxsO1xuICBsZXQgcHJldmlvdXNGb2N1c09mZnNldCA9IG51bGw7XG4gIGxldCByZW1vdmVSYW5nZUxpc3RlbmVyID0gKCkgPT4ge307XG4gIGZ1bmN0aW9uIGNvbXB1dGUoZWRpdG9yU3RhdGUpIHtcbiAgICBlZGl0b3JTdGF0ZS5yZWFkKCgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHByZXZpb3VzQW5jaG9yTm9kZSA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzQW5jaG9yT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXNGb2N1c05vZGUgPSBudWxsO1xuICAgICAgICBwcmV2aW91c0ZvY3VzT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgcmVtb3ZlUmFuZ2VMaXN0ZW5lcigpO1xuICAgICAgICByZW1vdmVSYW5nZUxpc3RlbmVyID0gKCkgPT4ge307XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBmb2N1c1xuICAgICAgfSA9IHNlbGVjdGlvbjtcbiAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3JOb2RlS2V5ID0gY3VycmVudEFuY2hvck5vZGUuZ2V0S2V5KCk7XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgICAgIGNvbnN0IGN1cnJlbnRGb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgICBjb25zdCBjdXJyZW50Rm9jdXNOb2RlS2V5ID0gY3VycmVudEZvY3VzTm9kZS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRGb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3JOb2RlRE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShjdXJyZW50QW5jaG9yTm9kZUtleSk7XG4gICAgICBjb25zdCBjdXJyZW50Rm9jdXNOb2RlRE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShjdXJyZW50Rm9jdXNOb2RlS2V5KTtcbiAgICAgIGNvbnN0IGRpZmZlcmVudEFuY2hvckRPTSA9IHByZXZpb3VzQW5jaG9yTm9kZSA9PT0gbnVsbCB8fCBjdXJyZW50QW5jaG9yTm9kZURPTSA9PT0gbnVsbCB8fCBjdXJyZW50QW5jaG9yT2Zmc2V0ICE9PSBwcmV2aW91c0FuY2hvck9mZnNldCB8fCBjdXJyZW50QW5jaG9yTm9kZUtleSAhPT0gcHJldmlvdXNBbmNob3JOb2RlLmdldEtleSgpIHx8IGN1cnJlbnRBbmNob3JOb2RlICE9PSBwcmV2aW91c0FuY2hvck5vZGUgJiYgKCEocHJldmlvdXNBbmNob3JOb2RlIGluc3RhbmNlb2YgVGV4dE5vZGUpIHx8IGN1cnJlbnRBbmNob3JOb2RlLnVwZGF0ZURPTShwcmV2aW91c0FuY2hvck5vZGUsIGN1cnJlbnRBbmNob3JOb2RlRE9NLCBlZGl0b3IuX2NvbmZpZykpO1xuICAgICAgY29uc3QgZGlmZmVyZW50Rm9jdXNET00gPSBwcmV2aW91c0ZvY3VzTm9kZSA9PT0gbnVsbCB8fCBjdXJyZW50Rm9jdXNOb2RlRE9NID09PSBudWxsIHx8IGN1cnJlbnRGb2N1c09mZnNldCAhPT0gcHJldmlvdXNGb2N1c09mZnNldCB8fCBjdXJyZW50Rm9jdXNOb2RlS2V5ICE9PSBwcmV2aW91c0ZvY3VzTm9kZS5nZXRLZXkoKSB8fCBjdXJyZW50Rm9jdXNOb2RlICE9PSBwcmV2aW91c0ZvY3VzTm9kZSAmJiAoIShwcmV2aW91c0ZvY3VzTm9kZSBpbnN0YW5jZW9mIFRleHROb2RlKSB8fCBjdXJyZW50Rm9jdXNOb2RlLnVwZGF0ZURPTShwcmV2aW91c0ZvY3VzTm9kZSwgY3VycmVudEZvY3VzTm9kZURPTSwgZWRpdG9yLl9jb25maWcpKTtcbiAgICAgIGlmIChkaWZmZXJlbnRBbmNob3JET00gfHwgZGlmZmVyZW50Rm9jdXNET00pIHtcbiAgICAgICAgY29uc3QgYW5jaG9ySFRNTEVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGFuY2hvci5nZXROb2RlKCkuZ2V0S2V5KCkpO1xuICAgICAgICBjb25zdCBmb2N1c0hUTUxFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShmb2N1cy5nZXROb2RlKCkuZ2V0S2V5KCkpO1xuICAgICAgICAvLyBUT0RPIGhhbmRsZSBzZWxlY3Rpb24gYmV5b25kIHRoZSBjb21tb24gVGV4dE5vZGVcbiAgICAgICAgaWYgKGFuY2hvckhUTUxFbGVtZW50ICE9PSBudWxsICYmIGZvY3VzSFRNTEVsZW1lbnQgIT09IG51bGwgJiYgYW5jaG9ySFRNTEVsZW1lbnQudGFnTmFtZSA9PT0gJ1NQQU4nICYmIGZvY3VzSFRNTEVsZW1lbnQudGFnTmFtZSA9PT0gJ1NQQU4nKSB7XG4gICAgICAgICAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgIGxldCBmaXJzdEhUTUxFbGVtZW50O1xuICAgICAgICAgIGxldCBmaXJzdE9mZnNldDtcbiAgICAgICAgICBsZXQgbGFzdEhUTUxFbGVtZW50O1xuICAgICAgICAgIGxldCBsYXN0T2Zmc2V0O1xuICAgICAgICAgIGlmIChmb2N1cy5pc0JlZm9yZShhbmNob3IpKSB7XG4gICAgICAgICAgICBmaXJzdEhUTUxFbGVtZW50ID0gZm9jdXNIVE1MRWxlbWVudDtcbiAgICAgICAgICAgIGZpcnN0T2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICAgICAgICAgICAgbGFzdEhUTUxFbGVtZW50ID0gYW5jaG9ySFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICBsYXN0T2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlyc3RIVE1MRWxlbWVudCA9IGFuY2hvckhUTUxFbGVtZW50O1xuICAgICAgICAgICAgZmlyc3RPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgICAgICAgICAgbGFzdEhUTUxFbGVtZW50ID0gZm9jdXNIVE1MRWxlbWVudDtcbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZpcnN0VGV4dE5vZGUgPSBmaXJzdEhUTUxFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgaWYgKCEoZmlyc3RUZXh0Tm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB0ZXh0IG5vZGUgdG8gYmUgZmlyc3QgY2hpbGQgb2Ygc3BhbmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBsYXN0VGV4dE5vZGUgPSBsYXN0SFRNTEVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICBpZiAoIShsYXN0VGV4dE5vZGUgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdGV4dCBub2RlIHRvIGJlIGZpcnN0IGNoaWxkIG9mIHNwYW5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoZmlyc3RUZXh0Tm9kZSwgZmlyc3RPZmZzZXQpO1xuICAgICAgICAgIHJhbmdlLnNldEVuZChsYXN0VGV4dE5vZGUsIGxhc3RPZmZzZXQpO1xuICAgICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIoKTtcbiAgICAgICAgICByZW1vdmVSYW5nZUxpc3RlbmVyID0gcG9zaXRpb25Ob2RlT25SYW5nZShlZGl0b3IsIHJhbmdlLCBkb21Ob2RlcyA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRvbU5vZGUgb2YgZG9tTm9kZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgZG9tTm9kZVN0eWxlID0gZG9tTm9kZS5zdHlsZTtcbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS5iYWNrZ3JvdW5kICE9PSAnSGlnaGxpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGRvbU5vZGVTdHlsZS5iYWNrZ3JvdW5kID0gJ0hpZ2hsaWdodCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS5jb2xvciAhPT0gJ0hpZ2hsaWdodFRleHQnKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLmNvbG9yID0gJ0hpZ2hsaWdodFRleHQnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUuekluZGV4ICE9PSAnLTEnKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLnpJbmRleCA9ICctMSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS5wb2ludGVyRXZlbnRzICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLm1hcmdpblRvcCAhPT0gcHgoLTEuNSkpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUubWFyZ2luVG9wID0gcHgoLTEuNSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS5wYWRkaW5nVG9wICE9PSBweCg0KSkge1xuICAgICAgICAgICAgICAgIGRvbU5vZGVTdHlsZS5wYWRkaW5nVG9wID0gcHgoNCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS5wYWRkaW5nQm90dG9tICE9PSBweCgwKSkge1xuICAgICAgICAgICAgICAgIGRvbU5vZGVTdHlsZS5wYWRkaW5nQm90dG9tID0gcHgoMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblJlcG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBvblJlcG9zaXRpb24oZG9tTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcmV2aW91c0FuY2hvck5vZGUgPSBjdXJyZW50QW5jaG9yTm9kZTtcbiAgICAgIHByZXZpb3VzQW5jaG9yT2Zmc2V0ID0gY3VycmVudEFuY2hvck9mZnNldDtcbiAgICAgIHByZXZpb3VzRm9jdXNOb2RlID0gY3VycmVudEZvY3VzTm9kZTtcbiAgICAgIHByZXZpb3VzRm9jdXNPZmZzZXQgPSBjdXJyZW50Rm9jdXNPZmZzZXQ7XG4gICAgfSk7XG4gIH1cbiAgY29tcHV0ZShlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKSk7XG4gIHJldHVybiBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKCh7XG4gICAgZWRpdG9yU3RhdGVcbiAgfSkgPT4gY29tcHV0ZShlZGl0b3JTdGF0ZSkpLCByZW1vdmVSYW5nZUxpc3RlbmVyLCAoKSA9PiB7XG4gICAgcmVtb3ZlUmFuZ2VMaXN0ZW5lcigpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vLyBIb3RmaXggdG8gZXhwb3J0IHRoZXNlIHdpdGggaW5saW5lZCB0eXBlcyAjNTkxOFxuY29uc3QgQ0FOX1VTRV9CRUZPUkVfSU5QVVQgPSBDQU5fVVNFX0JFRk9SRV9JTlBVVCQxO1xuY29uc3QgQ0FOX1VTRV9ET00gPSBDQU5fVVNFX0RPTSQxO1xuY29uc3QgSVNfQU5EUk9JRCA9IElTX0FORFJPSUQkMTtcbmNvbnN0IElTX0FORFJPSURfQ0hST01FID0gSVNfQU5EUk9JRF9DSFJPTUUkMTtcbmNvbnN0IElTX0FQUExFID0gSVNfQVBQTEUkMTtcbmNvbnN0IElTX0FQUExFX1dFQktJVCA9IElTX0FQUExFX1dFQktJVCQxO1xuY29uc3QgSVNfQ0hST01FID0gSVNfQ0hST01FJDE7XG5jb25zdCBJU19GSVJFRk9YID0gSVNfRklSRUZPWCQxO1xuY29uc3QgSVNfSU9TID0gSVNfSU9TJDE7XG5jb25zdCBJU19TQUZBUkkgPSBJU19TQUZBUkkkMTtcbi8qKlxuICogVGFrZXMgYW4gSFRNTCBlbGVtZW50IGFuZCBhZGRzIHRoZSBjbGFzc05hbWVzIHBhc3NlZCB3aXRoaW4gYW4gYXJyYXksXG4gKiBpZ25vcmluZyBhbnkgbm9uLXN0cmluZyB0eXBlcy4gQSBzcGFjZSBjYW4gYmUgdXNlZCB0byBhZGQgbXVsdGlwbGUgY2xhc3Nlc1xuICogZWcuIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgWydlbGVtZW50LWlubmVyIGFjdGl2ZScsIHRydWUsIG51bGxdKVxuICogd2lsbCBhZGQgYm90aCAnZWxlbWVudC1pbm5lcicgYW5kICdhY3RpdmUnIGFzIGNsYXNzZXMgdG8gdGhhdCBlbGVtZW50LlxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCBpbiB3aGljaCB0aGUgY2xhc3NlcyBhcmUgYWRkZWRcbiAqIEBwYXJhbSBjbGFzc05hbWVzIC0gQW4gYXJyYXkgZGVmaW5pbmcgdGhlIGNsYXNzIG5hbWVzIHRvIGFkZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgY2xhc3Nlc1RvQWRkID0gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKTtcbiAgaWYgKGNsYXNzZXNUb0FkZC5sZW5ndGggPiAwKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXNUb0FkZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyBhbiBIVE1MIGVsZW1lbnQgYW5kIHJlbW92ZXMgdGhlIGNsYXNzTmFtZXMgcGFzc2VkIHdpdGhpbiBhbiBhcnJheSxcbiAqIGlnbm9yaW5nIGFueSBub24tc3RyaW5nIHR5cGVzLiBBIHNwYWNlIGNhbiBiZSB1c2VkIHRvIHJlbW92ZSBtdWx0aXBsZSBjbGFzc2VzXG4gKiBlZy4gcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGVsZW1lbnQsIFsnYWN0aXZlIHNtYWxsJywgdHJ1ZSwgbnVsbF0pXG4gKiB3aWxsIHJlbW92ZSBib3RoIHRoZSAnYWN0aXZlJyBhbmQgJ3NtYWxsJyBjbGFzc2VzIGZyb20gdGhhdCBlbGVtZW50LlxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCBpbiB3aGljaCB0aGUgY2xhc3NlcyBhcmUgcmVtb3ZlZFxuICogQHBhcmFtIGNsYXNzTmFtZXMgLSBBbiBhcnJheSBkZWZpbmluZyB0aGUgY2xhc3MgbmFtZXMgdG8gcmVtb3ZlIGZyb20gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGVsZW1lbnQsIC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgY2xhc3Nlc1RvUmVtb3ZlID0gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKTtcbiAgaWYgKGNsYXNzZXNUb1JlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzZXNUb1JlbW92ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZpbGUgdHlwZSBtYXRjaGVzIHRoZSB0eXBlcyBwYXNzZWQgd2l0aGluIHRoZSBhY2NlcHRhYmxlTWltZVR5cGVzIGFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBUaGUgdHlwZXMgcGFzc2VkIG11c3QgYmUgc3RyaW5ncyBhbmQgYXJlIENBU0UtU0VOU0lUSVZFLlxuICogZWcuIGlmIGZpbGUgaXMgb2YgdHlwZSAndGV4dCcgYW5kIGFjY2VwdGFibGVNaW1lVHlwZXMgPSBbJ1RFWFQnLCAnSU1BR0UnXSB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gZmFsc2UuXG4gKiBAcGFyYW0gZmlsZSAtIFRoZSBmaWxlIHlvdSB3YW50IHRvIHR5cGUgY2hlY2suXG4gKiBAcGFyYW0gYWNjZXB0YWJsZU1pbWVUeXBlcyAtIEFuIGFycmF5IG9mIHN0cmluZ3Mgb2YgdHlwZXMgd2hpY2ggdGhlIGZpbGUgaXMgY2hlY2tlZCBhZ2FpbnN0LlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZmlsZSBpcyBhbiBhY2NlcHRhYmxlIG1pbWUgdHlwZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc01pbWVUeXBlKGZpbGUsIGFjY2VwdGFibGVNaW1lVHlwZXMpIHtcbiAgZm9yIChjb25zdCBhY2NlcHRhYmxlVHlwZSBvZiBhY2NlcHRhYmxlTWltZVR5cGVzKSB7XG4gICAgaWYgKGZpbGUudHlwZS5zdGFydHNXaXRoKGFjY2VwdGFibGVUeXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBMZXhpY2FsIEZpbGUgUmVhZGVyIHdpdGg6XG4gKiAgMS4gTUlNRSB0eXBlIHN1cHBvcnRcbiAqICAyLiBiYXRjaGVkIHJlc3VsdHMgKEhpc3RvcnlQbHVnaW4gY29tcGF0aWJpbGl0eSlcbiAqICAzLiBPcmRlciBhd2FyZSAocmVzcGVjdHMgdGhlIG9yZGVyIHdoZW4gbXVsdGlwbGUgRmlsZXMgYXJlIHBhc3NlZClcbiAqXG4gKiBjb25zdCBmaWxlc1Jlc3VsdCA9IGF3YWl0IG1lZGlhRmlsZVJlYWRlcihmaWxlcywgWydpbWFnZS8nXSk7XG4gKiBmaWxlc1Jlc3VsdC5mb3JFYWNoKGZpbGUgPT4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZCgnSU5TRVJUX0lNQUdFJywgXFxcXHtcbiAqICAgc3JjOiBmaWxlLnJlc3VsdCxcbiAqIFxcXFx9KSk7XG4gKi9cbmZ1bmN0aW9uIG1lZGlhRmlsZVJlYWRlcihmaWxlcywgYWNjZXB0YWJsZU1pbWVUeXBlcykge1xuICBjb25zdCBmaWxlc0l0ZXJhdG9yID0gZmlsZXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHByb2Nlc3NlZCA9IFtdO1xuICAgIGNvbnN0IGhhbmRsZU5leHRGaWxlID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkb25lLFxuICAgICAgICB2YWx1ZTogZmlsZVxuICAgICAgfSA9IGZpbGVzSXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUocHJvY2Vzc2VkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICBmaWxlUmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbGVSZWFkZXIucmVzdWx0O1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBwcm9jZXNzZWQucHVzaCh7XG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlTmV4dEZpbGUoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzTWltZVR5cGUoZmlsZSwgYWNjZXB0YWJsZU1pbWVUeXBlcykpIHtcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlTmV4dEZpbGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGhhbmRsZU5leHRGaWxlKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFwiRGVwdGgtRmlyc3QgU2VhcmNoXCIgc3RhcnRzIGF0IHRoZSByb290L3RvcCBub2RlIG9mIGEgdHJlZSBhbmQgZ29lcyBhcyBmYXIgYXMgaXQgY2FuIGRvd24gYSBicmFuY2ggZW5kXG4gKiBiZWZvcmUgYmFja3RyYWNraW5nIGFuZCBmaW5kaW5nIGEgbmV3IHBhdGguIENvbnNpZGVyIHNvbHZpbmcgYSBtYXplIGJ5IGh1Z2dpbmcgZWl0aGVyIHdhbGwsIG1vdmluZyBkb3duIGFcbiAqIGJyYW5jaCB1bnRpbCB5b3UgaGl0IGEgZGVhZC1lbmQgKGxlYWYpIGFuZCBiYWNrdHJhY2tpbmcgdG8gZmluZCB0aGUgbmVhcmVzdCBicmFuY2hpbmcgcGF0aCBhbmQgcmVwZWF0LlxuICogSXQgd2lsbCB0aGVuIHJldHVybiBhbGwgdGhlIG5vZGVzIGZvdW5kIGluIHRoZSBzZWFyY2ggaW4gYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAqIEBwYXJhbSBzdGFydGluZ05vZGUgLSBUaGUgbm9kZSB0byBzdGFydCB0aGUgc2VhcmNoLCBpZiBvbW1pdHRlZCwgaXQgd2lsbCBzdGFydCBhdCB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIGVuZGluZ05vZGUgLSBUaGUgbm9kZSB0byBlbmQgdGhlIHNlYXJjaCwgaWYgb21taXR0ZWQsIGl0IHdpbGwgZmluZCBhbGwgZGVzY2VuZGFudHMgb2YgdGhlIHN0YXJ0aW5nTm9kZS5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG9iamVjdHMgb2YgYWxsIHRoZSBub2RlcyBmb3VuZCBieSB0aGUgc2VhcmNoLCBpbmNsdWRpbmcgdGhlaXIgZGVwdGggaW50byB0aGUgdHJlZS5cbiAqIFxcXFx7ZGVwdGg6IG51bWJlciwgbm9kZTogTGV4aWNhbE5vZGVcXFxcfSBJdCB3aWxsIGFsd2F5cyByZXR1cm4gYXQgbGVhc3QgMSBub2RlICh0aGUgZW5kaW5nIG5vZGUpIHNvIGxvbmcgYXMgaXQgZXhpc3RzXG4gKi9cbmZ1bmN0aW9uICRkZnMoc3RhcnRpbmdOb2RlLCBlbmRpbmdOb2RlKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGNvbnN0IHN0YXJ0ID0gKHN0YXJ0aW5nTm9kZSB8fCAkZ2V0Um9vdCgpKS5nZXRMYXRlc3QoKTtcbiAgY29uc3QgZW5kID0gZW5kaW5nTm9kZSB8fCAoJGlzRWxlbWVudE5vZGUoc3RhcnQpID8gc3RhcnQuZ2V0TGFzdERlc2NlbmRhbnQoKSB8fCBzdGFydCA6IHN0YXJ0KTtcbiAgbGV0IG5vZGUgPSBzdGFydDtcbiAgbGV0IGRlcHRoID0gJGdldERlcHRoKG5vZGUpO1xuICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiAhbm9kZS5pcyhlbmQpKSB7XG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBkZXB0aCxcbiAgICAgIG5vZGVcbiAgICB9KTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5nZXRDaGlsZHJlblNpemUoKSA+IDApIHtcbiAgICAgIG5vZGUgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGRlcHRoKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgaW1tZWRpYXRlIHNpYmxpbmcgb3IgbmVhcmVzdCBwYXJlbnQgc2libGluZ1xuICAgICAgbGV0IHNpYmxpbmcgPSBudWxsO1xuICAgICAgd2hpbGUgKHNpYmxpbmcgPT09IG51bGwgJiYgbm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBzaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICBpZiAoc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUgIT09IG51bGwgJiYgbm9kZS5pcyhlbmQpKSB7XG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBkZXB0aCxcbiAgICAgIG5vZGVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5mdW5jdGlvbiAkZ2V0RGVwdGgobm9kZSkge1xuICBsZXQgaW5uZXJOb2RlID0gbm9kZTtcbiAgbGV0IGRlcHRoID0gMDtcbiAgd2hpbGUgKChpbm5lck5vZGUgPSBpbm5lck5vZGUuZ2V0UGFyZW50KCkpICE9PSBudWxsKSB7XG4gICAgZGVwdGgrKztcbiAgfVxuICByZXR1cm4gZGVwdGg7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSByaWdodC10by1sZWZ0IHByZW9yZGVyIHRyZWUgdHJhdmVyc2FsLlxuICogRnJvbSB0aGUgc3RhcnRpbmcgbm9kZSBpdCBnb2VzIHRvIHRoZSByaWdodG1vc3QgY2hpbGQsIHRoYW4gYmFja3RyYWNrcyB0byBwYXJldCBhbmQgZmluZHMgbmV3IHJpZ2h0bW9zdCBwYXRoLlxuICogSXQgd2lsbCByZXR1cm4gdGhlIG5leHQgbm9kZSBpbiB0cmF2ZXJzYWwgc2VxdWVuY2UgYWZ0ZXIgdGhlIHN0YXJ0aW5nTm9kZS5cbiAqIFRoZSB0cmF2ZXJzYWwgaXMgc2ltaWxhciB0byAkZGZzIGZ1bmN0aW9ucyBhYm92ZSwgYnV0IHRoZSBub2RlcyBhcmUgdmlzaXRlZCByaWdodC10by1sZWZ0LCBub3QgbGVmdC10by1yaWdodC5cbiAqIEBwYXJhbSBzdGFydGluZ05vZGUgLSBUaGUgbm9kZSB0byBzdGFydCB0aGUgc2VhcmNoLlxuICogQHJldHVybnMgVGhlIG5leHQgbm9kZSBpbiBwcmUtb3JkZXIgcmlnaHQgdG8gbGVmdCB0cmF2ZXJzYWwgc2VxdWVuY2Ugb3IgYG51bGxgLCBpZiB0aGUgbm9kZSBkb2VzIG5vdCBleGlzdFxuICovXG5mdW5jdGlvbiAkZ2V0TmV4dFJpZ2h0UHJlb3JkZXJOb2RlKHN0YXJ0aW5nTm9kZSkge1xuICBsZXQgbm9kZSA9IHN0YXJ0aW5nTm9kZTtcbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPiAwKSB7XG4gICAgbm9kZSA9IG5vZGUuZ2V0TGFzdENoaWxkKCk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHNpYmxpbmcgPSBudWxsO1xuICAgIHdoaWxlIChzaWJsaW5nID09PSBudWxsICYmIG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHNpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgaWYgKHNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogVGFrZXMgYSBub2RlIGFuZCB0cmF2ZXJzZXMgdXAgaXRzIGFuY2VzdG9ycyAodG93YXJkIHRoZSByb290IG5vZGUpXG4gKiBpbiBvcmRlciB0byBmaW5kIGEgc3BlY2lmaWMgdHlwZSBvZiBub2RlLlxuICogQHBhcmFtIG5vZGUgLSB0aGUgbm9kZSB0byBiZWdpbiBzZWFyY2hpbmcuXG4gKiBAcGFyYW0ga2xhc3MgLSBhbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBvZiBub2RlIHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgdGhlIG5vZGUgb2YgdHlwZSBrbGFzcyB0aGF0IHdhcyBwYXNzZWQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gJGdldE5lYXJlc3ROb2RlT2ZUeXBlKG5vZGUsIGtsYXNzKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2Yga2xhc3MpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IG5vZGUgb2YgdGhlIG5lYXJlc3QgYW5jZXN0b3IsIG90aGVyd2lzZSB0aHJvd3MgYW4gZXJyb3IuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIHN0YXJ0aW5nIG5vZGUgb2YgdGhlIHNlYXJjaFxuICogQHJldHVybnMgVGhlIGFuY2VzdG9yIG5vZGUgZm91bmRcbiAqL1xuZnVuY3Rpb24gJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3coc3RhcnROb2RlKSB7XG4gIGNvbnN0IGJsb2NrTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnROb2RlLCBub2RlID0+ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpO1xuICBpZiAoISRpc0VsZW1lbnROb2RlKGJsb2NrTm9kZSkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSAke3N0YXJ0Tm9kZS5fX2tleX0gdG8gaGF2ZSBjbG9zZXN0IGJsb2NrIGVsZW1lbnQgbm9kZS5gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJsb2NrTm9kZTtcbn1cbi8qKlxuICogU3RhcnRzIHdpdGggYSBub2RlIGFuZCBtb3ZlcyB1cCB0aGUgdHJlZSAodG93YXJkIHRoZSByb290IG5vZGUpIHRvIGZpbmQgYSBtYXRjaGluZyBub2RlIGJhc2VkIG9uXG4gKiB0aGUgc2VhcmNoIHBhcmFtZXRlcnMgb2YgdGhlIGZpbmRGbi4gKENvbnNpZGVyIEphdmFTY3JpcHRzJyAuZmluZCgpIGZ1bmN0aW9uIHdoZXJlIGEgdGVzdGluZyBmdW5jdGlvbiBtdXN0IGJlXG4gKiBwYXNzZWQgYXMgYW4gYXJndW1lbnQuIGVnLiBpZiggKG5vZGUpID0+IG5vZGUuX190eXBlID09PSAnZGl2JykgKSByZXR1cm4gdHJ1ZTsgb3RoZXJ3aXNlIHJldHVybiBmYWxzZVxuICogQHBhcmFtIHN0YXJ0aW5nTm9kZSAtIFRoZSBub2RlIHdoZXJlIHRoZSBzZWFyY2ggc3RhcnRzLlxuICogQHBhcmFtIGZpbmRGbiAtIEEgdGVzdGluZyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBub2RlIHNhdGlzZmllcyB0aGUgdGVzdGluZyBwYXJhbWV0ZXJzLlxuICogQHJldHVybnMgQSBwYXJlbnQgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIGZpbmRGbiBwYXJhbWV0ZXJzLCBvciBudWxsIGlmIG9uZSB3YXNuJ3QgZm91bmQuXG4gKi9cbmNvbnN0ICRmaW5kTWF0Y2hpbmdQYXJlbnQgPSAoc3RhcnRpbmdOb2RlLCBmaW5kRm4pID0+IHtcbiAgbGV0IGN1cnIgPSBzdGFydGluZ05vZGU7XG4gIHdoaWxlIChjdXJyICE9PSAkZ2V0Um9vdCgpICYmIGN1cnIgIT0gbnVsbCkge1xuICAgIGlmIChmaW5kRm4oY3VycikpIHtcbiAgICAgIHJldHVybiBjdXJyO1xuICAgIH1cbiAgICBjdXJyID0gY3Vyci5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcmVzb2x2ZSBuZXN0ZWQgZWxlbWVudCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGludG8gYSBzaW5nbGUgbm9kZSBvZiB0aGF0IHR5cGUuXG4gKiBJdCBpcyBnZW5lcmFsbHkgdXNlZCBmb3IgbWFya3MvY29tbWVudGluZ1xuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvclxuICogQHBhcmFtIHRhcmdldE5vZGUgLSBUaGUgdGFyZ2V0IGZvciB0aGUgbmVzdGVkIGVsZW1lbnQgdG8gYmUgZXh0cmFjdGVkIGZyb20uXG4gKiBAcGFyYW0gY2xvbmVOb2RlIC0gU2VlIHtAbGluayAkY3JlYXRlTWFya05vZGV9XG4gKiBAcGFyYW0gaGFuZGxlT3ZlcmxhcCAtIEhhbmRsZXMgYW55IG92ZXJsYXAgYmV0d2VlbiB0aGUgbm9kZSB0byBleHRyYWN0IGFuZCB0aGUgdGFyZ2V0Tm9kZVxuICogQHJldHVybnMgVGhlIGxleGljYWwgZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyKGVkaXRvciwgdGFyZ2V0Tm9kZSwgY2xvbmVOb2RlLCBoYW5kbGVPdmVybGFwKSB7XG4gIGNvbnN0ICRpc1RhcmdldE5vZGUgPSBub2RlID0+IHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIHRhcmdldE5vZGU7XG4gIH07XG4gIGNvbnN0ICRmaW5kTWF0Y2ggPSBub2RlID0+IHtcbiAgICAvLyBGaXJzdCB2YWxpZGF0ZSB3ZSBkb24ndCBoYXZlIGFueSBjaGlsZHJlbiB0aGF0IGFyZSBvZiB0aGUgdGFyZ2V0LFxuICAgIC8vIGFzIHdlIG5lZWQgdG8gaGFuZGxlIHRoZW0gZmlyc3QuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmICgkaXNUYXJnZXROb2RlKGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHBhcmVudE5vZGUgPSBub2RlO1xuICAgIGxldCBjaGlsZE5vZGUgPSBub2RlO1xuICAgIHdoaWxlIChwYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICBjaGlsZE5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBpZiAoJGlzVGFyZ2V0Tm9kZShwYXJlbnROb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoaWxkOiBjaGlsZE5vZGUsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBjb25zdCAkZWxlbWVudE5vZGVUcmFuc2Zvcm0gPSBub2RlID0+IHtcbiAgICBjb25zdCBtYXRjaCA9ICRmaW5kTWF0Y2gobm9kZSk7XG4gICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkLFxuICAgICAgICBwYXJlbnRcbiAgICAgIH0gPSBtYXRjaDtcblxuICAgICAgLy8gU2ltcGxlIHBhdGgsIHdlIGNhbiBtb3ZlIGNoaWxkIG91dCBhbmQgc2libGluZ3MgaW50byBhIG5ldyBwYXJlbnQuXG5cbiAgICAgIGlmIChjaGlsZC5pcyhub2RlKSkge1xuICAgICAgICBoYW5kbGVPdmVybGFwKHBhcmVudCwgbm9kZSk7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5ncyA9IGNoaWxkLmdldE5leHRTaWJsaW5ncygpO1xuICAgICAgICBjb25zdCBuZXh0U2libGluZ3NMZW5ndGggPSBuZXh0U2libGluZ3MubGVuZ3RoO1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QWZ0ZXIoY2hpbGQpO1xuICAgICAgICBpZiAobmV4dFNpYmxpbmdzTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgY29uc3QgbmV3UGFyZW50ID0gY2xvbmVOb2RlKHBhcmVudCk7XG4gICAgICAgICAgY2hpbGQuaW5zZXJ0QWZ0ZXIobmV3UGFyZW50KTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRTaWJsaW5nc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdQYXJlbnQuYXBwZW5kKG5leHRTaWJsaW5nc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50LmNhbkJlRW1wdHkoKSAmJiBwYXJlbnQuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKHRhcmdldE5vZGUsICRlbGVtZW50Tm9kZVRyYW5zZm9ybSk7XG59XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBlZGl0b3IgYW5kIG1hcmtzIGl0IGFzIGRpcnR5IHRvIGJlIHJlY29uY2lsZWQuIElmIHRoZXJlIHdhcyBhIHNlbGVjdGlvbixcbiAqIGl0IHdvdWxkIGJlIHNldCBiYWNrIHRvIGl0cyBwcmV2aW91cyBzdGF0ZSwgb3IgbnVsbCBvdGhlcndpc2UuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yXG4gKiBAcGFyYW0gZWRpdG9yU3RhdGUgLSBUaGUgZWRpdG9yJ3Mgc3RhdGVcbiAqL1xuZnVuY3Rpb24gJHJlc3RvcmVFZGl0b3JTdGF0ZShlZGl0b3IsIGVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IEZVTExfUkVDT05DSUxFID0gMjtcbiAgY29uc3Qgbm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgYWN0aXZlRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgZm9yIChjb25zdCBba2V5LCBub2RlXSBvZiBlZGl0b3JTdGF0ZS5fbm9kZU1hcCkge1xuICAgIGNvbnN0IGNsb25lID0gJGNsb25lV2l0aFByb3BlcnRpZXMobm9kZSk7XG4gICAgaWYgKCRpc1RleHROb2RlKGNsb25lKSkge1xuICAgICAgaWYgKCEkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSBiZSBhIFRleHROb2RlYCk7XG4gICAgICB9XG4gICAgICBjbG9uZS5fX3RleHQgPSBub2RlLl9fdGV4dDtcbiAgICB9XG4gICAgbm9kZU1hcC5zZXQoa2V5LCBjbG9uZSk7XG4gIH1cbiAgaWYgKGFjdGl2ZUVkaXRvclN0YXRlKSB7XG4gICAgYWN0aXZlRWRpdG9yU3RhdGUuX25vZGVNYXAgPSBub2RlTWFwO1xuICB9XG4gIGVkaXRvci5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uID09PSBudWxsID8gbnVsbCA6IHNlbGVjdGlvbi5jbG9uZSgpKTtcbn1cblxuLyoqXG4gKiBJZiB0aGUgc2VsZWN0ZWQgaW5zZXJ0aW9uIGFyZWEgaXMgdGhlIHJvb3Qvc2hhZG93IHJvb3Qgbm9kZSAoc2VlIHtAbGluayBsZXhpY2FsISRpc1Jvb3RPclNoYWRvd1Jvb3R9KSxcbiAqIHRoZSBub2RlIHdpbGwgYmUgYXBwZW5kZWQgdGhlcmUsIG90aGVyd2lzZSwgaXQgd2lsbCBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlIGluc2VydGlvbiBhcmVhLlxuICogSWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uIHdoZXJlIHRoZSBub2RlIGlzIHRvIGJlIGluc2VydGVkLCBpdCB3aWxsIGJlIGFwcGVuZGVkIGFmdGVyIGFueSBjdXJyZW50IG5vZGVzXG4gKiB3aXRoaW4gdGhlIHRyZWUsIGFzIGEgY2hpbGQgb2YgdGhlIHJvb3Qgbm9kZS4gQSBwYXJhZ3JhcGggbm9kZSB3aWxsIHRoZW4gYmUgYWRkZWQgYWZ0ZXIgdGhlIGluc2VydGVkIG5vZGUgYW5kIHNlbGVjdGVkLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBpbnNlcnRlZFxuICogQHJldHVybnMgVGhlIG5vZGUgYWZ0ZXIgaXRzIGluc2VydGlvblxuICovXG5mdW5jdGlvbiAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3Qobm9kZSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkgfHwgJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm9jdXNcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChmb2N1c05vZGUpKSB7XG4gICAgICBjb25zdCBmb2N1c0NoaWxkID0gZm9jdXNOb2RlLmdldENoaWxkQXRJbmRleChmb2N1c09mZnNldCk7XG4gICAgICBpZiAoZm9jdXNDaGlsZCA9PSBudWxsKSB7XG4gICAgICAgIGZvY3VzTm9kZS5hcHBlbmQobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb2N1c0NoaWxkLmluc2VydEJlZm9yZShub2RlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2VsZWN0TmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgc3BsaXROb2RlO1xuICAgICAgbGV0IHNwbGl0T2Zmc2V0O1xuICAgICAgaWYgKCRpc1RleHROb2RlKGZvY3VzTm9kZSkpIHtcbiAgICAgICAgc3BsaXROb2RlID0gZm9jdXNOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgc3BsaXRPZmZzZXQgPSBmb2N1c05vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgICAgaWYgKGZvY3VzT2Zmc2V0ID4gMCkge1xuICAgICAgICAgIHNwbGl0T2Zmc2V0ICs9IDE7XG4gICAgICAgICAgZm9jdXNOb2RlLnNwbGl0VGV4dChmb2N1c09mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwbGl0Tm9kZSA9IGZvY3VzTm9kZTtcbiAgICAgICAgc3BsaXRPZmZzZXQgPSBmb2N1c09mZnNldDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFssIHJpZ2h0VHJlZV0gPSAkc3BsaXROb2RlKHNwbGl0Tm9kZSwgc3BsaXRPZmZzZXQpO1xuICAgICAgcmlnaHRUcmVlLmluc2VydEJlZm9yZShub2RlKTtcbiAgICAgIHJpZ2h0VHJlZS5zZWxlY3RTdGFydCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2VsZWN0aW9uICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgICBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXS5nZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCkuaW5zZXJ0QWZ0ZXIobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICAgICAgcm9vdC5hcHBlbmQobm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFncmFwaE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIG5vZGUuaW5zZXJ0QWZ0ZXIocGFyYWdyYXBoTm9kZSk7XG4gICAgcGFyYWdyYXBoTm9kZS5zZWxlY3QoKTtcbiAgfVxuICByZXR1cm4gbm9kZS5nZXRMYXRlc3QoKTtcbn1cblxuLyoqXG4gKiBXcmFwcyB0aGUgbm9kZSBpbnRvIGFub3RoZXIgbm9kZSBjcmVhdGVkIGZyb20gYSBjcmVhdGVFbGVtZW50Tm9kZSBmdW5jdGlvbiwgZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlXG4gKiBAcGFyYW0gbm9kZSAtIE5vZGUgdG8gYmUgd3JhcHBlZC5cbiAqIEBwYXJhbSBjcmVhdGVFbGVtZW50Tm9kZSAtIENyZWF0ZXMgYSBuZXcgbGV4aWNhbCBlbGVtZW50IHRvIHdyYXAgdGhlIHRvLWJlLXdyYXBwZWQgbm9kZSBhbmQgcmV0dXJucyBpdC5cbiAqIEByZXR1cm5zIEEgbmV3IGxleGljYWwgZWxlbWVudCB3aXRoIHRoZSBwcmV2aW91cyBub2RlIGFwcGVuZGVkIHdpdGhpbiAoYXMgYSBjaGlsZCwgaW5jbHVkaW5nIGl0cyBjaGlsZHJlbikuXG4gKi9cbmZ1bmN0aW9uICR3cmFwTm9kZUluRWxlbWVudChub2RlLCBjcmVhdGVFbGVtZW50Tm9kZSkge1xuICBjb25zdCBlbGVtZW50Tm9kZSA9IGNyZWF0ZUVsZW1lbnROb2RlKCk7XG4gIG5vZGUucmVwbGFjZShlbGVtZW50Tm9kZSk7XG4gIGVsZW1lbnROb2RlLmFwcGVuZChub2RlKTtcbiAgcmV0dXJuIGVsZW1lbnROb2RlO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4vKipcbiAqIEBwYXJhbSBvYmplY3QgPSBUaGUgaW5zdGFuY2Ugb2YgdGhlIHR5cGVcbiAqIEBwYXJhbSBvYmplY3RDbGFzcyA9IFRoZSBjbGFzcyBvZiB0aGUgdHlwZVxuICogQHJldHVybnMgV2hldGhlciB0aGUgb2JqZWN0IGlzIGhhcyB0aGUgc2FtZSBLbGFzcyBvZiB0aGUgb2JqZWN0Q2xhc3MsIGlnbm9yaW5nIHRoZSBkaWZmZXJlbmNlIGFjcm9zcyB3aW5kb3cgKGUuZy4gZGlmZmVyZW50IGlmcmFtcylcbiAqL1xuZnVuY3Rpb24gb2JqZWN0S2xhc3NFcXVhbHMob2JqZWN0LCBvYmplY3RDbGFzcykge1xuICByZXR1cm4gb2JqZWN0ICE9PSBudWxsID8gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCkuY29uc3RydWN0b3IubmFtZSA9PT0gb2JqZWN0Q2xhc3MubmFtZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIEZpbHRlciB0aGUgbm9kZXNcbiAqIEBwYXJhbSBub2RlcyBBcnJheSBvZiBub2RlcyB0aGF0IG5lZWRzIHRvIGJlIGZpbHRlcmVkXG4gKiBAcGFyYW0gZmlsdGVyRm4gQSBmaWx0ZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG5vZGUgaWYgdGhlIGN1cnJlbnQgbm9kZSBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBvdGhlcndpc2UgbnVsbFxuICogQHJldHVybnMgQXJyYXkgb2YgZmlsdGVyZWQgbm9kZXNcbiAqL1xuXG5mdW5jdGlvbiAkZmlsdGVyKG5vZGVzLCBmaWx0ZXJGbikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBmaWx0ZXJGbihub2Rlc1tpXSk7XG4gICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBBcHBlbmRzIHRoZSBub2RlIGJlZm9yZSB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIHBhcmVudCBub2RlXG4gKiBAcGFyYW0gcGFyZW50IEEgcGFyZW50IG5vZGVcbiAqIEBwYXJhbSBub2RlIE5vZGUgdGhhdCBuZWVkcyB0byBiZSBhcHBlbmRlZFxuICovXG5mdW5jdGlvbiAkaW5zZXJ0Rmlyc3QocGFyZW50LCBub2RlKSB7XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJlbnQuZ2V0Rmlyc3RDaGlsZCgpO1xuICBpZiAoZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudC5hcHBlbmQobm9kZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB6b29tIGxldmVsIG9mIGFuIGVsZW1lbnQgYXMgYSByZXN1bHQgb2YgdXNpbmdcbiAqIGNzcyB6b29tIHByb3BlcnR5LlxuICogQHBhcmFtIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlWm9vbUxldmVsKGVsZW1lbnQpIHtcbiAgaWYgKElTX0ZJUkVGT1gpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBsZXQgem9vbSA9IDE7XG4gIHdoaWxlIChlbGVtZW50KSB7XG4gICAgem9vbSAqPSBOdW1iZXIod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnem9vbScpKTtcbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiB6b29tO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZWRpdG9yIGlzIGEgbmVzdGVkIGVkaXRvciBjcmVhdGVkIGJ5IExleGljYWxOZXN0ZWRDb21wb3NlclxuICovXG5mdW5jdGlvbiAkaXNFZGl0b3JJc05lc3RlZEVkaXRvcihlZGl0b3IpIHtcbiAgcmV0dXJuIGVkaXRvci5fcGFyZW50RWRpdG9yICE9PSBudWxsO1xufVxuXG5leHBvcnQgeyAkZGZzLCAkZmlsdGVyLCAkZmluZE1hdGNoaW5nUGFyZW50LCAkZ2V0TmVhcmVzdEJsb2NrRWxlbWVudEFuY2VzdG9yT3JUaHJvdywgJGdldE5lYXJlc3ROb2RlT2ZUeXBlLCAkZ2V0TmV4dFJpZ2h0UHJlb3JkZXJOb2RlLCAkaW5zZXJ0Rmlyc3QsICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdCwgJGlzRWRpdG9ySXNOZXN0ZWRFZGl0b3IsICRyZXN0b3JlRWRpdG9yU3RhdGUsICR3cmFwTm9kZUluRWxlbWVudCwgQ0FOX1VTRV9CRUZPUkVfSU5QVVQsIENBTl9VU0VfRE9NLCBJU19BTkRST0lELCBJU19BTkRST0lEX0NIUk9NRSwgSVNfQVBQTEUsIElTX0FQUExFX1dFQktJVCwgSVNfQ0hST01FLCBJU19GSVJFRk9YLCBJU19JT1MsIElTX1NBRkFSSSwgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCwgY2FsY3VsYXRlWm9vbUxldmVsLCBpc01pbWVUeXBlLCBtYXJrU2VsZWN0aW9uLCBtZWRpYUZpbGVSZWFkZXIsIG1lcmdlUmVnaXN0ZXIsIG9iamVjdEtsYXNzRXF1YWxzLCBwb3NpdGlvbk5vZGVPblJhbmdlLCByZWdpc3Rlck5lc3RlZEVsZW1lbnRSZXNvbHZlciwgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/yjs/LexicalYjs.dev.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@lexical/yjs/LexicalYjs.dev.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONNECTED_COMMAND: () => (/* binding */ CONNECTED_COMMAND),\n/* harmony export */   TOGGLE_CONNECT_COMMAND: () => (/* binding */ TOGGLE_CONNECT_COMMAND),\n/* harmony export */   createBinding: () => (/* binding */ createBinding),\n/* harmony export */   createUndoManager: () => (/* binding */ createUndoManager),\n/* harmony export */   initLocalState: () => (/* binding */ initLocalState),\n/* harmony export */   setLocalStateFocus: () => (/* binding */ setLocalStateFocus),\n/* harmony export */   syncCursorPositions: () => (/* binding */ syncCursorPositions),\n/* harmony export */   syncLexicalUpdateToYjs: () => (/* binding */ syncLexicalUpdateToYjs),\n/* harmony export */   syncYjsChangesToLexical: () => (/* binding */ syncYjsChangesToLexical)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _lexical_offset__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/offset */ \"(ssr)/./node_modules/@lexical/offset/LexicalOffset.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass CollabLineBreakNode {\n  constructor(map, parent) {\n    this._key = '';\n    this._map = map;\n    this._parent = parent;\n    this._type = 'linebreak';\n  }\n  getNode() {\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this._key);\n    return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(node) ? node : null;\n  }\n  getKey() {\n    return this._key;\n  }\n  getSharedType() {\n    return this._map;\n  }\n  getType() {\n    return this._type;\n  }\n  getSize() {\n    return 1;\n  }\n  getOffset() {\n    const collabElementNode = this._parent;\n    return collabElementNode.getChildOffset(this);\n  }\n  destroy(binding) {\n    const collabNodeMap = binding.collabNodeMap;\n    collabNodeMap.delete(this._key);\n  }\n}\nfunction $createCollabLineBreakNode(map, parent) {\n  const collabNode = new CollabLineBreakNode(map, parent);\n  map._collabNode = collabNode;\n  return collabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction simpleDiffWithCursor(a, b, cursor) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0; // number of same characters counting from left\n  let right = 0; // number of same characters counting from right\n  // Iterate left to the right until we find a changed character\n  // First iteration considers the current cursor position\n  while (left < aLength && left < bLength && a[left] === b[left] && left < cursor) {\n    left++;\n  }\n  // Iterate right to the left until we find a changed character\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  // Try to iterate left further to the right without caring about the current cursor position\n  while (right + left < aLength && right + left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  return {\n    index: left,\n    insert: b.slice(left, bLength - right),\n    remove: aLength - left - right\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $diffTextContentAndApplyDelta(collabNode, key, prevText, nextText) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  let cursorOffset = nextText.length;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n    const anchor = selection.anchor;\n    if (anchor.key === key) {\n      cursorOffset = anchor.offset;\n    }\n  }\n  const diff = simpleDiffWithCursor(prevText, nextText, cursorOffset);\n  collabNode.spliceText(diff.index, diff.remove, diff.insert);\n}\nclass CollabTextNode {\n  constructor(map, text, parent, type) {\n    this._key = '';\n    this._map = map;\n    this._parent = parent;\n    this._text = text;\n    this._type = type;\n    this._normalized = false;\n  }\n  getPrevNode(nodeMap) {\n    if (nodeMap === null) {\n      return null;\n    }\n    const node = nodeMap.get(this._key);\n    return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node) ? node : null;\n  }\n  getNode() {\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this._key);\n    return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node) ? node : null;\n  }\n  getSharedType() {\n    return this._map;\n  }\n  getType() {\n    return this._type;\n  }\n  getKey() {\n    return this._key;\n  }\n  getSize() {\n    return this._text.length + (this._normalized ? 0 : 1);\n  }\n  getOffset() {\n    const collabElementNode = this._parent;\n    return collabElementNode.getChildOffset(this);\n  }\n  spliceText(index, delCount, newText) {\n    const collabElementNode = this._parent;\n    const xmlText = collabElementNode._xmlText;\n    const offset = this.getOffset() + 1 + index;\n    if (delCount !== 0) {\n      xmlText.delete(offset, delCount);\n    }\n    if (newText !== '') {\n      xmlText.insert(offset, newText);\n    }\n  }\n  syncPropertiesAndTextFromLexical(binding, nextLexicalNode, prevNodeMap) {\n    const prevLexicalNode = this.getPrevNode(prevNodeMap);\n    const nextText = nextLexicalNode.__text;\n    syncPropertiesFromLexical(binding, this._map, prevLexicalNode, nextLexicalNode);\n    if (prevLexicalNode !== null) {\n      const prevText = prevLexicalNode.__text;\n      if (prevText !== nextText) {\n        const key = nextLexicalNode.__key;\n        $diffTextContentAndApplyDelta(this, key, prevText, nextText);\n        this._text = nextText;\n      }\n    }\n  }\n  syncPropertiesAndTextFromYjs(binding, keysChanged) {\n    const lexicalNode = this.getNode();\n    if (!(lexicalNode !== null)) {\n      throw Error(`syncPropertiesAndTextFromYjs: could not find decorator node`);\n    }\n    syncPropertiesFromYjs(binding, this._map, lexicalNode, keysChanged);\n    const collabText = this._text;\n    if (lexicalNode.__text !== collabText) {\n      const writable = lexicalNode.getWritable();\n      writable.__text = collabText;\n    }\n  }\n  destroy(binding) {\n    const collabNodeMap = binding.collabNodeMap;\n    collabNodeMap.delete(this._key);\n  }\n}\nfunction $createCollabTextNode(map, text, parent, type) {\n  const collabNode = new CollabTextNode(map, text, parent, type);\n  map._collabNode = collabNode;\n  return collabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst baseExcludedProperties = new Set(['__key', '__parent', '__next', '__prev']);\nconst elementExcludedProperties = new Set(['__first', '__last', '__size']);\nconst rootExcludedProperties = new Set(['__cachedText']);\nconst textExcludedProperties = new Set(['__text']);\nfunction isExcludedProperty(name, node, binding) {\n  if (baseExcludedProperties.has(name)) {\n    return true;\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n    if (textExcludedProperties.has(name)) {\n      return true;\n    }\n  } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    if (elementExcludedProperties.has(name) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(node) && rootExcludedProperties.has(name)) {\n      return true;\n    }\n  }\n  const nodeKlass = node.constructor;\n  const excludedProperties = binding.excludedProperties.get(nodeKlass);\n  return excludedProperties != null && excludedProperties.has(name);\n}\nfunction $getNodeByKeyOrThrow(key) {\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(key);\n  if (!(node !== null)) {\n    throw Error(`could not find node by key`);\n  }\n  return node;\n}\nfunction $createCollabNodeFromLexicalNode(binding, lexicalNode, parent) {\n  const nodeType = lexicalNode.__type;\n  let collabNode;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(lexicalNode)) {\n    const xmlText = new yjs__WEBPACK_IMPORTED_MODULE_1__.XmlText();\n    collabNode = $createCollabElementNode(xmlText, parent, nodeType);\n    collabNode.syncPropertiesFromLexical(binding, lexicalNode, null);\n    collabNode.syncChildrenFromLexical(binding, lexicalNode, null, null, null);\n  } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(lexicalNode)) {\n    // TODO create a token text node for token, segmented nodes.\n    const map = new yjs__WEBPACK_IMPORTED_MODULE_1__.Map();\n    collabNode = $createCollabTextNode(map, lexicalNode.__text, parent, nodeType);\n    collabNode.syncPropertiesAndTextFromLexical(binding, lexicalNode, null);\n  } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(lexicalNode)) {\n    const map = new yjs__WEBPACK_IMPORTED_MODULE_1__.Map();\n    map.set('__type', 'linebreak');\n    collabNode = $createCollabLineBreakNode(map, parent);\n  } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(lexicalNode)) {\n    const xmlElem = new yjs__WEBPACK_IMPORTED_MODULE_1__.XmlElement();\n    collabNode = $createCollabDecoratorNode(xmlElem, parent, nodeType);\n    collabNode.syncPropertiesFromLexical(binding, lexicalNode, null);\n  } else {\n    {\n      throw Error(`Expected text, element, decorator, or linebreak node`);\n    }\n  }\n  collabNode._key = lexicalNode.__key;\n  return collabNode;\n}\nfunction getNodeTypeFromSharedType(sharedType) {\n  const type = sharedType instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Map ? sharedType.get('__type') : sharedType.getAttribute('__type');\n  if (!(type != null)) {\n    throw Error(`Expected shared type to include type attribute`);\n  }\n  return type;\n}\nfunction $getOrInitCollabNodeFromSharedType(binding, sharedType, parent) {\n  const collabNode = sharedType._collabNode;\n  if (collabNode === undefined) {\n    const registeredNodes = binding.editor._nodes;\n    const type = getNodeTypeFromSharedType(sharedType);\n    const nodeInfo = registeredNodes.get(type);\n    if (!(nodeInfo !== undefined)) {\n      throw Error(`Node ${type} is not registered`);\n    }\n    const sharedParent = sharedType.parent;\n    const targetParent = parent === undefined && sharedParent !== null ? $getOrInitCollabNodeFromSharedType(binding, sharedParent) : parent || null;\n    if (!(targetParent instanceof CollabElementNode)) {\n      throw Error(`Expected parent to be a collab element node`);\n    }\n    if (sharedType instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.XmlText) {\n      return $createCollabElementNode(sharedType, targetParent, type);\n    } else if (sharedType instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Map) {\n      if (type === 'linebreak') {\n        return $createCollabLineBreakNode(sharedType, targetParent);\n      }\n      return $createCollabTextNode(sharedType, '', targetParent, type);\n    } else if (sharedType instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.XmlElement) {\n      return $createCollabDecoratorNode(sharedType, targetParent, type);\n    }\n  }\n  return collabNode;\n}\nfunction createLexicalNodeFromCollabNode(binding, collabNode, parentKey) {\n  const type = collabNode.getType();\n  const registeredNodes = binding.editor._nodes;\n  const nodeInfo = registeredNodes.get(type);\n  if (!(nodeInfo !== undefined)) {\n    throw Error(`Node ${type} is not registered`);\n  }\n  const lexicalNode = new nodeInfo.klass();\n  lexicalNode.__parent = parentKey;\n  collabNode._key = lexicalNode.__key;\n  if (collabNode instanceof CollabElementNode) {\n    const xmlText = collabNode._xmlText;\n    collabNode.syncPropertiesFromYjs(binding, null);\n    collabNode.applyChildrenYjsDelta(binding, xmlText.toDelta());\n    collabNode.syncChildrenFromYjs(binding);\n  } else if (collabNode instanceof CollabTextNode) {\n    collabNode.syncPropertiesAndTextFromYjs(binding, null);\n  } else if (collabNode instanceof CollabDecoratorNode) {\n    collabNode.syncPropertiesFromYjs(binding, null);\n  }\n  binding.collabNodeMap.set(lexicalNode.__key, collabNode);\n  return lexicalNode;\n}\nfunction syncPropertiesFromYjs(binding, sharedType, lexicalNode, keysChanged) {\n  const properties = keysChanged === null ? sharedType instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Map ? Array.from(sharedType.keys()) : Object.keys(sharedType.getAttributes()) : Array.from(keysChanged);\n  let writableNode;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (isExcludedProperty(property, lexicalNode, binding)) {\n      continue;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const prevValue = lexicalNode[property];\n    let nextValue = sharedType instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Map ? sharedType.get(property) : sharedType.getAttribute(property);\n    if (prevValue !== nextValue) {\n      if (nextValue instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Doc) {\n        const yjsDocMap = binding.docMap;\n        if (prevValue instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Doc) {\n          yjsDocMap.delete(prevValue.guid);\n        }\n        const nestedEditor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createEditor)();\n        const key = nextValue.guid;\n        nestedEditor._key = key;\n        yjsDocMap.set(key, nextValue);\n        nextValue = nestedEditor;\n      }\n      if (writableNode === undefined) {\n        writableNode = lexicalNode.getWritable();\n      }\n      writableNode[property] = nextValue;\n    }\n  }\n}\nfunction syncPropertiesFromLexical(binding, sharedType, prevLexicalNode, nextLexicalNode) {\n  const type = nextLexicalNode.__type;\n  const nodeProperties = binding.nodeProperties;\n  let properties = nodeProperties.get(type);\n  if (properties === undefined) {\n    properties = Object.keys(nextLexicalNode).filter(property => {\n      return !isExcludedProperty(property, nextLexicalNode, binding);\n    });\n    nodeProperties.set(type, properties);\n  }\n  const EditorClass = binding.editor.constructor;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    const prevValue =\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    prevLexicalNode === null ? undefined : prevLexicalNode[property];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let nextValue = nextLexicalNode[property];\n    if (prevValue !== nextValue) {\n      if (nextValue instanceof EditorClass) {\n        const yjsDocMap = binding.docMap;\n        let prevDoc;\n        if (prevValue instanceof EditorClass) {\n          const prevKey = prevValue._key;\n          prevDoc = yjsDocMap.get(prevKey);\n          yjsDocMap.delete(prevKey);\n        }\n\n        // If we already have a document, use it.\n        const doc = prevDoc || new yjs__WEBPACK_IMPORTED_MODULE_1__.Doc();\n        const key = doc.guid;\n        nextValue._key = key;\n        yjsDocMap.set(key, doc);\n        nextValue = doc;\n        // Mark the node dirty as we've assigned a new key to it\n        binding.editor.update(() => {\n          nextLexicalNode.markDirty();\n        });\n      }\n      if (sharedType instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Map) {\n        sharedType.set(property, nextValue);\n      } else {\n        sharedType.setAttribute(property, nextValue);\n      }\n    }\n  }\n}\nfunction spliceString(str, index, delCount, newText) {\n  return str.slice(0, index) + newText + str.slice(index + delCount);\n}\nfunction getPositionFromElementAndOffset(node, offset, boundaryIsEdge) {\n  let index = 0;\n  let i = 0;\n  const children = node._children;\n  const childrenLength = children.length;\n  for (; i < childrenLength; i++) {\n    const child = children[i];\n    const childOffset = index;\n    const size = child.getSize();\n    index += size;\n    const exceedsBoundary = boundaryIsEdge ? index >= offset : index > offset;\n    if (exceedsBoundary && child instanceof CollabTextNode) {\n      let textOffset = offset - childOffset - 1;\n      if (textOffset < 0) {\n        textOffset = 0;\n      }\n      const diffLength = index - offset;\n      return {\n        length: diffLength,\n        node: child,\n        nodeIndex: i,\n        offset: textOffset\n      };\n    }\n    if (index > offset) {\n      return {\n        length: 0,\n        node: child,\n        nodeIndex: i,\n        offset: childOffset\n      };\n    } else if (i === childrenLength - 1) {\n      return {\n        length: 0,\n        node: null,\n        nodeIndex: i + 1,\n        offset: childOffset + 1\n      };\n    }\n  }\n  return {\n    length: 0,\n    node: null,\n    nodeIndex: 0,\n    offset: 0\n  };\n}\nfunction doesSelectionNeedRecovering(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  let recoveryNeeded = false;\n  try {\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (\n    // We might have removed a node that no longer exists\n    !anchorNode.isAttached() || !focusNode.isAttached() ||\n    // If we've split a node, then the offset might not be right\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode) && anchor.offset > anchorNode.getTextContentSize() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode) && focus.offset > focusNode.getTextContentSize()) {\n      recoveryNeeded = true;\n    }\n  } catch (e) {\n    // Sometimes checking nor a node via getNode might trigger\n    // an error, so we need recovery then too.\n    recoveryNeeded = true;\n  }\n  return recoveryNeeded;\n}\nfunction syncWithTransaction(binding, fn) {\n  binding.doc.transact(fn, binding);\n}\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n    // TODO: this function duplicates a bunch of operations, can be simplified.\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n      writableNode.__prev = null;\n    }\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n      writableNode.__next = null;\n    }\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n}\nfunction $moveSelectionToPreviousNode(anchorNodeKey, currentEditorState) {\n  const anchorNode = currentEditorState._nodeMap.get(anchorNodeKey);\n  if (!anchorNode) {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)().selectStart();\n    return;\n  }\n  // Get previous node\n  const prevNodeKey = anchorNode.__prev;\n  let prevNode = null;\n  if (prevNodeKey) {\n    prevNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(prevNodeKey);\n  }\n\n  // If previous node not found, get parent node\n  if (prevNode === null && anchorNode.__parent !== null) {\n    prevNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(anchorNode.__parent);\n  }\n  if (prevNode === null) {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)().selectStart();\n    return;\n  }\n  if (prevNode !== null && prevNode.isAttached()) {\n    prevNode.selectEnd();\n    return;\n  } else {\n    // If the found node is also deleted, select the next one\n    $moveSelectionToPreviousNode(prevNode.__key, currentEditorState);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass CollabDecoratorNode {\n  constructor(xmlElem, parent, type) {\n    this._key = '';\n    this._xmlElem = xmlElem;\n    this._parent = parent;\n    this._type = type;\n  }\n  getPrevNode(nodeMap) {\n    if (nodeMap === null) {\n      return null;\n    }\n    const node = nodeMap.get(this._key);\n    return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node) ? node : null;\n  }\n  getNode() {\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this._key);\n    return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node) ? node : null;\n  }\n  getSharedType() {\n    return this._xmlElem;\n  }\n  getType() {\n    return this._type;\n  }\n  getKey() {\n    return this._key;\n  }\n  getSize() {\n    return 1;\n  }\n  getOffset() {\n    const collabElementNode = this._parent;\n    return collabElementNode.getChildOffset(this);\n  }\n  syncPropertiesFromLexical(binding, nextLexicalNode, prevNodeMap) {\n    const prevLexicalNode = this.getPrevNode(prevNodeMap);\n    const xmlElem = this._xmlElem;\n    syncPropertiesFromLexical(binding, xmlElem, prevLexicalNode, nextLexicalNode);\n  }\n  syncPropertiesFromYjs(binding, keysChanged) {\n    const lexicalNode = this.getNode();\n    if (!(lexicalNode !== null)) {\n      throw Error(`syncPropertiesFromYjs: could not find decorator node`);\n    }\n    const xmlElem = this._xmlElem;\n    syncPropertiesFromYjs(binding, xmlElem, lexicalNode, keysChanged);\n  }\n  destroy(binding) {\n    const collabNodeMap = binding.collabNodeMap;\n    collabNodeMap.delete(this._key);\n  }\n}\nfunction $createCollabDecoratorNode(xmlElem, parent, type) {\n  const collabNode = new CollabDecoratorNode(xmlElem, parent, type);\n  xmlElem._collabNode = collabNode;\n  return collabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass CollabElementNode {\n  constructor(xmlText, parent, type) {\n    this._key = '';\n    this._children = [];\n    this._xmlText = xmlText;\n    this._type = type;\n    this._parent = parent;\n  }\n  getPrevNode(nodeMap) {\n    if (nodeMap === null) {\n      return null;\n    }\n    const node = nodeMap.get(this._key);\n    return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) ? node : null;\n  }\n  getNode() {\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this._key);\n    return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) ? node : null;\n  }\n  getSharedType() {\n    return this._xmlText;\n  }\n  getType() {\n    return this._type;\n  }\n  getKey() {\n    return this._key;\n  }\n  isEmpty() {\n    return this._children.length === 0;\n  }\n  getSize() {\n    return 1;\n  }\n  getOffset() {\n    const collabElementNode = this._parent;\n    if (!(collabElementNode !== null)) {\n      throw Error(`getOffset: could not find collab element node`);\n    }\n    return collabElementNode.getChildOffset(this);\n  }\n  syncPropertiesFromYjs(binding, keysChanged) {\n    const lexicalNode = this.getNode();\n    if (!(lexicalNode !== null)) {\n      throw Error(`syncPropertiesFromYjs: could not find element node`);\n    }\n    syncPropertiesFromYjs(binding, this._xmlText, lexicalNode, keysChanged);\n  }\n  applyChildrenYjsDelta(binding, deltas) {\n    const children = this._children;\n    let currIndex = 0;\n    for (let i = 0; i < deltas.length; i++) {\n      const delta = deltas[i];\n      const insertDelta = delta.insert;\n      const deleteDelta = delta.delete;\n      if (delta.retain != null) {\n        currIndex += delta.retain;\n      } else if (typeof deleteDelta === 'number') {\n        let deletionSize = deleteDelta;\n        while (deletionSize > 0) {\n          const {\n            node,\n            nodeIndex,\n            offset,\n            length\n          } = getPositionFromElementAndOffset(this, currIndex, false);\n          if (node instanceof CollabElementNode || node instanceof CollabLineBreakNode || node instanceof CollabDecoratorNode) {\n            children.splice(nodeIndex, 1);\n            deletionSize -= 1;\n          } else if (node instanceof CollabTextNode) {\n            const delCount = Math.min(deletionSize, length);\n            const prevCollabNode = nodeIndex !== 0 ? children[nodeIndex - 1] : null;\n            const nodeSize = node.getSize();\n            if (offset === 0 && delCount === 1 && nodeIndex > 0 && prevCollabNode instanceof CollabTextNode && length === nodeSize &&\n            // If the node has no keys, it's been deleted\n            Array.from(node._map.keys()).length === 0) {\n              // Merge the text node with previous.\n              prevCollabNode._text += node._text;\n              children.splice(nodeIndex, 1);\n            } else if (offset === 0 && delCount === nodeSize) {\n              // The entire thing needs removing\n              children.splice(nodeIndex, 1);\n            } else {\n              node._text = spliceString(node._text, offset, delCount, '');\n            }\n            deletionSize -= delCount;\n          } else {\n            // Can occur due to the deletion from the dangling text heuristic below.\n            break;\n          }\n        }\n      } else if (insertDelta != null) {\n        if (typeof insertDelta === 'string') {\n          const {\n            node,\n            offset\n          } = getPositionFromElementAndOffset(this, currIndex, true);\n          if (node instanceof CollabTextNode) {\n            node._text = spliceString(node._text, offset, 0, insertDelta);\n          } else {\n            // TODO: maybe we can improve this by keeping around a redundant\n            // text node map, rather than removing all the text nodes, so there\n            // never can be dangling text.\n\n            // We have a conflict where there was likely a CollabTextNode and\n            // an Lexical TextNode too, but they were removed in a merge. So\n            // let's just ignore the text and trigger a removal for it from our\n            // shared type.\n            this._xmlText.delete(offset, insertDelta.length);\n          }\n          currIndex += insertDelta.length;\n        } else {\n          const sharedType = insertDelta;\n          const {\n            nodeIndex\n          } = getPositionFromElementAndOffset(this, currIndex, false);\n          const collabNode = $getOrInitCollabNodeFromSharedType(binding, sharedType, this);\n          children.splice(nodeIndex, 0, collabNode);\n          currIndex += 1;\n        }\n      } else {\n        throw new Error('Unexpected delta format');\n      }\n    }\n  }\n  syncChildrenFromYjs(binding) {\n    // Now diff the children of the collab node with that of our existing Lexical node.\n    const lexicalNode = this.getNode();\n    if (!(lexicalNode !== null)) {\n      throw Error(`syncChildrenFromYjs: could not find element node`);\n    }\n    const key = lexicalNode.__key;\n    const prevLexicalChildrenKeys = (0,_lexical_offset__WEBPACK_IMPORTED_MODULE_2__.$createChildrenArray)(lexicalNode, null);\n    const lexicalChildrenKeysLength = prevLexicalChildrenKeys.length;\n    const collabChildren = this._children;\n    const collabChildrenLength = collabChildren.length;\n    const collabNodeMap = binding.collabNodeMap;\n    const visitedKeys = new Set();\n    let collabKeys;\n    let writableLexicalNode;\n    let prevIndex = 0;\n    let prevChildNode = null;\n    if (collabChildrenLength !== lexicalChildrenKeysLength) {\n      writableLexicalNode = lexicalNode.getWritable();\n    }\n    for (let i = 0; i < collabChildrenLength; i++) {\n      const lexicalChildKey = prevLexicalChildrenKeys[prevIndex];\n      const childCollabNode = collabChildren[i];\n      const collabLexicalChildNode = childCollabNode.getNode();\n      const collabKey = childCollabNode._key;\n      if (collabLexicalChildNode !== null && lexicalChildKey === collabKey) {\n        const childNeedsUpdating = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(collabLexicalChildNode);\n        // Update\n        visitedKeys.add(lexicalChildKey);\n        if (childNeedsUpdating) {\n          childCollabNode._key = lexicalChildKey;\n          if (childCollabNode instanceof CollabElementNode) {\n            const xmlText = childCollabNode._xmlText;\n            childCollabNode.syncPropertiesFromYjs(binding, null);\n            childCollabNode.applyChildrenYjsDelta(binding, xmlText.toDelta());\n            childCollabNode.syncChildrenFromYjs(binding);\n          } else if (childCollabNode instanceof CollabTextNode) {\n            childCollabNode.syncPropertiesAndTextFromYjs(binding, null);\n          } else if (childCollabNode instanceof CollabDecoratorNode) {\n            childCollabNode.syncPropertiesFromYjs(binding, null);\n          } else if (!(childCollabNode instanceof CollabLineBreakNode)) {\n            {\n              throw Error(`syncChildrenFromYjs: expected text, element, decorator, or linebreak collab node`);\n            }\n          }\n        }\n        prevChildNode = collabLexicalChildNode;\n        prevIndex++;\n      } else {\n        if (collabKeys === undefined) {\n          collabKeys = new Set();\n          for (let s = 0; s < collabChildrenLength; s++) {\n            const child = collabChildren[s];\n            const childKey = child._key;\n            if (childKey !== '') {\n              collabKeys.add(childKey);\n            }\n          }\n        }\n        if (collabLexicalChildNode !== null && lexicalChildKey !== undefined && !collabKeys.has(lexicalChildKey)) {\n          const nodeToRemove = $getNodeByKeyOrThrow(lexicalChildKey);\n          removeFromParent(nodeToRemove);\n          i--;\n          prevIndex++;\n          continue;\n        }\n        writableLexicalNode = lexicalNode.getWritable();\n        // Create/Replace\n        const lexicalChildNode = createLexicalNodeFromCollabNode(binding, childCollabNode, key);\n        const childKey = lexicalChildNode.__key;\n        collabNodeMap.set(childKey, childCollabNode);\n        if (prevChildNode === null) {\n          const nextSibling = writableLexicalNode.getFirstChild();\n          writableLexicalNode.__first = childKey;\n          if (nextSibling !== null) {\n            const writableNextSibling = nextSibling.getWritable();\n            writableNextSibling.__prev = childKey;\n            lexicalChildNode.__next = writableNextSibling.__key;\n          }\n        } else {\n          const writablePrevChildNode = prevChildNode.getWritable();\n          const nextSibling = prevChildNode.getNextSibling();\n          writablePrevChildNode.__next = childKey;\n          lexicalChildNode.__prev = prevChildNode.__key;\n          if (nextSibling !== null) {\n            const writableNextSibling = nextSibling.getWritable();\n            writableNextSibling.__prev = childKey;\n            lexicalChildNode.__next = writableNextSibling.__key;\n          }\n        }\n        if (i === collabChildrenLength - 1) {\n          writableLexicalNode.__last = childKey;\n        }\n        writableLexicalNode.__size++;\n        prevChildNode = lexicalChildNode;\n      }\n    }\n    for (let i = 0; i < lexicalChildrenKeysLength; i++) {\n      const lexicalChildKey = prevLexicalChildrenKeys[i];\n      if (!visitedKeys.has(lexicalChildKey)) {\n        // Remove\n        const lexicalChildNode = $getNodeByKeyOrThrow(lexicalChildKey);\n        const collabNode = binding.collabNodeMap.get(lexicalChildKey);\n        if (collabNode !== undefined) {\n          collabNode.destroy(binding);\n        }\n        removeFromParent(lexicalChildNode);\n      }\n    }\n  }\n  syncPropertiesFromLexical(binding, nextLexicalNode, prevNodeMap) {\n    syncPropertiesFromLexical(binding, this._xmlText, this.getPrevNode(prevNodeMap), nextLexicalNode);\n  }\n  _syncChildFromLexical(binding, index, key, prevNodeMap, dirtyElements, dirtyLeaves) {\n    const childCollabNode = this._children[index];\n    // Update\n    const nextChildNode = $getNodeByKeyOrThrow(key);\n    if (childCollabNode instanceof CollabElementNode && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(nextChildNode)) {\n      childCollabNode.syncPropertiesFromLexical(binding, nextChildNode, prevNodeMap);\n      childCollabNode.syncChildrenFromLexical(binding, nextChildNode, prevNodeMap, dirtyElements, dirtyLeaves);\n    } else if (childCollabNode instanceof CollabTextNode && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextChildNode)) {\n      childCollabNode.syncPropertiesAndTextFromLexical(binding, nextChildNode, prevNodeMap);\n    } else if (childCollabNode instanceof CollabDecoratorNode && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(nextChildNode)) {\n      childCollabNode.syncPropertiesFromLexical(binding, nextChildNode, prevNodeMap);\n    }\n  }\n  syncChildrenFromLexical(binding, nextLexicalNode, prevNodeMap, dirtyElements, dirtyLeaves) {\n    const prevLexicalNode = this.getPrevNode(prevNodeMap);\n    const prevChildren = prevLexicalNode === null ? [] : (0,_lexical_offset__WEBPACK_IMPORTED_MODULE_2__.$createChildrenArray)(prevLexicalNode, prevNodeMap);\n    const nextChildren = (0,_lexical_offset__WEBPACK_IMPORTED_MODULE_2__.$createChildrenArray)(nextLexicalNode, null);\n    const prevEndIndex = prevChildren.length - 1;\n    const nextEndIndex = nextChildren.length - 1;\n    const collabNodeMap = binding.collabNodeMap;\n    let prevChildrenSet;\n    let nextChildrenSet;\n    let prevIndex = 0;\n    let nextIndex = 0;\n    while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n      const prevKey = prevChildren[prevIndex];\n      const nextKey = nextChildren[nextIndex];\n      if (prevKey === nextKey) {\n        // Nove move, create or remove\n        this._syncChildFromLexical(binding, nextIndex, nextKey, prevNodeMap, dirtyElements, dirtyLeaves);\n        prevIndex++;\n        nextIndex++;\n      } else {\n        if (prevChildrenSet === undefined) {\n          prevChildrenSet = new Set(prevChildren);\n        }\n        if (nextChildrenSet === undefined) {\n          nextChildrenSet = new Set(nextChildren);\n        }\n        const nextHasPrevKey = nextChildrenSet.has(prevKey);\n        const prevHasNextKey = prevChildrenSet.has(nextKey);\n        if (!nextHasPrevKey) {\n          // Remove\n          this.splice(binding, nextIndex, 1);\n          prevIndex++;\n        } else {\n          // Create or replace\n          const nextChildNode = $getNodeByKeyOrThrow(nextKey);\n          const collabNode = $createCollabNodeFromLexicalNode(binding, nextChildNode, this);\n          collabNodeMap.set(nextKey, collabNode);\n          if (prevHasNextKey) {\n            this.splice(binding, nextIndex, 1, collabNode);\n            prevIndex++;\n            nextIndex++;\n          } else {\n            this.splice(binding, nextIndex, 0, collabNode);\n            nextIndex++;\n          }\n        }\n      }\n    }\n    const appendNewChildren = prevIndex > prevEndIndex;\n    const removeOldChildren = nextIndex > nextEndIndex;\n    if (appendNewChildren && !removeOldChildren) {\n      for (; nextIndex <= nextEndIndex; ++nextIndex) {\n        const key = nextChildren[nextIndex];\n        const nextChildNode = $getNodeByKeyOrThrow(key);\n        const collabNode = $createCollabNodeFromLexicalNode(binding, nextChildNode, this);\n        this.append(collabNode);\n        collabNodeMap.set(key, collabNode);\n      }\n    } else if (removeOldChildren && !appendNewChildren) {\n      for (let i = this._children.length - 1; i >= nextIndex; i--) {\n        this.splice(binding, i, 1);\n      }\n    }\n  }\n  append(collabNode) {\n    const xmlText = this._xmlText;\n    const children = this._children;\n    const lastChild = children[children.length - 1];\n    const offset = lastChild !== undefined ? lastChild.getOffset() + lastChild.getSize() : 0;\n    if (collabNode instanceof CollabElementNode) {\n      xmlText.insertEmbed(offset, collabNode._xmlText);\n    } else if (collabNode instanceof CollabTextNode) {\n      const map = collabNode._map;\n      if (map.parent === null) {\n        xmlText.insertEmbed(offset, map);\n      }\n      xmlText.insert(offset + 1, collabNode._text);\n    } else if (collabNode instanceof CollabLineBreakNode) {\n      xmlText.insertEmbed(offset, collabNode._map);\n    } else if (collabNode instanceof CollabDecoratorNode) {\n      xmlText.insertEmbed(offset, collabNode._xmlElem);\n    }\n    this._children.push(collabNode);\n  }\n  splice(binding, index, delCount, collabNode) {\n    const children = this._children;\n    const child = children[index];\n    if (child === undefined) {\n      if (!(collabNode !== undefined)) {\n        throw Error(`splice: could not find collab element node`);\n      }\n      this.append(collabNode);\n      return;\n    }\n    const offset = child.getOffset();\n    if (!(offset !== -1)) {\n      throw Error(`splice: expected offset to be greater than zero`);\n    }\n    const xmlText = this._xmlText;\n    if (delCount !== 0) {\n      // What if we delete many nodes, don't we need to get all their\n      // sizes?\n      xmlText.delete(offset, child.getSize());\n    }\n    if (collabNode instanceof CollabElementNode) {\n      xmlText.insertEmbed(offset, collabNode._xmlText);\n    } else if (collabNode instanceof CollabTextNode) {\n      const map = collabNode._map;\n      if (map.parent === null) {\n        xmlText.insertEmbed(offset, map);\n      }\n      xmlText.insert(offset + 1, collabNode._text);\n    } else if (collabNode instanceof CollabLineBreakNode) {\n      xmlText.insertEmbed(offset, collabNode._map);\n    } else if (collabNode instanceof CollabDecoratorNode) {\n      xmlText.insertEmbed(offset, collabNode._xmlElem);\n    }\n    if (delCount !== 0) {\n      const childrenToDelete = children.slice(index, index + delCount);\n      for (let i = 0; i < childrenToDelete.length; i++) {\n        childrenToDelete[i].destroy(binding);\n      }\n    }\n    if (collabNode !== undefined) {\n      children.splice(index, delCount, collabNode);\n    } else {\n      children.splice(index, delCount);\n    }\n  }\n  getChildOffset(collabNode) {\n    let offset = 0;\n    const children = this._children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child === collabNode) {\n        return offset;\n      }\n      offset += child.getSize();\n    }\n    return -1;\n  }\n  destroy(binding) {\n    const collabNodeMap = binding.collabNodeMap;\n    const children = this._children;\n    for (let i = 0; i < children.length; i++) {\n      children[i].destroy(binding);\n    }\n    collabNodeMap.delete(this._key);\n  }\n}\nfunction $createCollabElementNode(xmlText, parent, type) {\n  const collabNode = new CollabElementNode(xmlText, parent, type);\n  xmlText._collabNode = collabNode;\n  return collabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createBinding(editor, provider, id, doc, docMap, excludedProperties) {\n  if (!(doc !== undefined && doc !== null)) {\n    throw Error(`createBinding: doc is null or undefined`);\n  }\n  const rootXmlText = doc.get('root', yjs__WEBPACK_IMPORTED_MODULE_1__.XmlText);\n  const root = $createCollabElementNode(rootXmlText, null, 'root');\n  root._key = 'root';\n  return {\n    clientID: doc.clientID,\n    collabNodeMap: new Map(),\n    cursors: new Map(),\n    cursorsContainer: null,\n    doc,\n    docMap,\n    editor,\n    excludedProperties: excludedProperties || new Map(),\n    id,\n    nodeProperties: new Map(),\n    root\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createRelativePosition(point, binding) {\n  const collabNodeMap = binding.collabNodeMap;\n  const collabNode = collabNodeMap.get(point.key);\n  if (collabNode === undefined) {\n    return null;\n  }\n  let offset = point.offset;\n  let sharedType = collabNode.getSharedType();\n  if (collabNode instanceof CollabTextNode) {\n    sharedType = collabNode._parent._xmlText;\n    const currentOffset = collabNode.getOffset();\n    if (currentOffset === -1) {\n      return null;\n    }\n    offset = currentOffset + 1 + offset;\n  } else if (collabNode instanceof CollabElementNode && point.type === 'element') {\n    const parent = point.getNode();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(parent)) {\n      throw Error(`Element point must be an element node`);\n    }\n    let accumulatedOffset = 0;\n    let i = 0;\n    let node = parent.getFirstChild();\n    while (node !== null && i++ < offset) {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n        accumulatedOffset += node.getTextContentSize() + 1;\n      } else {\n        accumulatedOffset++;\n      }\n      node = node.getNextSibling();\n    }\n    offset = accumulatedOffset;\n  }\n  return (0,yjs__WEBPACK_IMPORTED_MODULE_1__.createRelativePositionFromTypeIndex)(sharedType, offset);\n}\nfunction createAbsolutePosition(relativePosition, binding) {\n  return (0,yjs__WEBPACK_IMPORTED_MODULE_1__.createAbsolutePositionFromRelativePosition)(relativePosition, binding.doc);\n}\nfunction shouldUpdatePosition(currentPos, pos) {\n  if (currentPos == null) {\n    if (pos != null) {\n      return true;\n    }\n  } else if (pos == null || !(0,yjs__WEBPACK_IMPORTED_MODULE_1__.compareRelativePositions)(currentPos, pos)) {\n    return true;\n  }\n  return false;\n}\nfunction createCursor(name, color) {\n  return {\n    color: color,\n    name: name,\n    selection: null\n  };\n}\nfunction destroySelection(binding, selection) {\n  const cursorsContainer = binding.cursorsContainer;\n  if (cursorsContainer !== null) {\n    const selections = selection.selections;\n    const selectionsLength = selections.length;\n    for (let i = 0; i < selectionsLength; i++) {\n      cursorsContainer.removeChild(selections[i]);\n    }\n  }\n}\nfunction destroyCursor(binding, cursor) {\n  const selection = cursor.selection;\n  if (selection !== null) {\n    destroySelection(binding, selection);\n  }\n}\nfunction createCursorSelection(cursor, anchorKey, anchorOffset, focusKey, focusOffset) {\n  const color = cursor.color;\n  const caret = document.createElement('span');\n  caret.style.cssText = `position:absolute;top:0;bottom:0;right:-1px;width:1px;background-color:${color};z-index:10;`;\n  const name = document.createElement('span');\n  name.textContent = cursor.name;\n  name.style.cssText = `position:absolute;left:-2px;top:-16px;background-color:${color};color:#fff;line-height:12px;font-size:12px;padding:2px;font-family:Arial;font-weight:bold;white-space:nowrap;`;\n  caret.appendChild(name);\n  return {\n    anchor: {\n      key: anchorKey,\n      offset: anchorOffset\n    },\n    caret,\n    color,\n    focus: {\n      key: focusKey,\n      offset: focusOffset\n    },\n    name,\n    selections: []\n  };\n}\nfunction updateCursor(binding, cursor, nextSelection, nodeMap) {\n  const editor = binding.editor;\n  const rootElement = editor.getRootElement();\n  const cursorsContainer = binding.cursorsContainer;\n  if (cursorsContainer === null || rootElement === null) {\n    return;\n  }\n  const cursorsContainerOffsetParent = cursorsContainer.offsetParent;\n  if (cursorsContainerOffsetParent === null) {\n    return;\n  }\n  const containerRect = cursorsContainerOffsetParent.getBoundingClientRect();\n  const prevSelection = cursor.selection;\n  if (nextSelection === null) {\n    if (prevSelection === null) {\n      return;\n    } else {\n      cursor.selection = null;\n      destroySelection(binding, prevSelection);\n      return;\n    }\n  } else {\n    cursor.selection = nextSelection;\n  }\n  const caret = nextSelection.caret;\n  const color = nextSelection.color;\n  const selections = nextSelection.selections;\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorNode = nodeMap.get(anchorKey);\n  const focusNode = nodeMap.get(focusKey);\n  if (anchorNode == null || focusNode == null) {\n    return;\n  }\n  let selectionRects;\n\n  // In the case of a collapsed selection on a linebreak, we need\n  // to improvise as the browser will return nothing here as <br>\n  // apparantly take up no visual space :/\n  // This won't work in all cases, but it's better than just showing\n  // nothing all the time.\n  if (anchorNode === focusNode && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(anchorNode)) {\n    const brRect = editor.getElementByKey(anchorKey).getBoundingClientRect();\n    selectionRects = [brRect];\n  } else {\n    const range = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.createDOMRange)(editor, anchorNode, anchor.offset, focusNode, focus.offset);\n    if (range === null) {\n      return;\n    }\n    selectionRects = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.createRectsFromDOMRange)(editor, range);\n  }\n  const selectionsLength = selections.length;\n  const selectionRectsLength = selectionRects.length;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    let selection = selections[i];\n    if (selection === undefined) {\n      selection = document.createElement('span');\n      selections[i] = selection;\n      const selectionBg = document.createElement('span');\n      selection.appendChild(selectionBg);\n      cursorsContainer.appendChild(selection);\n    }\n    const top = selectionRect.top - containerRect.top;\n    const left = selectionRect.left - containerRect.left;\n    const style = `position:absolute;top:${top}px;left:${left}px;height:${selectionRect.height}px;width:${selectionRect.width}px;pointer-events:none;z-index:5;`;\n    selection.style.cssText = style;\n    selection.firstChild.style.cssText = `${style}left:0;top:0;background-color:${color};opacity:0.3;`;\n    if (i === selectionRectsLength - 1) {\n      if (caret.parentNode !== selection) {\n        selection.appendChild(caret);\n      }\n    }\n  }\n  for (let i = selectionsLength - 1; i >= selectionRectsLength; i--) {\n    const selection = selections[i];\n    cursorsContainer.removeChild(selection);\n    selections.pop();\n  }\n}\nfunction $syncLocalCursorPosition(binding, provider) {\n  const awareness = provider.awareness;\n  const localState = awareness.getLocalState();\n  if (localState === null) {\n    return;\n  }\n  const anchorPos = localState.anchorPos;\n  const focusPos = localState.focusPos;\n  if (anchorPos !== null && focusPos !== null) {\n    const anchorAbsPos = createAbsolutePosition(anchorPos, binding);\n    const focusAbsPos = createAbsolutePosition(focusPos, binding);\n    if (anchorAbsPos !== null && focusAbsPos !== null) {\n      const [anchorCollabNode, anchorOffset] = getCollabNodeAndOffset(anchorAbsPos.type, anchorAbsPos.index);\n      const [focusCollabNode, focusOffset] = getCollabNodeAndOffset(focusAbsPos.type, focusAbsPos.index);\n      if (anchorCollabNode !== null && focusCollabNode !== null) {\n        const anchorKey = anchorCollabNode.getKey();\n        const focusKey = focusCollabNode.getKey();\n        const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n        if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n          return;\n        }\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        $setPoint(anchor, anchorKey, anchorOffset);\n        $setPoint(focus, focusKey, focusOffset);\n      }\n    }\n  }\n}\nfunction $setPoint(point, key, offset) {\n  if (point.key !== key || point.offset !== offset) {\n    let anchorNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(key);\n    if (anchorNode !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(anchorNode) && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n      const parent = anchorNode.getParentOrThrow();\n      key = parent.getKey();\n      offset = anchorNode.getIndexWithinParent();\n      anchorNode = parent;\n    }\n    point.set(key, offset, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(anchorNode) ? 'element' : 'text');\n  }\n}\nfunction getCollabNodeAndOffset(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nsharedType, offset) {\n  const collabNode = sharedType._collabNode;\n  if (collabNode === undefined) {\n    return [null, 0];\n  }\n  if (collabNode instanceof CollabElementNode) {\n    const {\n      node,\n      offset: collabNodeOffset\n    } = getPositionFromElementAndOffset(collabNode, offset, true);\n    if (node === null) {\n      return [collabNode, 0];\n    } else {\n      return [node, collabNodeOffset];\n    }\n  }\n  return [null, 0];\n}\nfunction syncCursorPositions(binding, provider) {\n  const awarenessStates = Array.from(provider.awareness.getStates());\n  const localClientID = binding.clientID;\n  const cursors = binding.cursors;\n  const editor = binding.editor;\n  const nodeMap = editor._editorState._nodeMap;\n  const visitedClientIDs = new Set();\n  for (let i = 0; i < awarenessStates.length; i++) {\n    const awarenessState = awarenessStates[i];\n    const [clientID, awareness] = awarenessState;\n    if (clientID !== localClientID) {\n      visitedClientIDs.add(clientID);\n      const {\n        anchorPos,\n        focusPos,\n        name,\n        color,\n        focusing\n      } = awareness;\n      let selection = null;\n      let cursor = cursors.get(clientID);\n      if (cursor === undefined) {\n        cursor = createCursor(name, color);\n        cursors.set(clientID, cursor);\n      }\n      if (anchorPos !== null && focusPos !== null && focusing) {\n        const anchorAbsPos = createAbsolutePosition(anchorPos, binding);\n        const focusAbsPos = createAbsolutePosition(focusPos, binding);\n        if (anchorAbsPos !== null && focusAbsPos !== null) {\n          const [anchorCollabNode, anchorOffset] = getCollabNodeAndOffset(anchorAbsPos.type, anchorAbsPos.index);\n          const [focusCollabNode, focusOffset] = getCollabNodeAndOffset(focusAbsPos.type, focusAbsPos.index);\n          if (anchorCollabNode !== null && focusCollabNode !== null) {\n            const anchorKey = anchorCollabNode.getKey();\n            const focusKey = focusCollabNode.getKey();\n            selection = cursor.selection;\n            if (selection === null) {\n              selection = createCursorSelection(cursor, anchorKey, anchorOffset, focusKey, focusOffset);\n            } else {\n              const anchor = selection.anchor;\n              const focus = selection.focus;\n              anchor.key = anchorKey;\n              anchor.offset = anchorOffset;\n              focus.key = focusKey;\n              focus.offset = focusOffset;\n            }\n          }\n        }\n      }\n      updateCursor(binding, cursor, selection, nodeMap);\n    }\n  }\n  const allClientIDs = Array.from(cursors.keys());\n  for (let i = 0; i < allClientIDs.length; i++) {\n    const clientID = allClientIDs[i];\n    if (!visitedClientIDs.has(clientID)) {\n      const cursor = cursors.get(clientID);\n      if (cursor !== undefined) {\n        destroyCursor(binding, cursor);\n        cursors.delete(clientID);\n      }\n    }\n  }\n}\nfunction syncLexicalSelectionToYjs(binding, provider, prevSelection, nextSelection) {\n  const awareness = provider.awareness;\n  const localState = awareness.getLocalState();\n  if (localState === null) {\n    return;\n  }\n  const {\n    anchorPos: currentAnchorPos,\n    focusPos: currentFocusPos,\n    name,\n    color,\n    focusing,\n    awarenessData\n  } = localState;\n  let anchorPos = null;\n  let focusPos = null;\n  if (nextSelection === null || currentAnchorPos !== null && !nextSelection.is(prevSelection)) {\n    if (prevSelection === null) {\n      return;\n    }\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(nextSelection)) {\n    anchorPos = createRelativePosition(nextSelection.anchor, binding);\n    focusPos = createRelativePosition(nextSelection.focus, binding);\n  }\n  if (shouldUpdatePosition(currentAnchorPos, anchorPos) || shouldUpdatePosition(currentFocusPos, focusPos)) {\n    awareness.setLocalState({\n      anchorPos,\n      awarenessData,\n      color,\n      focusPos,\n      focusing,\n      name\n    });\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction $syncEvent(binding, event) {\n  const {\n    target\n  } = event;\n  const collabNode = $getOrInitCollabNodeFromSharedType(binding, target);\n  if (collabNode instanceof CollabElementNode && event instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.YTextEvent) {\n    // @ts-expect-error We need to access the private property of the class\n    const {\n      keysChanged,\n      childListChanged,\n      delta\n    } = event;\n\n    // Update\n    if (keysChanged.size > 0) {\n      collabNode.syncPropertiesFromYjs(binding, keysChanged);\n    }\n    if (childListChanged) {\n      collabNode.applyChildrenYjsDelta(binding, delta);\n      collabNode.syncChildrenFromYjs(binding);\n    }\n  } else if (collabNode instanceof CollabTextNode && event instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.YMapEvent) {\n    const {\n      keysChanged\n    } = event;\n\n    // Update\n    if (keysChanged.size > 0) {\n      collabNode.syncPropertiesAndTextFromYjs(binding, keysChanged);\n    }\n  } else if (collabNode instanceof CollabDecoratorNode && event instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.YXmlEvent) {\n    const {\n      attributesChanged\n    } = event;\n\n    // Update\n    if (attributesChanged.size > 0) {\n      collabNode.syncPropertiesFromYjs(binding, attributesChanged);\n    }\n  } else {\n    {\n      throw Error(`Expected text, element, or decorator event`);\n    }\n  }\n}\nfunction syncYjsChangesToLexical(binding, provider, events, isFromUndoManger) {\n  const editor = binding.editor;\n  const currentEditorState = editor._editorState;\n\n  // This line precompute the delta before editor update. The reason is\n  // delta is computed when it is accessed. Note that this can only be\n  // safely computed during the event call. If it is accessed after event\n  // call it might result in unexpected behavior.\n  // https://github.com/yjs/yjs/blob/00ef472d68545cb260abd35c2de4b3b78719c9e4/src/utils/YEvent.js#L132\n  events.forEach(event => event.delta);\n  editor.update(() => {\n    for (let i = 0; i < events.length; i++) {\n      const event = events[i];\n      $syncEvent(binding, event);\n    }\n    // If there was a collision on the top level paragraph\n    // we need to re-add a paragraph\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)().getChildrenSize() === 0) {\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)().append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      if (doesSelectionNeedRecovering(selection)) {\n        const prevSelection = currentEditorState._selection;\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection)) {\n          $syncLocalCursorPosition(binding, provider);\n          if (doesSelectionNeedRecovering(selection)) {\n            // If the selected node is deleted, move the selection to the previous or parent node.\n            const anchorNodeKey = selection.anchor.key;\n            $moveSelectionToPreviousNode(anchorNodeKey, currentEditorState);\n          }\n        }\n        syncLexicalSelectionToYjs(binding, provider, prevSelection, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)());\n      } else {\n        $syncLocalCursorPosition(binding, provider);\n      }\n    }\n  }, {\n    onUpdate: () => {\n      syncCursorPositions(binding, provider);\n    },\n    skipTransforms: true,\n    tag: isFromUndoManger ? 'historic' : 'collaboration'\n  });\n}\nfunction $handleNormalizationMergeConflicts(binding, normalizedNodes) {\n  // We handle the merge operations here\n  const normalizedNodesKeys = Array.from(normalizedNodes);\n  const collabNodeMap = binding.collabNodeMap;\n  const mergedNodes = [];\n  for (let i = 0; i < normalizedNodesKeys.length; i++) {\n    const nodeKey = normalizedNodesKeys[i];\n    const lexicalNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(nodeKey);\n    const collabNode = collabNodeMap.get(nodeKey);\n    if (collabNode instanceof CollabTextNode) {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(lexicalNode)) {\n        // We mutate the text collab nodes after removing\n        // all the dead nodes first, otherwise offsets break.\n        mergedNodes.push([collabNode, lexicalNode.__text]);\n      } else {\n        const offset = collabNode.getOffset();\n        if (offset === -1) {\n          continue;\n        }\n        const parent = collabNode._parent;\n        collabNode._normalized = true;\n        parent._xmlText.delete(offset, 1);\n        collabNodeMap.delete(nodeKey);\n        const parentChildren = parent._children;\n        const index = parentChildren.indexOf(collabNode);\n        parentChildren.splice(index, 1);\n      }\n    }\n  }\n  for (let i = 0; i < mergedNodes.length; i++) {\n    const [collabNode, text] = mergedNodes[i];\n    if (collabNode instanceof CollabTextNode && typeof text === 'string') {\n      collabNode._text = text;\n    }\n  }\n}\nfunction syncLexicalUpdateToYjs(binding, provider, prevEditorState, currEditorState, dirtyElements, dirtyLeaves, normalizedNodes, tags) {\n  syncWithTransaction(binding, () => {\n    currEditorState.read(() => {\n      // We check if the update has come from a origin where the origin\n      // was the collaboration binding previously. This can help us\n      // prevent unnecessarily re-diffing and possible re-applying\n      // the same change editor state again. For example, if a user\n      // types a character and we get it, we don't want to then insert\n      // the same character again. The exception to this heuristic is\n      // when we need to handle normalization merge conflicts.\n      if (tags.has('collaboration') || tags.has('historic')) {\n        if (normalizedNodes.size > 0) {\n          $handleNormalizationMergeConflicts(binding, normalizedNodes);\n        }\n        return;\n      }\n      if (dirtyElements.has('root')) {\n        const prevNodeMap = prevEditorState._nodeMap;\n        const nextLexicalRoot = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n        const collabRoot = binding.root;\n        collabRoot.syncPropertiesFromLexical(binding, nextLexicalRoot, prevNodeMap);\n        collabRoot.syncChildrenFromLexical(binding, nextLexicalRoot, prevNodeMap, dirtyElements, dirtyLeaves);\n      }\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      const prevSelection = prevEditorState._selection;\n      syncLexicalSelectionToYjs(binding, provider, prevSelection, selection);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CONNECTED_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('CONNECTED_COMMAND');\nconst TOGGLE_CONNECT_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('TOGGLE_CONNECT_COMMAND');\nfunction createUndoManager(binding, root) {\n  return new yjs__WEBPACK_IMPORTED_MODULE_1__.UndoManager(root, {\n    trackedOrigins: new Set([binding, null])\n  });\n}\nfunction initLocalState(provider, name, color, focusing, awarenessData) {\n  provider.awareness.setLocalState({\n    anchorPos: null,\n    awarenessData,\n    color,\n    focusPos: null,\n    focusing: focusing,\n    name\n  });\n}\nfunction setLocalStateFocus(provider, name, color, focusing, awarenessData) {\n  const {\n    awareness\n  } = provider;\n  let localState = awareness.getLocalState();\n  if (localState === null) {\n    localState = {\n      anchorPos: null,\n      awarenessData,\n      color,\n      focusPos: null,\n      focusing: focusing,\n      name\n    };\n  }\n  localState.focusing = focusing;\n  awareness.setLocalState(localState);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwveWpzL0xleGljYWxZanMuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFOO0FBQ0U7QUFDaEs7QUFDc0I7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0RBQWE7QUFDOUIsV0FBVyx5REFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isc0RBQWE7QUFDakM7QUFDQSxNQUFNLDBEQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0RBQVc7QUFDdEI7QUFDQTtBQUNBLGlCQUFpQixzREFBYTtBQUM5QixXQUFXLG9EQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTs7QUFFQSwwQkFBMEIsc0RBQWE7QUFDdkMsK0JBQStCLHNEQUFhO0FBQzVDO0FBQ0EsYUFBYSw0Q0FBVztBQUN4QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXZlZG9jcy8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC95anMvTGV4aWNhbFlqcy5kZXYubWpzPzFhNGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkZ2V0Tm9kZUJ5S2V5LCAkaXNMaW5lQnJlYWtOb2RlLCAkaXNUZXh0Tm9kZSwgJGdldFNlbGVjdGlvbiwgJGlzUmFuZ2VTZWxlY3Rpb24sIGNyZWF0ZUVkaXRvciwgJGdldFJvb3QsICRpc0VsZW1lbnROb2RlLCAkaXNSb290Tm9kZSwgJGlzRGVjb3JhdG9yTm9kZSwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsIGNyZWF0ZUNvbW1hbmQgfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCB7IFhtbFRleHQsIE1hcCBhcyBNYXAkMSwgWG1sRWxlbWVudCwgRG9jLCBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24sIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4LCBjb21wYXJlUmVsYXRpdmVQb3NpdGlvbnMsIFlUZXh0RXZlbnQsIFlNYXBFdmVudCwgWVhtbEV2ZW50LCBVbmRvTWFuYWdlciB9IGZyb20gJ3lqcyc7XG5pbXBvcnQgeyAkY3JlYXRlQ2hpbGRyZW5BcnJheSB9IGZyb20gJ0BsZXhpY2FsL29mZnNldCc7XG5pbXBvcnQgeyBjcmVhdGVET01SYW5nZSwgY3JlYXRlUmVjdHNGcm9tRE9NUmFuZ2UgfSBmcm9tICdAbGV4aWNhbC9zZWxlY3Rpb24nO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNsYXNzIENvbGxhYkxpbmVCcmVha05vZGUge1xuICBjb25zdHJ1Y3RvcihtYXAsIHBhcmVudCkge1xuICAgIHRoaXMuX2tleSA9ICcnO1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fdHlwZSA9ICdsaW5lYnJlYWsnO1xuICB9XG4gIGdldE5vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRnZXROb2RlQnlLZXkodGhpcy5fa2V5KTtcbiAgICByZXR1cm4gJGlzTGluZUJyZWFrTm9kZShub2RlKSA/IG5vZGUgOiBudWxsO1xuICB9XG4gIGdldEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5O1xuICB9XG4gIGdldFNoYXJlZFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcDtcbiAgfVxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl90eXBlO1xuICB9XG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IGNvbGxhYkVsZW1lbnROb2RlID0gdGhpcy5fcGFyZW50O1xuICAgIHJldHVybiBjb2xsYWJFbGVtZW50Tm9kZS5nZXRDaGlsZE9mZnNldCh0aGlzKTtcbiAgfVxuICBkZXN0cm95KGJpbmRpbmcpIHtcbiAgICBjb25zdCBjb2xsYWJOb2RlTWFwID0gYmluZGluZy5jb2xsYWJOb2RlTWFwO1xuICAgIGNvbGxhYk5vZGVNYXAuZGVsZXRlKHRoaXMuX2tleSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRjcmVhdGVDb2xsYWJMaW5lQnJlYWtOb2RlKG1hcCwgcGFyZW50KSB7XG4gIGNvbnN0IGNvbGxhYk5vZGUgPSBuZXcgQ29sbGFiTGluZUJyZWFrTm9kZShtYXAsIHBhcmVudCk7XG4gIG1hcC5fY29sbGFiTm9kZSA9IGNvbGxhYk5vZGU7XG4gIHJldHVybiBjb2xsYWJOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHNpbXBsZURpZmZXaXRoQ3Vyc29yKGEsIGIsIGN1cnNvcikge1xuICBjb25zdCBhTGVuZ3RoID0gYS5sZW5ndGg7XG4gIGNvbnN0IGJMZW5ndGggPSBiLmxlbmd0aDtcbiAgbGV0IGxlZnQgPSAwOyAvLyBudW1iZXIgb2Ygc2FtZSBjaGFyYWN0ZXJzIGNvdW50aW5nIGZyb20gbGVmdFxuICBsZXQgcmlnaHQgPSAwOyAvLyBudW1iZXIgb2Ygc2FtZSBjaGFyYWN0ZXJzIGNvdW50aW5nIGZyb20gcmlnaHRcbiAgLy8gSXRlcmF0ZSBsZWZ0IHRvIHRoZSByaWdodCB1bnRpbCB3ZSBmaW5kIGEgY2hhbmdlZCBjaGFyYWN0ZXJcbiAgLy8gRmlyc3QgaXRlcmF0aW9uIGNvbnNpZGVycyB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb25cbiAgd2hpbGUgKGxlZnQgPCBhTGVuZ3RoICYmIGxlZnQgPCBiTGVuZ3RoICYmIGFbbGVmdF0gPT09IGJbbGVmdF0gJiYgbGVmdCA8IGN1cnNvcikge1xuICAgIGxlZnQrKztcbiAgfVxuICAvLyBJdGVyYXRlIHJpZ2h0IHRvIHRoZSBsZWZ0IHVudGlsIHdlIGZpbmQgYSBjaGFuZ2VkIGNoYXJhY3RlclxuICB3aGlsZSAocmlnaHQgKyBsZWZ0IDwgYUxlbmd0aCAmJiByaWdodCArIGxlZnQgPCBiTGVuZ3RoICYmIGFbYUxlbmd0aCAtIHJpZ2h0IC0gMV0gPT09IGJbYkxlbmd0aCAtIHJpZ2h0IC0gMV0pIHtcbiAgICByaWdodCsrO1xuICB9XG4gIC8vIFRyeSB0byBpdGVyYXRlIGxlZnQgZnVydGhlciB0byB0aGUgcmlnaHQgd2l0aG91dCBjYXJpbmcgYWJvdXQgdGhlIGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uXG4gIHdoaWxlIChyaWdodCArIGxlZnQgPCBhTGVuZ3RoICYmIHJpZ2h0ICsgbGVmdCA8IGJMZW5ndGggJiYgYVtsZWZ0XSA9PT0gYltsZWZ0XSkge1xuICAgIGxlZnQrKztcbiAgfVxuICByZXR1cm4ge1xuICAgIGluZGV4OiBsZWZ0LFxuICAgIGluc2VydDogYi5zbGljZShsZWZ0LCBiTGVuZ3RoIC0gcmlnaHQpLFxuICAgIHJlbW92ZTogYUxlbmd0aCAtIGxlZnQgLSByaWdodFxuICB9O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uICRkaWZmVGV4dENvbnRlbnRBbmRBcHBseURlbHRhKGNvbGxhYk5vZGUsIGtleSwgcHJldlRleHQsIG5leHRUZXh0KSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgbGV0IGN1cnNvck9mZnNldCA9IG5leHRUZXh0Lmxlbmd0aDtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgIGlmIChhbmNob3Iua2V5ID09PSBrZXkpIHtcbiAgICAgIGN1cnNvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRpZmYgPSBzaW1wbGVEaWZmV2l0aEN1cnNvcihwcmV2VGV4dCwgbmV4dFRleHQsIGN1cnNvck9mZnNldCk7XG4gIGNvbGxhYk5vZGUuc3BsaWNlVGV4dChkaWZmLmluZGV4LCBkaWZmLnJlbW92ZSwgZGlmZi5pbnNlcnQpO1xufVxuY2xhc3MgQ29sbGFiVGV4dE5vZGUge1xuICBjb25zdHJ1Y3RvcihtYXAsIHRleHQsIHBhcmVudCwgdHlwZSkge1xuICAgIHRoaXMuX2tleSA9ICcnO1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fdGV4dCA9IHRleHQ7XG4gICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IGZhbHNlO1xuICB9XG4gIGdldFByZXZOb2RlKG5vZGVNYXApIHtcbiAgICBpZiAobm9kZU1hcCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldCh0aGlzLl9rZXkpO1xuICAgIHJldHVybiAkaXNUZXh0Tm9kZShub2RlKSA/IG5vZGUgOiBudWxsO1xuICB9XG4gIGdldE5vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRnZXROb2RlQnlLZXkodGhpcy5fa2V5KTtcbiAgICByZXR1cm4gJGlzVGV4dE5vZGUobm9kZSkgPyBub2RlIDogbnVsbDtcbiAgfVxuICBnZXRTaGFyZWRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXA7XG4gIH1cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgfVxuICBnZXRLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleTtcbiAgfVxuICBnZXRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0Lmxlbmd0aCArICh0aGlzLl9ub3JtYWxpemVkID8gMCA6IDEpO1xuICB9XG4gIGdldE9mZnNldCgpIHtcbiAgICBjb25zdCBjb2xsYWJFbGVtZW50Tm9kZSA9IHRoaXMuX3BhcmVudDtcbiAgICByZXR1cm4gY29sbGFiRWxlbWVudE5vZGUuZ2V0Q2hpbGRPZmZzZXQodGhpcyk7XG4gIH1cbiAgc3BsaWNlVGV4dChpbmRleCwgZGVsQ291bnQsIG5ld1RleHQpIHtcbiAgICBjb25zdCBjb2xsYWJFbGVtZW50Tm9kZSA9IHRoaXMuX3BhcmVudDtcbiAgICBjb25zdCB4bWxUZXh0ID0gY29sbGFiRWxlbWVudE5vZGUuX3htbFRleHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5nZXRPZmZzZXQoKSArIDEgKyBpbmRleDtcbiAgICBpZiAoZGVsQ291bnQgIT09IDApIHtcbiAgICAgIHhtbFRleHQuZGVsZXRlKG9mZnNldCwgZGVsQ291bnQpO1xuICAgIH1cbiAgICBpZiAobmV3VGV4dCAhPT0gJycpIHtcbiAgICAgIHhtbFRleHQuaW5zZXJ0KG9mZnNldCwgbmV3VGV4dCk7XG4gICAgfVxuICB9XG4gIHN5bmNQcm9wZXJ0aWVzQW5kVGV4dEZyb21MZXhpY2FsKGJpbmRpbmcsIG5leHRMZXhpY2FsTm9kZSwgcHJldk5vZGVNYXApIHtcbiAgICBjb25zdCBwcmV2TGV4aWNhbE5vZGUgPSB0aGlzLmdldFByZXZOb2RlKHByZXZOb2RlTWFwKTtcbiAgICBjb25zdCBuZXh0VGV4dCA9IG5leHRMZXhpY2FsTm9kZS5fX3RleHQ7XG4gICAgc3luY1Byb3BlcnRpZXNGcm9tTGV4aWNhbChiaW5kaW5nLCB0aGlzLl9tYXAsIHByZXZMZXhpY2FsTm9kZSwgbmV4dExleGljYWxOb2RlKTtcbiAgICBpZiAocHJldkxleGljYWxOb2RlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcmV2VGV4dCA9IHByZXZMZXhpY2FsTm9kZS5fX3RleHQ7XG4gICAgICBpZiAocHJldlRleHQgIT09IG5leHRUZXh0KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG5leHRMZXhpY2FsTm9kZS5fX2tleTtcbiAgICAgICAgJGRpZmZUZXh0Q29udGVudEFuZEFwcGx5RGVsdGEodGhpcywga2V5LCBwcmV2VGV4dCwgbmV4dFRleHQpO1xuICAgICAgICB0aGlzLl90ZXh0ID0gbmV4dFRleHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN5bmNQcm9wZXJ0aWVzQW5kVGV4dEZyb21ZanMoYmluZGluZywga2V5c0NoYW5nZWQpIHtcbiAgICBjb25zdCBsZXhpY2FsTm9kZSA9IHRoaXMuZ2V0Tm9kZSgpO1xuICAgIGlmICghKGxleGljYWxOb2RlICE9PSBudWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYHN5bmNQcm9wZXJ0aWVzQW5kVGV4dEZyb21ZanM6IGNvdWxkIG5vdCBmaW5kIGRlY29yYXRvciBub2RlYCk7XG4gICAgfVxuICAgIHN5bmNQcm9wZXJ0aWVzRnJvbVlqcyhiaW5kaW5nLCB0aGlzLl9tYXAsIGxleGljYWxOb2RlLCBrZXlzQ2hhbmdlZCk7XG4gICAgY29uc3QgY29sbGFiVGV4dCA9IHRoaXMuX3RleHQ7XG4gICAgaWYgKGxleGljYWxOb2RlLl9fdGV4dCAhPT0gY29sbGFiVGV4dCkge1xuICAgICAgY29uc3Qgd3JpdGFibGUgPSBsZXhpY2FsTm9kZS5nZXRXcml0YWJsZSgpO1xuICAgICAgd3JpdGFibGUuX190ZXh0ID0gY29sbGFiVGV4dDtcbiAgICB9XG4gIH1cbiAgZGVzdHJveShiaW5kaW5nKSB7XG4gICAgY29uc3QgY29sbGFiTm9kZU1hcCA9IGJpbmRpbmcuY29sbGFiTm9kZU1hcDtcbiAgICBjb2xsYWJOb2RlTWFwLmRlbGV0ZSh0aGlzLl9rZXkpO1xuICB9XG59XG5mdW5jdGlvbiAkY3JlYXRlQ29sbGFiVGV4dE5vZGUobWFwLCB0ZXh0LCBwYXJlbnQsIHR5cGUpIHtcbiAgY29uc3QgY29sbGFiTm9kZSA9IG5ldyBDb2xsYWJUZXh0Tm9kZShtYXAsIHRleHQsIHBhcmVudCwgdHlwZSk7XG4gIG1hcC5fY29sbGFiTm9kZSA9IGNvbGxhYk5vZGU7XG4gIHJldHVybiBjb2xsYWJOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IGJhc2VFeGNsdWRlZFByb3BlcnRpZXMgPSBuZXcgU2V0KFsnX19rZXknLCAnX19wYXJlbnQnLCAnX19uZXh0JywgJ19fcHJldiddKTtcbmNvbnN0IGVsZW1lbnRFeGNsdWRlZFByb3BlcnRpZXMgPSBuZXcgU2V0KFsnX19maXJzdCcsICdfX2xhc3QnLCAnX19zaXplJ10pO1xuY29uc3Qgcm9vdEV4Y2x1ZGVkUHJvcGVydGllcyA9IG5ldyBTZXQoWydfX2NhY2hlZFRleHQnXSk7XG5jb25zdCB0ZXh0RXhjbHVkZWRQcm9wZXJ0aWVzID0gbmV3IFNldChbJ19fdGV4dCddKTtcbmZ1bmN0aW9uIGlzRXhjbHVkZWRQcm9wZXJ0eShuYW1lLCBub2RlLCBiaW5kaW5nKSB7XG4gIGlmIChiYXNlRXhjbHVkZWRQcm9wZXJ0aWVzLmhhcyhuYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgIGlmICh0ZXh0RXhjbHVkZWRQcm9wZXJ0aWVzLmhhcyhuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgaWYgKGVsZW1lbnRFeGNsdWRlZFByb3BlcnRpZXMuaGFzKG5hbWUpIHx8ICRpc1Jvb3ROb2RlKG5vZGUpICYmIHJvb3RFeGNsdWRlZFByb3BlcnRpZXMuaGFzKG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgbm9kZUtsYXNzID0gbm9kZS5jb25zdHJ1Y3RvcjtcbiAgY29uc3QgZXhjbHVkZWRQcm9wZXJ0aWVzID0gYmluZGluZy5leGNsdWRlZFByb3BlcnRpZXMuZ2V0KG5vZGVLbGFzcyk7XG4gIHJldHVybiBleGNsdWRlZFByb3BlcnRpZXMgIT0gbnVsbCAmJiBleGNsdWRlZFByb3BlcnRpZXMuaGFzKG5hbWUpO1xufVxuZnVuY3Rpb24gJGdldE5vZGVCeUtleU9yVGhyb3coa2V5KSB7XG4gIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KGtleSk7XG4gIGlmICghKG5vZGUgIT09IG51bGwpKSB7XG4gICAgdGhyb3cgRXJyb3IoYGNvdWxkIG5vdCBmaW5kIG5vZGUgYnkga2V5YCk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiAkY3JlYXRlQ29sbGFiTm9kZUZyb21MZXhpY2FsTm9kZShiaW5kaW5nLCBsZXhpY2FsTm9kZSwgcGFyZW50KSB7XG4gIGNvbnN0IG5vZGVUeXBlID0gbGV4aWNhbE5vZGUuX190eXBlO1xuICBsZXQgY29sbGFiTm9kZTtcbiAgaWYgKCRpc0VsZW1lbnROb2RlKGxleGljYWxOb2RlKSkge1xuICAgIGNvbnN0IHhtbFRleHQgPSBuZXcgWG1sVGV4dCgpO1xuICAgIGNvbGxhYk5vZGUgPSAkY3JlYXRlQ29sbGFiRWxlbWVudE5vZGUoeG1sVGV4dCwgcGFyZW50LCBub2RlVHlwZSk7XG4gICAgY29sbGFiTm9kZS5zeW5jUHJvcGVydGllc0Zyb21MZXhpY2FsKGJpbmRpbmcsIGxleGljYWxOb2RlLCBudWxsKTtcbiAgICBjb2xsYWJOb2RlLnN5bmNDaGlsZHJlbkZyb21MZXhpY2FsKGJpbmRpbmcsIGxleGljYWxOb2RlLCBudWxsLCBudWxsLCBudWxsKTtcbiAgfSBlbHNlIGlmICgkaXNUZXh0Tm9kZShsZXhpY2FsTm9kZSkpIHtcbiAgICAvLyBUT0RPIGNyZWF0ZSBhIHRva2VuIHRleHQgbm9kZSBmb3IgdG9rZW4sIHNlZ21lbnRlZCBub2Rlcy5cbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwJDEoKTtcbiAgICBjb2xsYWJOb2RlID0gJGNyZWF0ZUNvbGxhYlRleHROb2RlKG1hcCwgbGV4aWNhbE5vZGUuX190ZXh0LCBwYXJlbnQsIG5vZGVUeXBlKTtcbiAgICBjb2xsYWJOb2RlLnN5bmNQcm9wZXJ0aWVzQW5kVGV4dEZyb21MZXhpY2FsKGJpbmRpbmcsIGxleGljYWxOb2RlLCBudWxsKTtcbiAgfSBlbHNlIGlmICgkaXNMaW5lQnJlYWtOb2RlKGxleGljYWxOb2RlKSkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAkMSgpO1xuICAgIG1hcC5zZXQoJ19fdHlwZScsICdsaW5lYnJlYWsnKTtcbiAgICBjb2xsYWJOb2RlID0gJGNyZWF0ZUNvbGxhYkxpbmVCcmVha05vZGUobWFwLCBwYXJlbnQpO1xuICB9IGVsc2UgaWYgKCRpc0RlY29yYXRvck5vZGUobGV4aWNhbE5vZGUpKSB7XG4gICAgY29uc3QgeG1sRWxlbSA9IG5ldyBYbWxFbGVtZW50KCk7XG4gICAgY29sbGFiTm9kZSA9ICRjcmVhdGVDb2xsYWJEZWNvcmF0b3JOb2RlKHhtbEVsZW0sIHBhcmVudCwgbm9kZVR5cGUpO1xuICAgIGNvbGxhYk5vZGUuc3luY1Byb3BlcnRpZXNGcm9tTGV4aWNhbChiaW5kaW5nLCBsZXhpY2FsTm9kZSwgbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRleHQsIGVsZW1lbnQsIGRlY29yYXRvciwgb3IgbGluZWJyZWFrIG5vZGVgKTtcbiAgICB9XG4gIH1cbiAgY29sbGFiTm9kZS5fa2V5ID0gbGV4aWNhbE5vZGUuX19rZXk7XG4gIHJldHVybiBjb2xsYWJOb2RlO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZVR5cGVGcm9tU2hhcmVkVHlwZShzaGFyZWRUeXBlKSB7XG4gIGNvbnN0IHR5cGUgPSBzaGFyZWRUeXBlIGluc3RhbmNlb2YgTWFwJDEgPyBzaGFyZWRUeXBlLmdldCgnX190eXBlJykgOiBzaGFyZWRUeXBlLmdldEF0dHJpYnV0ZSgnX190eXBlJyk7XG4gIGlmICghKHR5cGUgIT0gbnVsbCkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgc2hhcmVkIHR5cGUgdG8gaW5jbHVkZSB0eXBlIGF0dHJpYnV0ZWApO1xuICB9XG4gIHJldHVybiB0eXBlO1xufVxuZnVuY3Rpb24gJGdldE9ySW5pdENvbGxhYk5vZGVGcm9tU2hhcmVkVHlwZShiaW5kaW5nLCBzaGFyZWRUeXBlLCBwYXJlbnQpIHtcbiAgY29uc3QgY29sbGFiTm9kZSA9IHNoYXJlZFR5cGUuX2NvbGxhYk5vZGU7XG4gIGlmIChjb2xsYWJOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCByZWdpc3RlcmVkTm9kZXMgPSBiaW5kaW5nLmVkaXRvci5fbm9kZXM7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlRnJvbVNoYXJlZFR5cGUoc2hhcmVkVHlwZSk7XG4gICAgY29uc3Qgbm9kZUluZm8gPSByZWdpc3RlcmVkTm9kZXMuZ2V0KHR5cGUpO1xuICAgIGlmICghKG5vZGVJbmZvICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgTm9kZSAke3R5cGV9IGlzIG5vdCByZWdpc3RlcmVkYCk7XG4gICAgfVxuICAgIGNvbnN0IHNoYXJlZFBhcmVudCA9IHNoYXJlZFR5cGUucGFyZW50O1xuICAgIGNvbnN0IHRhcmdldFBhcmVudCA9IHBhcmVudCA9PT0gdW5kZWZpbmVkICYmIHNoYXJlZFBhcmVudCAhPT0gbnVsbCA/ICRnZXRPckluaXRDb2xsYWJOb2RlRnJvbVNoYXJlZFR5cGUoYmluZGluZywgc2hhcmVkUGFyZW50KSA6IHBhcmVudCB8fCBudWxsO1xuICAgIGlmICghKHRhcmdldFBhcmVudCBpbnN0YW5jZW9mIENvbGxhYkVsZW1lbnROb2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHBhcmVudCB0byBiZSBhIGNvbGxhYiBlbGVtZW50IG5vZGVgKTtcbiAgICB9XG4gICAgaWYgKHNoYXJlZFR5cGUgaW5zdGFuY2VvZiBYbWxUZXh0KSB7XG4gICAgICByZXR1cm4gJGNyZWF0ZUNvbGxhYkVsZW1lbnROb2RlKHNoYXJlZFR5cGUsIHRhcmdldFBhcmVudCwgdHlwZSk7XG4gICAgfSBlbHNlIGlmIChzaGFyZWRUeXBlIGluc3RhbmNlb2YgTWFwJDEpIHtcbiAgICAgIGlmICh0eXBlID09PSAnbGluZWJyZWFrJykge1xuICAgICAgICByZXR1cm4gJGNyZWF0ZUNvbGxhYkxpbmVCcmVha05vZGUoc2hhcmVkVHlwZSwgdGFyZ2V0UGFyZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAkY3JlYXRlQ29sbGFiVGV4dE5vZGUoc2hhcmVkVHlwZSwgJycsIHRhcmdldFBhcmVudCwgdHlwZSk7XG4gICAgfSBlbHNlIGlmIChzaGFyZWRUeXBlIGluc3RhbmNlb2YgWG1sRWxlbWVudCkge1xuICAgICAgcmV0dXJuICRjcmVhdGVDb2xsYWJEZWNvcmF0b3JOb2RlKHNoYXJlZFR5cGUsIHRhcmdldFBhcmVudCwgdHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb2xsYWJOb2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlTGV4aWNhbE5vZGVGcm9tQ29sbGFiTm9kZShiaW5kaW5nLCBjb2xsYWJOb2RlLCBwYXJlbnRLZXkpIHtcbiAgY29uc3QgdHlwZSA9IGNvbGxhYk5vZGUuZ2V0VHlwZSgpO1xuICBjb25zdCByZWdpc3RlcmVkTm9kZXMgPSBiaW5kaW5nLmVkaXRvci5fbm9kZXM7XG4gIGNvbnN0IG5vZGVJbmZvID0gcmVnaXN0ZXJlZE5vZGVzLmdldCh0eXBlKTtcbiAgaWYgKCEobm9kZUluZm8gIT09IHVuZGVmaW5lZCkpIHtcbiAgICB0aHJvdyBFcnJvcihgTm9kZSAke3R5cGV9IGlzIG5vdCByZWdpc3RlcmVkYCk7XG4gIH1cbiAgY29uc3QgbGV4aWNhbE5vZGUgPSBuZXcgbm9kZUluZm8ua2xhc3MoKTtcbiAgbGV4aWNhbE5vZGUuX19wYXJlbnQgPSBwYXJlbnRLZXk7XG4gIGNvbGxhYk5vZGUuX2tleSA9IGxleGljYWxOb2RlLl9fa2V5O1xuICBpZiAoY29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYkVsZW1lbnROb2RlKSB7XG4gICAgY29uc3QgeG1sVGV4dCA9IGNvbGxhYk5vZGUuX3htbFRleHQ7XG4gICAgY29sbGFiTm9kZS5zeW5jUHJvcGVydGllc0Zyb21ZanMoYmluZGluZywgbnVsbCk7XG4gICAgY29sbGFiTm9kZS5hcHBseUNoaWxkcmVuWWpzRGVsdGEoYmluZGluZywgeG1sVGV4dC50b0RlbHRhKCkpO1xuICAgIGNvbGxhYk5vZGUuc3luY0NoaWxkcmVuRnJvbVlqcyhiaW5kaW5nKTtcbiAgfSBlbHNlIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiVGV4dE5vZGUpIHtcbiAgICBjb2xsYWJOb2RlLnN5bmNQcm9wZXJ0aWVzQW5kVGV4dEZyb21ZanMoYmluZGluZywgbnVsbCk7XG4gIH0gZWxzZSBpZiAoY29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYkRlY29yYXRvck5vZGUpIHtcbiAgICBjb2xsYWJOb2RlLnN5bmNQcm9wZXJ0aWVzRnJvbVlqcyhiaW5kaW5nLCBudWxsKTtcbiAgfVxuICBiaW5kaW5nLmNvbGxhYk5vZGVNYXAuc2V0KGxleGljYWxOb2RlLl9fa2V5LCBjb2xsYWJOb2RlKTtcbiAgcmV0dXJuIGxleGljYWxOb2RlO1xufVxuZnVuY3Rpb24gc3luY1Byb3BlcnRpZXNGcm9tWWpzKGJpbmRpbmcsIHNoYXJlZFR5cGUsIGxleGljYWxOb2RlLCBrZXlzQ2hhbmdlZCkge1xuICBjb25zdCBwcm9wZXJ0aWVzID0ga2V5c0NoYW5nZWQgPT09IG51bGwgPyBzaGFyZWRUeXBlIGluc3RhbmNlb2YgTWFwJDEgPyBBcnJheS5mcm9tKHNoYXJlZFR5cGUua2V5cygpKSA6IE9iamVjdC5rZXlzKHNoYXJlZFR5cGUuZ2V0QXR0cmlidXRlcygpKSA6IEFycmF5LmZyb20oa2V5c0NoYW5nZWQpO1xuICBsZXQgd3JpdGFibGVOb2RlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgaWYgKGlzRXhjbHVkZWRQcm9wZXJ0eShwcm9wZXJ0eSwgbGV4aWNhbE5vZGUsIGJpbmRpbmcpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdCBwcmV2VmFsdWUgPSBsZXhpY2FsTm9kZVtwcm9wZXJ0eV07XG4gICAgbGV0IG5leHRWYWx1ZSA9IHNoYXJlZFR5cGUgaW5zdGFuY2VvZiBNYXAkMSA/IHNoYXJlZFR5cGUuZ2V0KHByb3BlcnR5KSA6IHNoYXJlZFR5cGUuZ2V0QXR0cmlidXRlKHByb3BlcnR5KTtcbiAgICBpZiAocHJldlZhbHVlICE9PSBuZXh0VmFsdWUpIHtcbiAgICAgIGlmIChuZXh0VmFsdWUgaW5zdGFuY2VvZiBEb2MpIHtcbiAgICAgICAgY29uc3QgeWpzRG9jTWFwID0gYmluZGluZy5kb2NNYXA7XG4gICAgICAgIGlmIChwcmV2VmFsdWUgaW5zdGFuY2VvZiBEb2MpIHtcbiAgICAgICAgICB5anNEb2NNYXAuZGVsZXRlKHByZXZWYWx1ZS5ndWlkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXN0ZWRFZGl0b3IgPSBjcmVhdGVFZGl0b3IoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gbmV4dFZhbHVlLmd1aWQ7XG4gICAgICAgIG5lc3RlZEVkaXRvci5fa2V5ID0ga2V5O1xuICAgICAgICB5anNEb2NNYXAuc2V0KGtleSwgbmV4dFZhbHVlKTtcbiAgICAgICAgbmV4dFZhbHVlID0gbmVzdGVkRWRpdG9yO1xuICAgICAgfVxuICAgICAgaWYgKHdyaXRhYmxlTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdyaXRhYmxlTm9kZSA9IGxleGljYWxOb2RlLmdldFdyaXRhYmxlKCk7XG4gICAgICB9XG4gICAgICB3cml0YWJsZU5vZGVbcHJvcGVydHldID0gbmV4dFZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3luY1Byb3BlcnRpZXNGcm9tTGV4aWNhbChiaW5kaW5nLCBzaGFyZWRUeXBlLCBwcmV2TGV4aWNhbE5vZGUsIG5leHRMZXhpY2FsTm9kZSkge1xuICBjb25zdCB0eXBlID0gbmV4dExleGljYWxOb2RlLl9fdHlwZTtcbiAgY29uc3Qgbm9kZVByb3BlcnRpZXMgPSBiaW5kaW5nLm5vZGVQcm9wZXJ0aWVzO1xuICBsZXQgcHJvcGVydGllcyA9IG5vZGVQcm9wZXJ0aWVzLmdldCh0eXBlKTtcbiAgaWYgKHByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhuZXh0TGV4aWNhbE5vZGUpLmZpbHRlcihwcm9wZXJ0eSA9PiB7XG4gICAgICByZXR1cm4gIWlzRXhjbHVkZWRQcm9wZXJ0eShwcm9wZXJ0eSwgbmV4dExleGljYWxOb2RlLCBiaW5kaW5nKTtcbiAgICB9KTtcbiAgICBub2RlUHJvcGVydGllcy5zZXQodHlwZSwgcHJvcGVydGllcyk7XG4gIH1cbiAgY29uc3QgRWRpdG9yQ2xhc3MgPSBiaW5kaW5nLmVkaXRvci5jb25zdHJ1Y3RvcjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgIGNvbnN0IHByZXZWYWx1ZSA9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBwcmV2TGV4aWNhbE5vZGUgPT09IG51bGwgPyB1bmRlZmluZWQgOiBwcmV2TGV4aWNhbE5vZGVbcHJvcGVydHldO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbGV0IG5leHRWYWx1ZSA9IG5leHRMZXhpY2FsTm9kZVtwcm9wZXJ0eV07XG4gICAgaWYgKHByZXZWYWx1ZSAhPT0gbmV4dFZhbHVlKSB7XG4gICAgICBpZiAobmV4dFZhbHVlIGluc3RhbmNlb2YgRWRpdG9yQ2xhc3MpIHtcbiAgICAgICAgY29uc3QgeWpzRG9jTWFwID0gYmluZGluZy5kb2NNYXA7XG4gICAgICAgIGxldCBwcmV2RG9jO1xuICAgICAgICBpZiAocHJldlZhbHVlIGluc3RhbmNlb2YgRWRpdG9yQ2xhc3MpIHtcbiAgICAgICAgICBjb25zdCBwcmV2S2V5ID0gcHJldlZhbHVlLl9rZXk7XG4gICAgICAgICAgcHJldkRvYyA9IHlqc0RvY01hcC5nZXQocHJldktleSk7XG4gICAgICAgICAgeWpzRG9jTWFwLmRlbGV0ZShwcmV2S2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSBhIGRvY3VtZW50LCB1c2UgaXQuXG4gICAgICAgIGNvbnN0IGRvYyA9IHByZXZEb2MgfHwgbmV3IERvYygpO1xuICAgICAgICBjb25zdCBrZXkgPSBkb2MuZ3VpZDtcbiAgICAgICAgbmV4dFZhbHVlLl9rZXkgPSBrZXk7XG4gICAgICAgIHlqc0RvY01hcC5zZXQoa2V5LCBkb2MpO1xuICAgICAgICBuZXh0VmFsdWUgPSBkb2M7XG4gICAgICAgIC8vIE1hcmsgdGhlIG5vZGUgZGlydHkgYXMgd2UndmUgYXNzaWduZWQgYSBuZXcga2V5IHRvIGl0XG4gICAgICAgIGJpbmRpbmcuZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgbmV4dExleGljYWxOb2RlLm1hcmtEaXJ0eSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFyZWRUeXBlIGluc3RhbmNlb2YgTWFwJDEpIHtcbiAgICAgICAgc2hhcmVkVHlwZS5zZXQocHJvcGVydHksIG5leHRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFyZWRUeXBlLnNldEF0dHJpYnV0ZShwcm9wZXJ0eSwgbmV4dFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNwbGljZVN0cmluZyhzdHIsIGluZGV4LCBkZWxDb3VudCwgbmV3VGV4dCkge1xuICByZXR1cm4gc3RyLnNsaWNlKDAsIGluZGV4KSArIG5ld1RleHQgKyBzdHIuc2xpY2UoaW5kZXggKyBkZWxDb3VudCk7XG59XG5mdW5jdGlvbiBnZXRQb3NpdGlvbkZyb21FbGVtZW50QW5kT2Zmc2V0KG5vZGUsIG9mZnNldCwgYm91bmRhcnlJc0VkZ2UpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuX2NoaWxkcmVuO1xuICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgZm9yICg7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBjb25zdCBjaGlsZE9mZnNldCA9IGluZGV4O1xuICAgIGNvbnN0IHNpemUgPSBjaGlsZC5nZXRTaXplKCk7XG4gICAgaW5kZXggKz0gc2l6ZTtcbiAgICBjb25zdCBleGNlZWRzQm91bmRhcnkgPSBib3VuZGFyeUlzRWRnZSA/IGluZGV4ID49IG9mZnNldCA6IGluZGV4ID4gb2Zmc2V0O1xuICAgIGlmIChleGNlZWRzQm91bmRhcnkgJiYgY2hpbGQgaW5zdGFuY2VvZiBDb2xsYWJUZXh0Tm9kZSkge1xuICAgICAgbGV0IHRleHRPZmZzZXQgPSBvZmZzZXQgLSBjaGlsZE9mZnNldCAtIDE7XG4gICAgICBpZiAodGV4dE9mZnNldCA8IDApIHtcbiAgICAgICAgdGV4dE9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCBkaWZmTGVuZ3RoID0gaW5kZXggLSBvZmZzZXQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGg6IGRpZmZMZW5ndGgsXG4gICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICBub2RlSW5kZXg6IGksXG4gICAgICAgIG9mZnNldDogdGV4dE9mZnNldFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGluZGV4ID4gb2Zmc2V0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICBub2RlSW5kZXg6IGksXG4gICAgICAgIG9mZnNldDogY2hpbGRPZmZzZXRcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpID09PSBjaGlsZHJlbkxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgbm9kZTogbnVsbCxcbiAgICAgICAgbm9kZUluZGV4OiBpICsgMSxcbiAgICAgICAgb2Zmc2V0OiBjaGlsZE9mZnNldCArIDFcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbGVuZ3RoOiAwLFxuICAgIG5vZGU6IG51bGwsXG4gICAgbm9kZUluZGV4OiAwLFxuICAgIG9mZnNldDogMFxuICB9O1xufVxuZnVuY3Rpb24gZG9lc1NlbGVjdGlvbk5lZWRSZWNvdmVyaW5nKHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgbGV0IHJlY292ZXJ5TmVlZGVkID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGlmIChcbiAgICAvLyBXZSBtaWdodCBoYXZlIHJlbW92ZWQgYSBub2RlIHRoYXQgbm8gbG9uZ2VyIGV4aXN0c1xuICAgICFhbmNob3JOb2RlLmlzQXR0YWNoZWQoKSB8fCAhZm9jdXNOb2RlLmlzQXR0YWNoZWQoKSB8fFxuICAgIC8vIElmIHdlJ3ZlIHNwbGl0IGEgbm9kZSwgdGhlbiB0aGUgb2Zmc2V0IG1pZ2h0IG5vdCBiZSByaWdodFxuICAgICRpc1RleHROb2RlKGFuY2hvck5vZGUpICYmIGFuY2hvci5vZmZzZXQgPiBhbmNob3JOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpIHx8ICRpc1RleHROb2RlKGZvY3VzTm9kZSkgJiYgZm9jdXMub2Zmc2V0ID4gZm9jdXNOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICByZWNvdmVyeU5lZWRlZCA9IHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gU29tZXRpbWVzIGNoZWNraW5nIG5vciBhIG5vZGUgdmlhIGdldE5vZGUgbWlnaHQgdHJpZ2dlclxuICAgIC8vIGFuIGVycm9yLCBzbyB3ZSBuZWVkIHJlY292ZXJ5IHRoZW4gdG9vLlxuICAgIHJlY292ZXJ5TmVlZGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVjb3ZlcnlOZWVkZWQ7XG59XG5mdW5jdGlvbiBzeW5jV2l0aFRyYW5zYWN0aW9uKGJpbmRpbmcsIGZuKSB7XG4gIGJpbmRpbmcuZG9jLnRyYW5zYWN0KGZuLCBiaW5kaW5nKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUZyb21QYXJlbnQobm9kZSkge1xuICBjb25zdCBvbGRQYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICBpZiAob2xkUGFyZW50ICE9PSBudWxsKSB7XG4gICAgY29uc3Qgd3JpdGFibGVOb2RlID0gbm9kZS5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHdyaXRhYmxlUGFyZW50ID0gb2xkUGFyZW50LmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3QgcHJldlNpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIC8vIFRPRE86IHRoaXMgZnVuY3Rpb24gZHVwbGljYXRlcyBhIGJ1bmNoIG9mIG9wZXJhdGlvbnMsIGNhbiBiZSBzaW1wbGlmaWVkLlxuICAgIGlmIChwcmV2U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlTmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgICB3cml0YWJsZVBhcmVudC5fX2ZpcnN0ID0gbmV4dFNpYmxpbmcuX19rZXk7XG4gICAgICAgIHdyaXRhYmxlTmV4dFNpYmxpbmcuX19wcmV2ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRhYmxlUGFyZW50Ll9fZmlyc3QgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3cml0YWJsZVByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgIGlmIChuZXh0U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB3cml0YWJsZU5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSB3cml0YWJsZVByZXZTaWJsaW5nLl9fa2V5O1xuICAgICAgICB3cml0YWJsZVByZXZTaWJsaW5nLl9fbmV4dCA9IHdyaXRhYmxlTmV4dFNpYmxpbmcuX19rZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0YWJsZVByZXZTaWJsaW5nLl9fbmV4dCA9IG51bGw7XG4gICAgICB9XG4gICAgICB3cml0YWJsZU5vZGUuX19wcmV2ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG5leHRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAocHJldlNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVQcmV2U2libGluZyA9IHByZXZTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlUGFyZW50Ll9fbGFzdCA9IHByZXZTaWJsaW5nLl9fa2V5O1xuICAgICAgICB3cml0YWJsZVByZXZTaWJsaW5nLl9fbmV4dCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0YWJsZVBhcmVudC5fX2xhc3QgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3cml0YWJsZU5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgIGlmIChwcmV2U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB3cml0YWJsZVByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSB3cml0YWJsZU5leHRTaWJsaW5nLl9fa2V5O1xuICAgICAgICB3cml0YWJsZU5leHRTaWJsaW5nLl9fcHJldiA9IHdyaXRhYmxlUHJldlNpYmxpbmcuX19rZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0YWJsZU5leHRTaWJsaW5nLl9fcHJldiA9IG51bGw7XG4gICAgICB9XG4gICAgICB3cml0YWJsZU5vZGUuX19uZXh0ID0gbnVsbDtcbiAgICB9XG4gICAgd3JpdGFibGVQYXJlbnQuX19zaXplLS07XG4gICAgd3JpdGFibGVOb2RlLl9fcGFyZW50ID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gJG1vdmVTZWxlY3Rpb25Ub1ByZXZpb3VzTm9kZShhbmNob3JOb2RlS2V5LCBjdXJyZW50RWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGN1cnJlbnRFZGl0b3JTdGF0ZS5fbm9kZU1hcC5nZXQoYW5jaG9yTm9kZUtleSk7XG4gIGlmICghYW5jaG9yTm9kZSkge1xuICAgICRnZXRSb290KCkuc2VsZWN0U3RhcnQoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gR2V0IHByZXZpb3VzIG5vZGVcbiAgY29uc3QgcHJldk5vZGVLZXkgPSBhbmNob3JOb2RlLl9fcHJldjtcbiAgbGV0IHByZXZOb2RlID0gbnVsbDtcbiAgaWYgKHByZXZOb2RlS2V5KSB7XG4gICAgcHJldk5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KHByZXZOb2RlS2V5KTtcbiAgfVxuXG4gIC8vIElmIHByZXZpb3VzIG5vZGUgbm90IGZvdW5kLCBnZXQgcGFyZW50IG5vZGVcbiAgaWYgKHByZXZOb2RlID09PSBudWxsICYmIGFuY2hvck5vZGUuX19wYXJlbnQgIT09IG51bGwpIHtcbiAgICBwcmV2Tm9kZSA9ICRnZXROb2RlQnlLZXkoYW5jaG9yTm9kZS5fX3BhcmVudCk7XG4gIH1cbiAgaWYgKHByZXZOb2RlID09PSBudWxsKSB7XG4gICAgJGdldFJvb3QoKS5zZWxlY3RTdGFydCgpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJldk5vZGUgIT09IG51bGwgJiYgcHJldk5vZGUuaXNBdHRhY2hlZCgpKSB7XG4gICAgcHJldk5vZGUuc2VsZWN0RW5kKCk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoZSBmb3VuZCBub2RlIGlzIGFsc28gZGVsZXRlZCwgc2VsZWN0IHRoZSBuZXh0IG9uZVxuICAgICRtb3ZlU2VsZWN0aW9uVG9QcmV2aW91c05vZGUocHJldk5vZGUuX19rZXksIGN1cnJlbnRFZGl0b3JTdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jbGFzcyBDb2xsYWJEZWNvcmF0b3JOb2RlIHtcbiAgY29uc3RydWN0b3IoeG1sRWxlbSwgcGFyZW50LCB0eXBlKSB7XG4gICAgdGhpcy5fa2V5ID0gJyc7XG4gICAgdGhpcy5feG1sRWxlbSA9IHhtbEVsZW07XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICB9XG4gIGdldFByZXZOb2RlKG5vZGVNYXApIHtcbiAgICBpZiAobm9kZU1hcCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldCh0aGlzLl9rZXkpO1xuICAgIHJldHVybiAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpID8gbm9kZSA6IG51bGw7XG4gIH1cbiAgZ2V0Tm9kZSgpIHtcbiAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleSh0aGlzLl9rZXkpO1xuICAgIHJldHVybiAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpID8gbm9kZSA6IG51bGw7XG4gIH1cbiAgZ2V0U2hhcmVkVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5feG1sRWxlbTtcbiAgfVxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl90eXBlO1xuICB9XG4gIGdldEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5O1xuICB9XG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IGNvbGxhYkVsZW1lbnROb2RlID0gdGhpcy5fcGFyZW50O1xuICAgIHJldHVybiBjb2xsYWJFbGVtZW50Tm9kZS5nZXRDaGlsZE9mZnNldCh0aGlzKTtcbiAgfVxuICBzeW5jUHJvcGVydGllc0Zyb21MZXhpY2FsKGJpbmRpbmcsIG5leHRMZXhpY2FsTm9kZSwgcHJldk5vZGVNYXApIHtcbiAgICBjb25zdCBwcmV2TGV4aWNhbE5vZGUgPSB0aGlzLmdldFByZXZOb2RlKHByZXZOb2RlTWFwKTtcbiAgICBjb25zdCB4bWxFbGVtID0gdGhpcy5feG1sRWxlbTtcbiAgICBzeW5jUHJvcGVydGllc0Zyb21MZXhpY2FsKGJpbmRpbmcsIHhtbEVsZW0sIHByZXZMZXhpY2FsTm9kZSwgbmV4dExleGljYWxOb2RlKTtcbiAgfVxuICBzeW5jUHJvcGVydGllc0Zyb21ZanMoYmluZGluZywga2V5c0NoYW5nZWQpIHtcbiAgICBjb25zdCBsZXhpY2FsTm9kZSA9IHRoaXMuZ2V0Tm9kZSgpO1xuICAgIGlmICghKGxleGljYWxOb2RlICE9PSBudWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYHN5bmNQcm9wZXJ0aWVzRnJvbVlqczogY291bGQgbm90IGZpbmQgZGVjb3JhdG9yIG5vZGVgKTtcbiAgICB9XG4gICAgY29uc3QgeG1sRWxlbSA9IHRoaXMuX3htbEVsZW07XG4gICAgc3luY1Byb3BlcnRpZXNGcm9tWWpzKGJpbmRpbmcsIHhtbEVsZW0sIGxleGljYWxOb2RlLCBrZXlzQ2hhbmdlZCk7XG4gIH1cbiAgZGVzdHJveShiaW5kaW5nKSB7XG4gICAgY29uc3QgY29sbGFiTm9kZU1hcCA9IGJpbmRpbmcuY29sbGFiTm9kZU1hcDtcbiAgICBjb2xsYWJOb2RlTWFwLmRlbGV0ZSh0aGlzLl9rZXkpO1xuICB9XG59XG5mdW5jdGlvbiAkY3JlYXRlQ29sbGFiRGVjb3JhdG9yTm9kZSh4bWxFbGVtLCBwYXJlbnQsIHR5cGUpIHtcbiAgY29uc3QgY29sbGFiTm9kZSA9IG5ldyBDb2xsYWJEZWNvcmF0b3JOb2RlKHhtbEVsZW0sIHBhcmVudCwgdHlwZSk7XG4gIHhtbEVsZW0uX2NvbGxhYk5vZGUgPSBjb2xsYWJOb2RlO1xuICByZXR1cm4gY29sbGFiTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jbGFzcyBDb2xsYWJFbGVtZW50Tm9kZSB7XG4gIGNvbnN0cnVjdG9yKHhtbFRleHQsIHBhcmVudCwgdHlwZSkge1xuICAgIHRoaXMuX2tleSA9ICcnO1xuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgdGhpcy5feG1sVGV4dCA9IHhtbFRleHQ7XG4gICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB9XG4gIGdldFByZXZOb2RlKG5vZGVNYXApIHtcbiAgICBpZiAobm9kZU1hcCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldCh0aGlzLl9rZXkpO1xuICAgIHJldHVybiAkaXNFbGVtZW50Tm9kZShub2RlKSA/IG5vZGUgOiBudWxsO1xuICB9XG4gIGdldE5vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRnZXROb2RlQnlLZXkodGhpcy5fa2V5KTtcbiAgICByZXR1cm4gJGlzRWxlbWVudE5vZGUobm9kZSkgPyBub2RlIDogbnVsbDtcbiAgfVxuICBnZXRTaGFyZWRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl94bWxUZXh0O1xuICB9XG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gIH1cbiAgZ2V0S2V5KCkge1xuICAgIHJldHVybiB0aGlzLl9rZXk7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xuICB9XG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IGNvbGxhYkVsZW1lbnROb2RlID0gdGhpcy5fcGFyZW50O1xuICAgIGlmICghKGNvbGxhYkVsZW1lbnROb2RlICE9PSBudWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYGdldE9mZnNldDogY291bGQgbm90IGZpbmQgY29sbGFiIGVsZW1lbnQgbm9kZWApO1xuICAgIH1cbiAgICByZXR1cm4gY29sbGFiRWxlbWVudE5vZGUuZ2V0Q2hpbGRPZmZzZXQodGhpcyk7XG4gIH1cbiAgc3luY1Byb3BlcnRpZXNGcm9tWWpzKGJpbmRpbmcsIGtleXNDaGFuZ2VkKSB7XG4gICAgY29uc3QgbGV4aWNhbE5vZGUgPSB0aGlzLmdldE5vZGUoKTtcbiAgICBpZiAoIShsZXhpY2FsTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgIHRocm93IEVycm9yKGBzeW5jUHJvcGVydGllc0Zyb21ZanM6IGNvdWxkIG5vdCBmaW5kIGVsZW1lbnQgbm9kZWApO1xuICAgIH1cbiAgICBzeW5jUHJvcGVydGllc0Zyb21ZanMoYmluZGluZywgdGhpcy5feG1sVGV4dCwgbGV4aWNhbE5vZGUsIGtleXNDaGFuZ2VkKTtcbiAgfVxuICBhcHBseUNoaWxkcmVuWWpzRGVsdGEoYmluZGluZywgZGVsdGFzKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBsZXQgY3VyckluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbHRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGVsdGEgPSBkZWx0YXNbaV07XG4gICAgICBjb25zdCBpbnNlcnREZWx0YSA9IGRlbHRhLmluc2VydDtcbiAgICAgIGNvbnN0IGRlbGV0ZURlbHRhID0gZGVsdGEuZGVsZXRlO1xuICAgICAgaWYgKGRlbHRhLnJldGFpbiAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJJbmRleCArPSBkZWx0YS5yZXRhaW47XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWxldGVEZWx0YSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbGV0IGRlbGV0aW9uU2l6ZSA9IGRlbGV0ZURlbHRhO1xuICAgICAgICB3aGlsZSAoZGVsZXRpb25TaXplID4gMCkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBub2RlSW5kZXgsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBsZW5ndGhcbiAgICAgICAgICB9ID0gZ2V0UG9zaXRpb25Gcm9tRWxlbWVudEFuZE9mZnNldCh0aGlzLCBjdXJySW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIENvbGxhYkVsZW1lbnROb2RlIHx8IG5vZGUgaW5zdGFuY2VvZiBDb2xsYWJMaW5lQnJlYWtOb2RlIHx8IG5vZGUgaW5zdGFuY2VvZiBDb2xsYWJEZWNvcmF0b3JOb2RlKSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2Uobm9kZUluZGV4LCAxKTtcbiAgICAgICAgICAgIGRlbGV0aW9uU2l6ZSAtPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIENvbGxhYlRleHROb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBkZWxDb3VudCA9IE1hdGgubWluKGRlbGV0aW9uU2l6ZSwgbGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZDb2xsYWJOb2RlID0gbm9kZUluZGV4ICE9PSAwID8gY2hpbGRyZW5bbm9kZUluZGV4IC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgY29uc3Qgbm9kZVNpemUgPSBub2RlLmdldFNpemUoKTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IDAgJiYgZGVsQ291bnQgPT09IDEgJiYgbm9kZUluZGV4ID4gMCAmJiBwcmV2Q29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYlRleHROb2RlICYmIGxlbmd0aCA9PT0gbm9kZVNpemUgJiZcbiAgICAgICAgICAgIC8vIElmIHRoZSBub2RlIGhhcyBubyBrZXlzLCBpdCdzIGJlZW4gZGVsZXRlZFxuICAgICAgICAgICAgQXJyYXkuZnJvbShub2RlLl9tYXAua2V5cygpKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gTWVyZ2UgdGhlIHRleHQgbm9kZSB3aXRoIHByZXZpb3VzLlxuICAgICAgICAgICAgICBwcmV2Q29sbGFiTm9kZS5fdGV4dCArPSBub2RlLl90ZXh0O1xuICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2Uobm9kZUluZGV4LCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID09PSAwICYmIGRlbENvdW50ID09PSBub2RlU2l6ZSkge1xuICAgICAgICAgICAgICAvLyBUaGUgZW50aXJlIHRoaW5nIG5lZWRzIHJlbW92aW5nXG4gICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShub2RlSW5kZXgsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZS5fdGV4dCA9IHNwbGljZVN0cmluZyhub2RlLl90ZXh0LCBvZmZzZXQsIGRlbENvdW50LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGlvblNpemUgLT0gZGVsQ291bnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhbiBvY2N1ciBkdWUgdG8gdGhlIGRlbGV0aW9uIGZyb20gdGhlIGRhbmdsaW5nIHRleHQgaGV1cmlzdGljIGJlbG93LlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGluc2VydERlbHRhICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnNlcnREZWx0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgb2Zmc2V0XG4gICAgICAgICAgfSA9IGdldFBvc2l0aW9uRnJvbUVsZW1lbnRBbmRPZmZzZXQodGhpcywgY3VyckluZGV4LCB0cnVlKTtcbiAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIENvbGxhYlRleHROb2RlKSB7XG4gICAgICAgICAgICBub2RlLl90ZXh0ID0gc3BsaWNlU3RyaW5nKG5vZGUuX3RleHQsIG9mZnNldCwgMCwgaW5zZXJ0RGVsdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYXliZSB3ZSBjYW4gaW1wcm92ZSB0aGlzIGJ5IGtlZXBpbmcgYXJvdW5kIGEgcmVkdW5kYW50XG4gICAgICAgICAgICAvLyB0ZXh0IG5vZGUgbWFwLCByYXRoZXIgdGhhbiByZW1vdmluZyBhbGwgdGhlIHRleHQgbm9kZXMsIHNvIHRoZXJlXG4gICAgICAgICAgICAvLyBuZXZlciBjYW4gYmUgZGFuZ2xpbmcgdGV4dC5cblxuICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIGNvbmZsaWN0IHdoZXJlIHRoZXJlIHdhcyBsaWtlbHkgYSBDb2xsYWJUZXh0Tm9kZSBhbmRcbiAgICAgICAgICAgIC8vIGFuIExleGljYWwgVGV4dE5vZGUgdG9vLCBidXQgdGhleSB3ZXJlIHJlbW92ZWQgaW4gYSBtZXJnZS4gU29cbiAgICAgICAgICAgIC8vIGxldCdzIGp1c3QgaWdub3JlIHRoZSB0ZXh0IGFuZCB0cmlnZ2VyIGEgcmVtb3ZhbCBmb3IgaXQgZnJvbSBvdXJcbiAgICAgICAgICAgIC8vIHNoYXJlZCB0eXBlLlxuICAgICAgICAgICAgdGhpcy5feG1sVGV4dC5kZWxldGUob2Zmc2V0LCBpbnNlcnREZWx0YS5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJySW5kZXggKz0gaW5zZXJ0RGVsdGEubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHNoYXJlZFR5cGUgPSBpbnNlcnREZWx0YTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBub2RlSW5kZXhcbiAgICAgICAgICB9ID0gZ2V0UG9zaXRpb25Gcm9tRWxlbWVudEFuZE9mZnNldCh0aGlzLCBjdXJySW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICBjb25zdCBjb2xsYWJOb2RlID0gJGdldE9ySW5pdENvbGxhYk5vZGVGcm9tU2hhcmVkVHlwZShiaW5kaW5nLCBzaGFyZWRUeXBlLCB0aGlzKTtcbiAgICAgICAgICBjaGlsZHJlbi5zcGxpY2Uobm9kZUluZGV4LCAwLCBjb2xsYWJOb2RlKTtcbiAgICAgICAgICBjdXJySW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGRlbHRhIGZvcm1hdCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzeW5jQ2hpbGRyZW5Gcm9tWWpzKGJpbmRpbmcpIHtcbiAgICAvLyBOb3cgZGlmZiB0aGUgY2hpbGRyZW4gb2YgdGhlIGNvbGxhYiBub2RlIHdpdGggdGhhdCBvZiBvdXIgZXhpc3RpbmcgTGV4aWNhbCBub2RlLlxuICAgIGNvbnN0IGxleGljYWxOb2RlID0gdGhpcy5nZXROb2RlKCk7XG4gICAgaWYgKCEobGV4aWNhbE5vZGUgIT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgc3luY0NoaWxkcmVuRnJvbVlqczogY291bGQgbm90IGZpbmQgZWxlbWVudCBub2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGxleGljYWxOb2RlLl9fa2V5O1xuICAgIGNvbnN0IHByZXZMZXhpY2FsQ2hpbGRyZW5LZXlzID0gJGNyZWF0ZUNoaWxkcmVuQXJyYXkobGV4aWNhbE5vZGUsIG51bGwpO1xuICAgIGNvbnN0IGxleGljYWxDaGlsZHJlbktleXNMZW5ndGggPSBwcmV2TGV4aWNhbENoaWxkcmVuS2V5cy5sZW5ndGg7XG4gICAgY29uc3QgY29sbGFiQ2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBjb25zdCBjb2xsYWJDaGlsZHJlbkxlbmd0aCA9IGNvbGxhYkNoaWxkcmVuLmxlbmd0aDtcbiAgICBjb25zdCBjb2xsYWJOb2RlTWFwID0gYmluZGluZy5jb2xsYWJOb2RlTWFwO1xuICAgIGNvbnN0IHZpc2l0ZWRLZXlzID0gbmV3IFNldCgpO1xuICAgIGxldCBjb2xsYWJLZXlzO1xuICAgIGxldCB3cml0YWJsZUxleGljYWxOb2RlO1xuICAgIGxldCBwcmV2SW5kZXggPSAwO1xuICAgIGxldCBwcmV2Q2hpbGROb2RlID0gbnVsbDtcbiAgICBpZiAoY29sbGFiQ2hpbGRyZW5MZW5ndGggIT09IGxleGljYWxDaGlsZHJlbktleXNMZW5ndGgpIHtcbiAgICAgIHdyaXRhYmxlTGV4aWNhbE5vZGUgPSBsZXhpY2FsTm9kZS5nZXRXcml0YWJsZSgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbGxhYkNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxleGljYWxDaGlsZEtleSA9IHByZXZMZXhpY2FsQ2hpbGRyZW5LZXlzW3ByZXZJbmRleF07XG4gICAgICBjb25zdCBjaGlsZENvbGxhYk5vZGUgPSBjb2xsYWJDaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IGNvbGxhYkxleGljYWxDaGlsZE5vZGUgPSBjaGlsZENvbGxhYk5vZGUuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgY29sbGFiS2V5ID0gY2hpbGRDb2xsYWJOb2RlLl9rZXk7XG4gICAgICBpZiAoY29sbGFiTGV4aWNhbENoaWxkTm9kZSAhPT0gbnVsbCAmJiBsZXhpY2FsQ2hpbGRLZXkgPT09IGNvbGxhYktleSkge1xuICAgICAgICBjb25zdCBjaGlsZE5lZWRzVXBkYXRpbmcgPSAkaXNUZXh0Tm9kZShjb2xsYWJMZXhpY2FsQ2hpbGROb2RlKTtcbiAgICAgICAgLy8gVXBkYXRlXG4gICAgICAgIHZpc2l0ZWRLZXlzLmFkZChsZXhpY2FsQ2hpbGRLZXkpO1xuICAgICAgICBpZiAoY2hpbGROZWVkc1VwZGF0aW5nKSB7XG4gICAgICAgICAgY2hpbGRDb2xsYWJOb2RlLl9rZXkgPSBsZXhpY2FsQ2hpbGRLZXk7XG4gICAgICAgICAgaWYgKGNoaWxkQ29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYkVsZW1lbnROb2RlKSB7XG4gICAgICAgICAgICBjb25zdCB4bWxUZXh0ID0gY2hpbGRDb2xsYWJOb2RlLl94bWxUZXh0O1xuICAgICAgICAgICAgY2hpbGRDb2xsYWJOb2RlLnN5bmNQcm9wZXJ0aWVzRnJvbVlqcyhiaW5kaW5nLCBudWxsKTtcbiAgICAgICAgICAgIGNoaWxkQ29sbGFiTm9kZS5hcHBseUNoaWxkcmVuWWpzRGVsdGEoYmluZGluZywgeG1sVGV4dC50b0RlbHRhKCkpO1xuICAgICAgICAgICAgY2hpbGRDb2xsYWJOb2RlLnN5bmNDaGlsZHJlbkZyb21ZanMoYmluZGluZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbGxhYk5vZGUgaW5zdGFuY2VvZiBDb2xsYWJUZXh0Tm9kZSkge1xuICAgICAgICAgICAgY2hpbGRDb2xsYWJOb2RlLnN5bmNQcm9wZXJ0aWVzQW5kVGV4dEZyb21ZanMoYmluZGluZywgbnVsbCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbGxhYk5vZGUgaW5zdGFuY2VvZiBDb2xsYWJEZWNvcmF0b3JOb2RlKSB7XG4gICAgICAgICAgICBjaGlsZENvbGxhYk5vZGUuc3luY1Byb3BlcnRpZXNGcm9tWWpzKGJpbmRpbmcsIG51bGwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIShjaGlsZENvbGxhYk5vZGUgaW5zdGFuY2VvZiBDb2xsYWJMaW5lQnJlYWtOb2RlKSkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgc3luY0NoaWxkcmVuRnJvbVlqczogZXhwZWN0ZWQgdGV4dCwgZWxlbWVudCwgZGVjb3JhdG9yLCBvciBsaW5lYnJlYWsgY29sbGFiIG5vZGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldkNoaWxkTm9kZSA9IGNvbGxhYkxleGljYWxDaGlsZE5vZGU7XG4gICAgICAgIHByZXZJbmRleCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbGxhYktleXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbGxhYktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBjb2xsYWJDaGlsZHJlbkxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNvbGxhYkNoaWxkcmVuW3NdO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBjaGlsZC5fa2V5O1xuICAgICAgICAgICAgaWYgKGNoaWxkS2V5ICE9PSAnJykge1xuICAgICAgICAgICAgICBjb2xsYWJLZXlzLmFkZChjaGlsZEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xsYWJMZXhpY2FsQ2hpbGROb2RlICE9PSBudWxsICYmIGxleGljYWxDaGlsZEtleSAhPT0gdW5kZWZpbmVkICYmICFjb2xsYWJLZXlzLmhhcyhsZXhpY2FsQ2hpbGRLZXkpKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZVRvUmVtb3ZlID0gJGdldE5vZGVCeUtleU9yVGhyb3cobGV4aWNhbENoaWxkS2V5KTtcbiAgICAgICAgICByZW1vdmVGcm9tUGFyZW50KG5vZGVUb1JlbW92ZSk7XG4gICAgICAgICAgaS0tO1xuICAgICAgICAgIHByZXZJbmRleCsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRhYmxlTGV4aWNhbE5vZGUgPSBsZXhpY2FsTm9kZS5nZXRXcml0YWJsZSgpO1xuICAgICAgICAvLyBDcmVhdGUvUmVwbGFjZVxuICAgICAgICBjb25zdCBsZXhpY2FsQ2hpbGROb2RlID0gY3JlYXRlTGV4aWNhbE5vZGVGcm9tQ29sbGFiTm9kZShiaW5kaW5nLCBjaGlsZENvbGxhYk5vZGUsIGtleSk7XG4gICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gbGV4aWNhbENoaWxkTm9kZS5fX2tleTtcbiAgICAgICAgY29sbGFiTm9kZU1hcC5zZXQoY2hpbGRLZXksIGNoaWxkQ29sbGFiTm9kZSk7XG4gICAgICAgIGlmIChwcmV2Q2hpbGROb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSB3cml0YWJsZUxleGljYWxOb2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICB3cml0YWJsZUxleGljYWxOb2RlLl9fZmlyc3QgPSBjaGlsZEtleTtcbiAgICAgICAgICBpZiAobmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlTmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSBjaGlsZEtleTtcbiAgICAgICAgICAgIGxleGljYWxDaGlsZE5vZGUuX19uZXh0ID0gd3JpdGFibGVOZXh0U2libGluZy5fX2tleTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgd3JpdGFibGVQcmV2Q2hpbGROb2RlID0gcHJldkNoaWxkTm9kZS5nZXRXcml0YWJsZSgpO1xuICAgICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gcHJldkNoaWxkTm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICAgIHdyaXRhYmxlUHJldkNoaWxkTm9kZS5fX25leHQgPSBjaGlsZEtleTtcbiAgICAgICAgICBsZXhpY2FsQ2hpbGROb2RlLl9fcHJldiA9IHByZXZDaGlsZE5vZGUuX19rZXk7XG4gICAgICAgICAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB3cml0YWJsZU5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgICAgIHdyaXRhYmxlTmV4dFNpYmxpbmcuX19wcmV2ID0gY2hpbGRLZXk7XG4gICAgICAgICAgICBsZXhpY2FsQ2hpbGROb2RlLl9fbmV4dCA9IHdyaXRhYmxlTmV4dFNpYmxpbmcuX19rZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSBjb2xsYWJDaGlsZHJlbkxlbmd0aCAtIDEpIHtcbiAgICAgICAgICB3cml0YWJsZUxleGljYWxOb2RlLl9fbGFzdCA9IGNoaWxkS2V5O1xuICAgICAgICB9XG4gICAgICAgIHdyaXRhYmxlTGV4aWNhbE5vZGUuX19zaXplKys7XG4gICAgICAgIHByZXZDaGlsZE5vZGUgPSBsZXhpY2FsQ2hpbGROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxleGljYWxDaGlsZHJlbktleXNMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGV4aWNhbENoaWxkS2V5ID0gcHJldkxleGljYWxDaGlsZHJlbktleXNbaV07XG4gICAgICBpZiAoIXZpc2l0ZWRLZXlzLmhhcyhsZXhpY2FsQ2hpbGRLZXkpKSB7XG4gICAgICAgIC8vIFJlbW92ZVxuICAgICAgICBjb25zdCBsZXhpY2FsQ2hpbGROb2RlID0gJGdldE5vZGVCeUtleU9yVGhyb3cobGV4aWNhbENoaWxkS2V5KTtcbiAgICAgICAgY29uc3QgY29sbGFiTm9kZSA9IGJpbmRpbmcuY29sbGFiTm9kZU1hcC5nZXQobGV4aWNhbENoaWxkS2V5KTtcbiAgICAgICAgaWYgKGNvbGxhYk5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbGxhYk5vZGUuZGVzdHJveShiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVGcm9tUGFyZW50KGxleGljYWxDaGlsZE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzeW5jUHJvcGVydGllc0Zyb21MZXhpY2FsKGJpbmRpbmcsIG5leHRMZXhpY2FsTm9kZSwgcHJldk5vZGVNYXApIHtcbiAgICBzeW5jUHJvcGVydGllc0Zyb21MZXhpY2FsKGJpbmRpbmcsIHRoaXMuX3htbFRleHQsIHRoaXMuZ2V0UHJldk5vZGUocHJldk5vZGVNYXApLCBuZXh0TGV4aWNhbE5vZGUpO1xuICB9XG4gIF9zeW5jQ2hpbGRGcm9tTGV4aWNhbChiaW5kaW5nLCBpbmRleCwga2V5LCBwcmV2Tm9kZU1hcCwgZGlydHlFbGVtZW50cywgZGlydHlMZWF2ZXMpIHtcbiAgICBjb25zdCBjaGlsZENvbGxhYk5vZGUgPSB0aGlzLl9jaGlsZHJlbltpbmRleF07XG4gICAgLy8gVXBkYXRlXG4gICAgY29uc3QgbmV4dENoaWxkTm9kZSA9ICRnZXROb2RlQnlLZXlPclRocm93KGtleSk7XG4gICAgaWYgKGNoaWxkQ29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYkVsZW1lbnROb2RlICYmICRpc0VsZW1lbnROb2RlKG5leHRDaGlsZE5vZGUpKSB7XG4gICAgICBjaGlsZENvbGxhYk5vZGUuc3luY1Byb3BlcnRpZXNGcm9tTGV4aWNhbChiaW5kaW5nLCBuZXh0Q2hpbGROb2RlLCBwcmV2Tm9kZU1hcCk7XG4gICAgICBjaGlsZENvbGxhYk5vZGUuc3luY0NoaWxkcmVuRnJvbUxleGljYWwoYmluZGluZywgbmV4dENoaWxkTm9kZSwgcHJldk5vZGVNYXAsIGRpcnR5RWxlbWVudHMsIGRpcnR5TGVhdmVzKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkQ29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYlRleHROb2RlICYmICRpc1RleHROb2RlKG5leHRDaGlsZE5vZGUpKSB7XG4gICAgICBjaGlsZENvbGxhYk5vZGUuc3luY1Byb3BlcnRpZXNBbmRUZXh0RnJvbUxleGljYWwoYmluZGluZywgbmV4dENoaWxkTm9kZSwgcHJldk5vZGVNYXApO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRDb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiRGVjb3JhdG9yTm9kZSAmJiAkaXNEZWNvcmF0b3JOb2RlKG5leHRDaGlsZE5vZGUpKSB7XG4gICAgICBjaGlsZENvbGxhYk5vZGUuc3luY1Byb3BlcnRpZXNGcm9tTGV4aWNhbChiaW5kaW5nLCBuZXh0Q2hpbGROb2RlLCBwcmV2Tm9kZU1hcCk7XG4gICAgfVxuICB9XG4gIHN5bmNDaGlsZHJlbkZyb21MZXhpY2FsKGJpbmRpbmcsIG5leHRMZXhpY2FsTm9kZSwgcHJldk5vZGVNYXAsIGRpcnR5RWxlbWVudHMsIGRpcnR5TGVhdmVzKSB7XG4gICAgY29uc3QgcHJldkxleGljYWxOb2RlID0gdGhpcy5nZXRQcmV2Tm9kZShwcmV2Tm9kZU1hcCk7XG4gICAgY29uc3QgcHJldkNoaWxkcmVuID0gcHJldkxleGljYWxOb2RlID09PSBudWxsID8gW10gOiAkY3JlYXRlQ2hpbGRyZW5BcnJheShwcmV2TGV4aWNhbE5vZGUsIHByZXZOb2RlTWFwKTtcbiAgICBjb25zdCBuZXh0Q2hpbGRyZW4gPSAkY3JlYXRlQ2hpbGRyZW5BcnJheShuZXh0TGV4aWNhbE5vZGUsIG51bGwpO1xuICAgIGNvbnN0IHByZXZFbmRJbmRleCA9IHByZXZDaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgIGNvbnN0IG5leHRFbmRJbmRleCA9IG5leHRDaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGNvbGxhYk5vZGVNYXAgPSBiaW5kaW5nLmNvbGxhYk5vZGVNYXA7XG4gICAgbGV0IHByZXZDaGlsZHJlblNldDtcbiAgICBsZXQgbmV4dENoaWxkcmVuU2V0O1xuICAgIGxldCBwcmV2SW5kZXggPSAwO1xuICAgIGxldCBuZXh0SW5kZXggPSAwO1xuICAgIHdoaWxlIChwcmV2SW5kZXggPD0gcHJldkVuZEluZGV4ICYmIG5leHRJbmRleCA8PSBuZXh0RW5kSW5kZXgpIHtcbiAgICAgIGNvbnN0IHByZXZLZXkgPSBwcmV2Q2hpbGRyZW5bcHJldkluZGV4XTtcbiAgICAgIGNvbnN0IG5leHRLZXkgPSBuZXh0Q2hpbGRyZW5bbmV4dEluZGV4XTtcbiAgICAgIGlmIChwcmV2S2V5ID09PSBuZXh0S2V5KSB7XG4gICAgICAgIC8vIE5vdmUgbW92ZSwgY3JlYXRlIG9yIHJlbW92ZVxuICAgICAgICB0aGlzLl9zeW5jQ2hpbGRGcm9tTGV4aWNhbChiaW5kaW5nLCBuZXh0SW5kZXgsIG5leHRLZXksIHByZXZOb2RlTWFwLCBkaXJ0eUVsZW1lbnRzLCBkaXJ0eUxlYXZlcyk7XG4gICAgICAgIHByZXZJbmRleCsrO1xuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW5TZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByZXZDaGlsZHJlblNldCA9IG5ldyBTZXQocHJldkNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dENoaWxkcmVuU2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXh0Q2hpbGRyZW5TZXQgPSBuZXcgU2V0KG5leHRDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dEhhc1ByZXZLZXkgPSBuZXh0Q2hpbGRyZW5TZXQuaGFzKHByZXZLZXkpO1xuICAgICAgICBjb25zdCBwcmV2SGFzTmV4dEtleSA9IHByZXZDaGlsZHJlblNldC5oYXMobmV4dEtleSk7XG4gICAgICAgIGlmICghbmV4dEhhc1ByZXZLZXkpIHtcbiAgICAgICAgICAvLyBSZW1vdmVcbiAgICAgICAgICB0aGlzLnNwbGljZShiaW5kaW5nLCBuZXh0SW5kZXgsIDEpO1xuICAgICAgICAgIHByZXZJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENyZWF0ZSBvciByZXBsYWNlXG4gICAgICAgICAgY29uc3QgbmV4dENoaWxkTm9kZSA9ICRnZXROb2RlQnlLZXlPclRocm93KG5leHRLZXkpO1xuICAgICAgICAgIGNvbnN0IGNvbGxhYk5vZGUgPSAkY3JlYXRlQ29sbGFiTm9kZUZyb21MZXhpY2FsTm9kZShiaW5kaW5nLCBuZXh0Q2hpbGROb2RlLCB0aGlzKTtcbiAgICAgICAgICBjb2xsYWJOb2RlTWFwLnNldChuZXh0S2V5LCBjb2xsYWJOb2RlKTtcbiAgICAgICAgICBpZiAocHJldkhhc05leHRLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlKGJpbmRpbmcsIG5leHRJbmRleCwgMSwgY29sbGFiTm9kZSk7XG4gICAgICAgICAgICBwcmV2SW5kZXgrKztcbiAgICAgICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZShiaW5kaW5nLCBuZXh0SW5kZXgsIDAsIGNvbGxhYk5vZGUpO1xuICAgICAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFwcGVuZE5ld0NoaWxkcmVuID0gcHJldkluZGV4ID4gcHJldkVuZEluZGV4O1xuICAgIGNvbnN0IHJlbW92ZU9sZENoaWxkcmVuID0gbmV4dEluZGV4ID4gbmV4dEVuZEluZGV4O1xuICAgIGlmIChhcHBlbmROZXdDaGlsZHJlbiAmJiAhcmVtb3ZlT2xkQ2hpbGRyZW4pIHtcbiAgICAgIGZvciAoOyBuZXh0SW5kZXggPD0gbmV4dEVuZEluZGV4OyArK25leHRJbmRleCkge1xuICAgICAgICBjb25zdCBrZXkgPSBuZXh0Q2hpbGRyZW5bbmV4dEluZGV4XTtcbiAgICAgICAgY29uc3QgbmV4dENoaWxkTm9kZSA9ICRnZXROb2RlQnlLZXlPclRocm93KGtleSk7XG4gICAgICAgIGNvbnN0IGNvbGxhYk5vZGUgPSAkY3JlYXRlQ29sbGFiTm9kZUZyb21MZXhpY2FsTm9kZShiaW5kaW5nLCBuZXh0Q2hpbGROb2RlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5hcHBlbmQoY29sbGFiTm9kZSk7XG4gICAgICAgIGNvbGxhYk5vZGVNYXAuc2V0KGtleSwgY29sbGFiTm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZW1vdmVPbGRDaGlsZHJlbiAmJiAhYXBwZW5kTmV3Q2hpbGRyZW4pIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IG5leHRJbmRleDsgaS0tKSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKGJpbmRpbmcsIGksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhcHBlbmQoY29sbGFiTm9kZSkge1xuICAgIGNvbnN0IHhtbFRleHQgPSB0aGlzLl94bWxUZXh0O1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgY29uc3QgbGFzdENoaWxkID0gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgY29uc3Qgb2Zmc2V0ID0gbGFzdENoaWxkICE9PSB1bmRlZmluZWQgPyBsYXN0Q2hpbGQuZ2V0T2Zmc2V0KCkgKyBsYXN0Q2hpbGQuZ2V0U2l6ZSgpIDogMDtcbiAgICBpZiAoY29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYkVsZW1lbnROb2RlKSB7XG4gICAgICB4bWxUZXh0Lmluc2VydEVtYmVkKG9mZnNldCwgY29sbGFiTm9kZS5feG1sVGV4dCk7XG4gICAgfSBlbHNlIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiVGV4dE5vZGUpIHtcbiAgICAgIGNvbnN0IG1hcCA9IGNvbGxhYk5vZGUuX21hcDtcbiAgICAgIGlmIChtYXAucGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHhtbFRleHQuaW5zZXJ0RW1iZWQob2Zmc2V0LCBtYXApO1xuICAgICAgfVxuICAgICAgeG1sVGV4dC5pbnNlcnQob2Zmc2V0ICsgMSwgY29sbGFiTm9kZS5fdGV4dCk7XG4gICAgfSBlbHNlIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiTGluZUJyZWFrTm9kZSkge1xuICAgICAgeG1sVGV4dC5pbnNlcnRFbWJlZChvZmZzZXQsIGNvbGxhYk5vZGUuX21hcCk7XG4gICAgfSBlbHNlIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiRGVjb3JhdG9yTm9kZSkge1xuICAgICAgeG1sVGV4dC5pbnNlcnRFbWJlZChvZmZzZXQsIGNvbGxhYk5vZGUuX3htbEVsZW0pO1xuICAgIH1cbiAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNvbGxhYk5vZGUpO1xuICB9XG4gIHNwbGljZShiaW5kaW5nLCBpbmRleCwgZGVsQ291bnQsIGNvbGxhYk5vZGUpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baW5kZXhdO1xuICAgIGlmIChjaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIShjb2xsYWJOb2RlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBzcGxpY2U6IGNvdWxkIG5vdCBmaW5kIGNvbGxhYiBlbGVtZW50IG5vZGVgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kKGNvbGxhYk5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvZmZzZXQgPSBjaGlsZC5nZXRPZmZzZXQoKTtcbiAgICBpZiAoIShvZmZzZXQgIT09IC0xKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYHNwbGljZTogZXhwZWN0ZWQgb2Zmc2V0IHRvIGJlIGdyZWF0ZXIgdGhhbiB6ZXJvYCk7XG4gICAgfVxuICAgIGNvbnN0IHhtbFRleHQgPSB0aGlzLl94bWxUZXh0O1xuICAgIGlmIChkZWxDb3VudCAhPT0gMCkge1xuICAgICAgLy8gV2hhdCBpZiB3ZSBkZWxldGUgbWFueSBub2RlcywgZG9uJ3Qgd2UgbmVlZCB0byBnZXQgYWxsIHRoZWlyXG4gICAgICAvLyBzaXplcz9cbiAgICAgIHhtbFRleHQuZGVsZXRlKG9mZnNldCwgY2hpbGQuZ2V0U2l6ZSgpKTtcbiAgICB9XG4gICAgaWYgKGNvbGxhYk5vZGUgaW5zdGFuY2VvZiBDb2xsYWJFbGVtZW50Tm9kZSkge1xuICAgICAgeG1sVGV4dC5pbnNlcnRFbWJlZChvZmZzZXQsIGNvbGxhYk5vZGUuX3htbFRleHQpO1xuICAgIH0gZWxzZSBpZiAoY29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYlRleHROb2RlKSB7XG4gICAgICBjb25zdCBtYXAgPSBjb2xsYWJOb2RlLl9tYXA7XG4gICAgICBpZiAobWFwLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICB4bWxUZXh0Lmluc2VydEVtYmVkKG9mZnNldCwgbWFwKTtcbiAgICAgIH1cbiAgICAgIHhtbFRleHQuaW5zZXJ0KG9mZnNldCArIDEsIGNvbGxhYk5vZGUuX3RleHQpO1xuICAgIH0gZWxzZSBpZiAoY29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYkxpbmVCcmVha05vZGUpIHtcbiAgICAgIHhtbFRleHQuaW5zZXJ0RW1iZWQob2Zmc2V0LCBjb2xsYWJOb2RlLl9tYXApO1xuICAgIH0gZWxzZSBpZiAoY29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYkRlY29yYXRvck5vZGUpIHtcbiAgICAgIHhtbFRleHQuaW5zZXJ0RW1iZWQob2Zmc2V0LCBjb2xsYWJOb2RlLl94bWxFbGVtKTtcbiAgICB9XG4gICAgaWYgKGRlbENvdW50ICE9PSAwKSB7XG4gICAgICBjb25zdCBjaGlsZHJlblRvRGVsZXRlID0gY2hpbGRyZW4uc2xpY2UoaW5kZXgsIGluZGV4ICsgZGVsQ291bnQpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlblRvRGVsZXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkcmVuVG9EZWxldGVbaV0uZGVzdHJveShiaW5kaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbGxhYk5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2hpbGRyZW4uc3BsaWNlKGluZGV4LCBkZWxDb3VudCwgY29sbGFiTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkcmVuLnNwbGljZShpbmRleCwgZGVsQ291bnQpO1xuICAgIH1cbiAgfVxuICBnZXRDaGlsZE9mZnNldChjb2xsYWJOb2RlKSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkID09PSBjb2xsYWJOb2RlKSB7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICB9XG4gICAgICBvZmZzZXQgKz0gY2hpbGQuZ2V0U2l6ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZGVzdHJveShiaW5kaW5nKSB7XG4gICAgY29uc3QgY29sbGFiTm9kZU1hcCA9IGJpbmRpbmcuY29sbGFiTm9kZU1hcDtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkcmVuW2ldLmRlc3Ryb3koYmluZGluZyk7XG4gICAgfVxuICAgIGNvbGxhYk5vZGVNYXAuZGVsZXRlKHRoaXMuX2tleSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRjcmVhdGVDb2xsYWJFbGVtZW50Tm9kZSh4bWxUZXh0LCBwYXJlbnQsIHR5cGUpIHtcbiAgY29uc3QgY29sbGFiTm9kZSA9IG5ldyBDb2xsYWJFbGVtZW50Tm9kZSh4bWxUZXh0LCBwYXJlbnQsIHR5cGUpO1xuICB4bWxUZXh0Ll9jb2xsYWJOb2RlID0gY29sbGFiTm9kZTtcbiAgcmV0dXJuIGNvbGxhYk5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQmluZGluZyhlZGl0b3IsIHByb3ZpZGVyLCBpZCwgZG9jLCBkb2NNYXAsIGV4Y2x1ZGVkUHJvcGVydGllcykge1xuICBpZiAoIShkb2MgIT09IHVuZGVmaW5lZCAmJiBkb2MgIT09IG51bGwpKSB7XG4gICAgdGhyb3cgRXJyb3IoYGNyZWF0ZUJpbmRpbmc6IGRvYyBpcyBudWxsIG9yIHVuZGVmaW5lZGApO1xuICB9XG4gIGNvbnN0IHJvb3RYbWxUZXh0ID0gZG9jLmdldCgncm9vdCcsIFhtbFRleHQpO1xuICBjb25zdCByb290ID0gJGNyZWF0ZUNvbGxhYkVsZW1lbnROb2RlKHJvb3RYbWxUZXh0LCBudWxsLCAncm9vdCcpO1xuICByb290Ll9rZXkgPSAncm9vdCc7XG4gIHJldHVybiB7XG4gICAgY2xpZW50SUQ6IGRvYy5jbGllbnRJRCxcbiAgICBjb2xsYWJOb2RlTWFwOiBuZXcgTWFwKCksXG4gICAgY3Vyc29yczogbmV3IE1hcCgpLFxuICAgIGN1cnNvcnNDb250YWluZXI6IG51bGwsXG4gICAgZG9jLFxuICAgIGRvY01hcCxcbiAgICBlZGl0b3IsXG4gICAgZXhjbHVkZWRQcm9wZXJ0aWVzOiBleGNsdWRlZFByb3BlcnRpZXMgfHwgbmV3IE1hcCgpLFxuICAgIGlkLFxuICAgIG5vZGVQcm9wZXJ0aWVzOiBuZXcgTWFwKCksXG4gICAgcm9vdFxuICB9O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24ocG9pbnQsIGJpbmRpbmcpIHtcbiAgY29uc3QgY29sbGFiTm9kZU1hcCA9IGJpbmRpbmcuY29sbGFiTm9kZU1hcDtcbiAgY29uc3QgY29sbGFiTm9kZSA9IGNvbGxhYk5vZGVNYXAuZ2V0KHBvaW50LmtleSk7XG4gIGlmIChjb2xsYWJOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgb2Zmc2V0ID0gcG9pbnQub2Zmc2V0O1xuICBsZXQgc2hhcmVkVHlwZSA9IGNvbGxhYk5vZGUuZ2V0U2hhcmVkVHlwZSgpO1xuICBpZiAoY29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYlRleHROb2RlKSB7XG4gICAgc2hhcmVkVHlwZSA9IGNvbGxhYk5vZGUuX3BhcmVudC5feG1sVGV4dDtcbiAgICBjb25zdCBjdXJyZW50T2Zmc2V0ID0gY29sbGFiTm9kZS5nZXRPZmZzZXQoKTtcbiAgICBpZiAoY3VycmVudE9mZnNldCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBvZmZzZXQgPSBjdXJyZW50T2Zmc2V0ICsgMSArIG9mZnNldDtcbiAgfSBlbHNlIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiRWxlbWVudE5vZGUgJiYgcG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgY29uc3QgcGFyZW50ID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGlmICghJGlzRWxlbWVudE5vZGUocGFyZW50KSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEVsZW1lbnQgcG9pbnQgbXVzdCBiZSBhbiBlbGVtZW50IG5vZGVgKTtcbiAgICB9XG4gICAgbGV0IGFjY3VtdWxhdGVkT2Zmc2V0ID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IG5vZGUgPSBwYXJlbnQuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIGkrKyA8IG9mZnNldCkge1xuICAgICAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAgIGFjY3VtdWxhdGVkT2Zmc2V0ICs9IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWNjdW11bGF0ZWRPZmZzZXQrKztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuICAgIG9mZnNldCA9IGFjY3VtdWxhdGVkT2Zmc2V0O1xuICB9XG4gIHJldHVybiBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleChzaGFyZWRUeXBlLCBvZmZzZXQpO1xufVxuZnVuY3Rpb24gY3JlYXRlQWJzb2x1dGVQb3NpdGlvbihyZWxhdGl2ZVBvc2l0aW9uLCBiaW5kaW5nKSB7XG4gIHJldHVybiBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24ocmVsYXRpdmVQb3NpdGlvbiwgYmluZGluZy5kb2MpO1xufVxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlUG9zaXRpb24oY3VycmVudFBvcywgcG9zKSB7XG4gIGlmIChjdXJyZW50UG9zID09IG51bGwpIHtcbiAgICBpZiAocG9zICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwb3MgPT0gbnVsbCB8fCAhY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zKGN1cnJlbnRQb3MsIHBvcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVDdXJzb3IobmFtZSwgY29sb3IpIHtcbiAgcmV0dXJuIHtcbiAgICBjb2xvcjogY29sb3IsXG4gICAgbmFtZTogbmFtZSxcbiAgICBzZWxlY3Rpb246IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lTZWxlY3Rpb24oYmluZGluZywgc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGN1cnNvcnNDb250YWluZXIgPSBiaW5kaW5nLmN1cnNvcnNDb250YWluZXI7XG4gIGlmIChjdXJzb3JzQ29udGFpbmVyICE9PSBudWxsKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9ucyA9IHNlbGVjdGlvbi5zZWxlY3Rpb25zO1xuICAgIGNvbnN0IHNlbGVjdGlvbnNMZW5ndGggPSBzZWxlY3Rpb25zLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGlvbnNMZW5ndGg7IGkrKykge1xuICAgICAgY3Vyc29yc0NvbnRhaW5lci5yZW1vdmVDaGlsZChzZWxlY3Rpb25zW2ldKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc3Ryb3lDdXJzb3IoYmluZGluZywgY3Vyc29yKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGN1cnNvci5zZWxlY3Rpb247XG4gIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICBkZXN0cm95U2VsZWN0aW9uKGJpbmRpbmcsIHNlbGVjdGlvbik7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUN1cnNvclNlbGVjdGlvbihjdXJzb3IsIGFuY2hvcktleSwgYW5jaG9yT2Zmc2V0LCBmb2N1c0tleSwgZm9jdXNPZmZzZXQpIHtcbiAgY29uc3QgY29sb3IgPSBjdXJzb3IuY29sb3I7XG4gIGNvbnN0IGNhcmV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBjYXJldC5zdHlsZS5jc3NUZXh0ID0gYHBvc2l0aW9uOmFic29sdXRlO3RvcDowO2JvdHRvbTowO3JpZ2h0Oi0xcHg7d2lkdGg6MXB4O2JhY2tncm91bmQtY29sb3I6JHtjb2xvcn07ei1pbmRleDoxMDtgO1xuICBjb25zdCBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBuYW1lLnRleHRDb250ZW50ID0gY3Vyc29yLm5hbWU7XG4gIG5hbWUuc3R5bGUuY3NzVGV4dCA9IGBwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0ycHg7dG9wOi0xNnB4O2JhY2tncm91bmQtY29sb3I6JHtjb2xvcn07Y29sb3I6I2ZmZjtsaW5lLWhlaWdodDoxMnB4O2ZvbnQtc2l6ZToxMnB4O3BhZGRpbmc6MnB4O2ZvbnQtZmFtaWx5OkFyaWFsO2ZvbnQtd2VpZ2h0OmJvbGQ7d2hpdGUtc3BhY2U6bm93cmFwO2A7XG4gIGNhcmV0LmFwcGVuZENoaWxkKG5hbWUpO1xuICByZXR1cm4ge1xuICAgIGFuY2hvcjoge1xuICAgICAga2V5OiBhbmNob3JLZXksXG4gICAgICBvZmZzZXQ6IGFuY2hvck9mZnNldFxuICAgIH0sXG4gICAgY2FyZXQsXG4gICAgY29sb3IsXG4gICAgZm9jdXM6IHtcbiAgICAgIGtleTogZm9jdXNLZXksXG4gICAgICBvZmZzZXQ6IGZvY3VzT2Zmc2V0XG4gICAgfSxcbiAgICBuYW1lLFxuICAgIHNlbGVjdGlvbnM6IFtdXG4gIH07XG59XG5mdW5jdGlvbiB1cGRhdGVDdXJzb3IoYmluZGluZywgY3Vyc29yLCBuZXh0U2VsZWN0aW9uLCBub2RlTWFwKSB7XG4gIGNvbnN0IGVkaXRvciA9IGJpbmRpbmcuZWRpdG9yO1xuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICBjb25zdCBjdXJzb3JzQ29udGFpbmVyID0gYmluZGluZy5jdXJzb3JzQ29udGFpbmVyO1xuICBpZiAoY3Vyc29yc0NvbnRhaW5lciA9PT0gbnVsbCB8fCByb290RWxlbWVudCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjdXJzb3JzQ29udGFpbmVyT2Zmc2V0UGFyZW50ID0gY3Vyc29yc0NvbnRhaW5lci5vZmZzZXRQYXJlbnQ7XG4gIGlmIChjdXJzb3JzQ29udGFpbmVyT2Zmc2V0UGFyZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbnRhaW5lclJlY3QgPSBjdXJzb3JzQ29udGFpbmVyT2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBwcmV2U2VsZWN0aW9uID0gY3Vyc29yLnNlbGVjdGlvbjtcbiAgaWYgKG5leHRTZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICBpZiAocHJldlNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJzb3Iuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIGRlc3Ryb3lTZWxlY3Rpb24oYmluZGluZywgcHJldlNlbGVjdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGN1cnNvci5zZWxlY3Rpb24gPSBuZXh0U2VsZWN0aW9uO1xuICB9XG4gIGNvbnN0IGNhcmV0ID0gbmV4dFNlbGVjdGlvbi5jYXJldDtcbiAgY29uc3QgY29sb3IgPSBuZXh0U2VsZWN0aW9uLmNvbG9yO1xuICBjb25zdCBzZWxlY3Rpb25zID0gbmV4dFNlbGVjdGlvbi5zZWxlY3Rpb25zO1xuICBjb25zdCBhbmNob3IgPSBuZXh0U2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBuZXh0U2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JLZXkgPSBhbmNob3Iua2V5O1xuICBjb25zdCBmb2N1c0tleSA9IGZvY3VzLmtleTtcbiAgY29uc3QgYW5jaG9yTm9kZSA9IG5vZGVNYXAuZ2V0KGFuY2hvcktleSk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IG5vZGVNYXAuZ2V0KGZvY3VzS2V5KTtcbiAgaWYgKGFuY2hvck5vZGUgPT0gbnVsbCB8fCBmb2N1c05vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc2VsZWN0aW9uUmVjdHM7XG5cbiAgLy8gSW4gdGhlIGNhc2Ugb2YgYSBjb2xsYXBzZWQgc2VsZWN0aW9uIG9uIGEgbGluZWJyZWFrLCB3ZSBuZWVkXG4gIC8vIHRvIGltcHJvdmlzZSBhcyB0aGUgYnJvd3NlciB3aWxsIHJldHVybiBub3RoaW5nIGhlcmUgYXMgPGJyPlxuICAvLyBhcHBhcmFudGx5IHRha2UgdXAgbm8gdmlzdWFsIHNwYWNlIDovXG4gIC8vIFRoaXMgd29uJ3Qgd29yayBpbiBhbGwgY2FzZXMsIGJ1dCBpdCdzIGJldHRlciB0aGFuIGp1c3Qgc2hvd2luZ1xuICAvLyBub3RoaW5nIGFsbCB0aGUgdGltZS5cbiAgaWYgKGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiAkaXNMaW5lQnJlYWtOb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgY29uc3QgYnJSZWN0ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3JLZXkpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHNlbGVjdGlvblJlY3RzID0gW2JyUmVjdF07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmFuZ2UgPSBjcmVhdGVET01SYW5nZShlZGl0b3IsIGFuY2hvck5vZGUsIGFuY2hvci5vZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXMub2Zmc2V0KTtcbiAgICBpZiAocmFuZ2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZWN0aW9uUmVjdHMgPSBjcmVhdGVSZWN0c0Zyb21ET01SYW5nZShlZGl0b3IsIHJhbmdlKTtcbiAgfVxuICBjb25zdCBzZWxlY3Rpb25zTGVuZ3RoID0gc2VsZWN0aW9ucy5sZW5ndGg7XG4gIGNvbnN0IHNlbGVjdGlvblJlY3RzTGVuZ3RoID0gc2VsZWN0aW9uUmVjdHMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGlvblJlY3RzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWxlY3Rpb25SZWN0ID0gc2VsZWN0aW9uUmVjdHNbaV07XG4gICAgbGV0IHNlbGVjdGlvbiA9IHNlbGVjdGlvbnNbaV07XG4gICAgaWYgKHNlbGVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZWxlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBzZWxlY3Rpb25zW2ldID0gc2VsZWN0aW9uO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uQmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBzZWxlY3Rpb24uYXBwZW5kQ2hpbGQoc2VsZWN0aW9uQmcpO1xuICAgICAgY3Vyc29yc0NvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxlY3Rpb24pO1xuICAgIH1cbiAgICBjb25zdCB0b3AgPSBzZWxlY3Rpb25SZWN0LnRvcCAtIGNvbnRhaW5lclJlY3QudG9wO1xuICAgIGNvbnN0IGxlZnQgPSBzZWxlY3Rpb25SZWN0LmxlZnQgLSBjb250YWluZXJSZWN0LmxlZnQ7XG4gICAgY29uc3Qgc3R5bGUgPSBgcG9zaXRpb246YWJzb2x1dGU7dG9wOiR7dG9wfXB4O2xlZnQ6JHtsZWZ0fXB4O2hlaWdodDoke3NlbGVjdGlvblJlY3QuaGVpZ2h0fXB4O3dpZHRoOiR7c2VsZWN0aW9uUmVjdC53aWR0aH1weDtwb2ludGVyLWV2ZW50czpub25lO3otaW5kZXg6NTtgO1xuICAgIHNlbGVjdGlvbi5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7XG4gICAgc2VsZWN0aW9uLmZpcnN0Q2hpbGQuc3R5bGUuY3NzVGV4dCA9IGAke3N0eWxlfWxlZnQ6MDt0b3A6MDtiYWNrZ3JvdW5kLWNvbG9yOiR7Y29sb3J9O29wYWNpdHk6MC4zO2A7XG4gICAgaWYgKGkgPT09IHNlbGVjdGlvblJlY3RzTGVuZ3RoIC0gMSkge1xuICAgICAgaWYgKGNhcmV0LnBhcmVudE5vZGUgIT09IHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uYXBwZW5kQ2hpbGQoY2FyZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gc2VsZWN0aW9uc0xlbmd0aCAtIDE7IGkgPj0gc2VsZWN0aW9uUmVjdHNMZW5ndGg7IGktLSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHNlbGVjdGlvbnNbaV07XG4gICAgY3Vyc29yc0NvbnRhaW5lci5yZW1vdmVDaGlsZChzZWxlY3Rpb24pO1xuICAgIHNlbGVjdGlvbnMucG9wKCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRzeW5jTG9jYWxDdXJzb3JQb3NpdGlvbihiaW5kaW5nLCBwcm92aWRlcikge1xuICBjb25zdCBhd2FyZW5lc3MgPSBwcm92aWRlci5hd2FyZW5lc3M7XG4gIGNvbnN0IGxvY2FsU3RhdGUgPSBhd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpO1xuICBpZiAobG9jYWxTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhbmNob3JQb3MgPSBsb2NhbFN0YXRlLmFuY2hvclBvcztcbiAgY29uc3QgZm9jdXNQb3MgPSBsb2NhbFN0YXRlLmZvY3VzUG9zO1xuICBpZiAoYW5jaG9yUG9zICE9PSBudWxsICYmIGZvY3VzUG9zICE9PSBudWxsKSB7XG4gICAgY29uc3QgYW5jaG9yQWJzUG9zID0gY3JlYXRlQWJzb2x1dGVQb3NpdGlvbihhbmNob3JQb3MsIGJpbmRpbmcpO1xuICAgIGNvbnN0IGZvY3VzQWJzUG9zID0gY3JlYXRlQWJzb2x1dGVQb3NpdGlvbihmb2N1c1BvcywgYmluZGluZyk7XG4gICAgaWYgKGFuY2hvckFic1BvcyAhPT0gbnVsbCAmJiBmb2N1c0Fic1BvcyAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgW2FuY2hvckNvbGxhYk5vZGUsIGFuY2hvck9mZnNldF0gPSBnZXRDb2xsYWJOb2RlQW5kT2Zmc2V0KGFuY2hvckFic1Bvcy50eXBlLCBhbmNob3JBYnNQb3MuaW5kZXgpO1xuICAgICAgY29uc3QgW2ZvY3VzQ29sbGFiTm9kZSwgZm9jdXNPZmZzZXRdID0gZ2V0Q29sbGFiTm9kZUFuZE9mZnNldChmb2N1c0Fic1Bvcy50eXBlLCBmb2N1c0Fic1Bvcy5pbmRleCk7XG4gICAgICBpZiAoYW5jaG9yQ29sbGFiTm9kZSAhPT0gbnVsbCAmJiBmb2N1c0NvbGxhYk5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yQ29sbGFiTm9kZS5nZXRLZXkoKTtcbiAgICAgICAgY29uc3QgZm9jdXNLZXkgPSBmb2N1c0NvbGxhYk5vZGUuZ2V0S2V5KCk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICAkc2V0UG9pbnQoYW5jaG9yLCBhbmNob3JLZXksIGFuY2hvck9mZnNldCk7XG4gICAgICAgICRzZXRQb2ludChmb2N1cywgZm9jdXNLZXksIGZvY3VzT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRzZXRQb2ludChwb2ludCwga2V5LCBvZmZzZXQpIHtcbiAgaWYgKHBvaW50LmtleSAhPT0ga2V5IHx8IHBvaW50Lm9mZnNldCAhPT0gb2Zmc2V0KSB7XG4gICAgbGV0IGFuY2hvck5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KGtleSk7XG4gICAgaWYgKGFuY2hvck5vZGUgIT09IG51bGwgJiYgISRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpICYmICEkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gYW5jaG9yTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBrZXkgPSBwYXJlbnQuZ2V0S2V5KCk7XG4gICAgICBvZmZzZXQgPSBhbmNob3JOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICBhbmNob3JOb2RlID0gcGFyZW50O1xuICAgIH1cbiAgICBwb2ludC5zZXQoa2V5LCBvZmZzZXQsICRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpID8gJ2VsZW1lbnQnIDogJ3RleHQnKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29sbGFiTm9kZUFuZE9mZnNldChcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5zaGFyZWRUeXBlLCBvZmZzZXQpIHtcbiAgY29uc3QgY29sbGFiTm9kZSA9IHNoYXJlZFR5cGUuX2NvbGxhYk5vZGU7XG4gIGlmIChjb2xsYWJOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW251bGwsIDBdO1xuICB9XG4gIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiRWxlbWVudE5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBub2RlLFxuICAgICAgb2Zmc2V0OiBjb2xsYWJOb2RlT2Zmc2V0XG4gICAgfSA9IGdldFBvc2l0aW9uRnJvbUVsZW1lbnRBbmRPZmZzZXQoY29sbGFiTm9kZSwgb2Zmc2V0LCB0cnVlKTtcbiAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFtjb2xsYWJOb2RlLCAwXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtub2RlLCBjb2xsYWJOb2RlT2Zmc2V0XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtudWxsLCAwXTtcbn1cbmZ1bmN0aW9uIHN5bmNDdXJzb3JQb3NpdGlvbnMoYmluZGluZywgcHJvdmlkZXIpIHtcbiAgY29uc3QgYXdhcmVuZXNzU3RhdGVzID0gQXJyYXkuZnJvbShwcm92aWRlci5hd2FyZW5lc3MuZ2V0U3RhdGVzKCkpO1xuICBjb25zdCBsb2NhbENsaWVudElEID0gYmluZGluZy5jbGllbnRJRDtcbiAgY29uc3QgY3Vyc29ycyA9IGJpbmRpbmcuY3Vyc29ycztcbiAgY29uc3QgZWRpdG9yID0gYmluZGluZy5lZGl0b3I7XG4gIGNvbnN0IG5vZGVNYXAgPSBlZGl0b3IuX2VkaXRvclN0YXRlLl9ub2RlTWFwO1xuICBjb25zdCB2aXNpdGVkQ2xpZW50SURzID0gbmV3IFNldCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGF3YXJlbmVzc1N0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGF3YXJlbmVzc1N0YXRlID0gYXdhcmVuZXNzU3RhdGVzW2ldO1xuICAgIGNvbnN0IFtjbGllbnRJRCwgYXdhcmVuZXNzXSA9IGF3YXJlbmVzc1N0YXRlO1xuICAgIGlmIChjbGllbnRJRCAhPT0gbG9jYWxDbGllbnRJRCkge1xuICAgICAgdmlzaXRlZENsaWVudElEcy5hZGQoY2xpZW50SUQpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbmNob3JQb3MsXG4gICAgICAgIGZvY3VzUG9zLFxuICAgICAgICBuYW1lLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgZm9jdXNpbmdcbiAgICAgIH0gPSBhd2FyZW5lc3M7XG4gICAgICBsZXQgc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIGxldCBjdXJzb3IgPSBjdXJzb3JzLmdldChjbGllbnRJRCk7XG4gICAgICBpZiAoY3Vyc29yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3Vyc29yID0gY3JlYXRlQ3Vyc29yKG5hbWUsIGNvbG9yKTtcbiAgICAgICAgY3Vyc29ycy5zZXQoY2xpZW50SUQsIGN1cnNvcik7XG4gICAgICB9XG4gICAgICBpZiAoYW5jaG9yUG9zICE9PSBudWxsICYmIGZvY3VzUG9zICE9PSBudWxsICYmIGZvY3VzaW5nKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvckFic1BvcyA9IGNyZWF0ZUFic29sdXRlUG9zaXRpb24oYW5jaG9yUG9zLCBiaW5kaW5nKTtcbiAgICAgICAgY29uc3QgZm9jdXNBYnNQb3MgPSBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uKGZvY3VzUG9zLCBiaW5kaW5nKTtcbiAgICAgICAgaWYgKGFuY2hvckFic1BvcyAhPT0gbnVsbCAmJiBmb2N1c0Fic1BvcyAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IFthbmNob3JDb2xsYWJOb2RlLCBhbmNob3JPZmZzZXRdID0gZ2V0Q29sbGFiTm9kZUFuZE9mZnNldChhbmNob3JBYnNQb3MudHlwZSwgYW5jaG9yQWJzUG9zLmluZGV4KTtcbiAgICAgICAgICBjb25zdCBbZm9jdXNDb2xsYWJOb2RlLCBmb2N1c09mZnNldF0gPSBnZXRDb2xsYWJOb2RlQW5kT2Zmc2V0KGZvY3VzQWJzUG9zLnR5cGUsIGZvY3VzQWJzUG9zLmluZGV4KTtcbiAgICAgICAgICBpZiAoYW5jaG9yQ29sbGFiTm9kZSAhPT0gbnVsbCAmJiBmb2N1c0NvbGxhYk5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvcktleSA9IGFuY2hvckNvbGxhYk5vZGUuZ2V0S2V5KCk7XG4gICAgICAgICAgICBjb25zdCBmb2N1c0tleSA9IGZvY3VzQ29sbGFiTm9kZS5nZXRLZXkoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IGN1cnNvci5zZWxlY3Rpb247XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbiA9IGNyZWF0ZUN1cnNvclNlbGVjdGlvbihjdXJzb3IsIGFuY2hvcktleSwgYW5jaG9yT2Zmc2V0LCBmb2N1c0tleSwgZm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgICAgICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgICAgICAgICAgIGFuY2hvci5rZXkgPSBhbmNob3JLZXk7XG4gICAgICAgICAgICAgIGFuY2hvci5vZmZzZXQgPSBhbmNob3JPZmZzZXQ7XG4gICAgICAgICAgICAgIGZvY3VzLmtleSA9IGZvY3VzS2V5O1xuICAgICAgICAgICAgICBmb2N1cy5vZmZzZXQgPSBmb2N1c09mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHVwZGF0ZUN1cnNvcihiaW5kaW5nLCBjdXJzb3IsIHNlbGVjdGlvbiwgbm9kZU1hcCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGFsbENsaWVudElEcyA9IEFycmF5LmZyb20oY3Vyc29ycy5rZXlzKCkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbENsaWVudElEcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gYWxsQ2xpZW50SURzW2ldO1xuICAgIGlmICghdmlzaXRlZENsaWVudElEcy5oYXMoY2xpZW50SUQpKSB7XG4gICAgICBjb25zdCBjdXJzb3IgPSBjdXJzb3JzLmdldChjbGllbnRJRCk7XG4gICAgICBpZiAoY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVzdHJveUN1cnNvcihiaW5kaW5nLCBjdXJzb3IpO1xuICAgICAgICBjdXJzb3JzLmRlbGV0ZShjbGllbnRJRCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzeW5jTGV4aWNhbFNlbGVjdGlvblRvWWpzKGJpbmRpbmcsIHByb3ZpZGVyLCBwcmV2U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKSB7XG4gIGNvbnN0IGF3YXJlbmVzcyA9IHByb3ZpZGVyLmF3YXJlbmVzcztcbiAgY29uc3QgbG9jYWxTdGF0ZSA9IGF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCk7XG4gIGlmIChsb2NhbFN0YXRlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtcbiAgICBhbmNob3JQb3M6IGN1cnJlbnRBbmNob3JQb3MsXG4gICAgZm9jdXNQb3M6IGN1cnJlbnRGb2N1c1BvcyxcbiAgICBuYW1lLFxuICAgIGNvbG9yLFxuICAgIGZvY3VzaW5nLFxuICAgIGF3YXJlbmVzc0RhdGFcbiAgfSA9IGxvY2FsU3RhdGU7XG4gIGxldCBhbmNob3JQb3MgPSBudWxsO1xuICBsZXQgZm9jdXNQb3MgPSBudWxsO1xuICBpZiAobmV4dFNlbGVjdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50QW5jaG9yUG9zICE9PSBudWxsICYmICFuZXh0U2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pKSB7XG4gICAgaWYgKHByZXZTZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKG5leHRTZWxlY3Rpb24pKSB7XG4gICAgYW5jaG9yUG9zID0gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbihuZXh0U2VsZWN0aW9uLmFuY2hvciwgYmluZGluZyk7XG4gICAgZm9jdXNQb3MgPSBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uKG5leHRTZWxlY3Rpb24uZm9jdXMsIGJpbmRpbmcpO1xuICB9XG4gIGlmIChzaG91bGRVcGRhdGVQb3NpdGlvbihjdXJyZW50QW5jaG9yUG9zLCBhbmNob3JQb3MpIHx8IHNob3VsZFVwZGF0ZVBvc2l0aW9uKGN1cnJlbnRGb2N1c1BvcywgZm9jdXNQb3MpKSB7XG4gICAgYXdhcmVuZXNzLnNldExvY2FsU3RhdGUoe1xuICAgICAgYW5jaG9yUG9zLFxuICAgICAgYXdhcmVuZXNzRGF0YSxcbiAgICAgIGNvbG9yLFxuICAgICAgZm9jdXNQb3MsXG4gICAgICBmb2N1c2luZyxcbiAgICAgIG5hbWVcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uICRzeW5jRXZlbnQoYmluZGluZywgZXZlbnQpIHtcbiAgY29uc3Qge1xuICAgIHRhcmdldFxuICB9ID0gZXZlbnQ7XG4gIGNvbnN0IGNvbGxhYk5vZGUgPSAkZ2V0T3JJbml0Q29sbGFiTm9kZUZyb21TaGFyZWRUeXBlKGJpbmRpbmcsIHRhcmdldCk7XG4gIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiRWxlbWVudE5vZGUgJiYgZXZlbnQgaW5zdGFuY2VvZiBZVGV4dEV2ZW50KSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBXZSBuZWVkIHRvIGFjY2VzcyB0aGUgcHJpdmF0ZSBwcm9wZXJ0eSBvZiB0aGUgY2xhc3NcbiAgICBjb25zdCB7XG4gICAgICBrZXlzQ2hhbmdlZCxcbiAgICAgIGNoaWxkTGlzdENoYW5nZWQsXG4gICAgICBkZWx0YVxuICAgIH0gPSBldmVudDtcblxuICAgIC8vIFVwZGF0ZVxuICAgIGlmIChrZXlzQ2hhbmdlZC5zaXplID4gMCkge1xuICAgICAgY29sbGFiTm9kZS5zeW5jUHJvcGVydGllc0Zyb21ZanMoYmluZGluZywga2V5c0NoYW5nZWQpO1xuICAgIH1cbiAgICBpZiAoY2hpbGRMaXN0Q2hhbmdlZCkge1xuICAgICAgY29sbGFiTm9kZS5hcHBseUNoaWxkcmVuWWpzRGVsdGEoYmluZGluZywgZGVsdGEpO1xuICAgICAgY29sbGFiTm9kZS5zeW5jQ2hpbGRyZW5Gcm9tWWpzKGJpbmRpbmcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiVGV4dE5vZGUgJiYgZXZlbnQgaW5zdGFuY2VvZiBZTWFwRXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBrZXlzQ2hhbmdlZFxuICAgIH0gPSBldmVudDtcblxuICAgIC8vIFVwZGF0ZVxuICAgIGlmIChrZXlzQ2hhbmdlZC5zaXplID4gMCkge1xuICAgICAgY29sbGFiTm9kZS5zeW5jUHJvcGVydGllc0FuZFRleHRGcm9tWWpzKGJpbmRpbmcsIGtleXNDaGFuZ2VkKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYkRlY29yYXRvck5vZGUgJiYgZXZlbnQgaW5zdGFuY2VvZiBZWG1sRXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBhdHRyaWJ1dGVzQ2hhbmdlZFxuICAgIH0gPSBldmVudDtcblxuICAgIC8vIFVwZGF0ZVxuICAgIGlmIChhdHRyaWJ1dGVzQ2hhbmdlZC5zaXplID4gMCkge1xuICAgICAgY29sbGFiTm9kZS5zeW5jUHJvcGVydGllc0Zyb21ZanMoYmluZGluZywgYXR0cmlidXRlc0NoYW5nZWQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdGV4dCwgZWxlbWVudCwgb3IgZGVjb3JhdG9yIGV2ZW50YCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzeW5jWWpzQ2hhbmdlc1RvTGV4aWNhbChiaW5kaW5nLCBwcm92aWRlciwgZXZlbnRzLCBpc0Zyb21VbmRvTWFuZ2VyKSB7XG4gIGNvbnN0IGVkaXRvciA9IGJpbmRpbmcuZWRpdG9yO1xuICBjb25zdCBjdXJyZW50RWRpdG9yU3RhdGUgPSBlZGl0b3IuX2VkaXRvclN0YXRlO1xuXG4gIC8vIFRoaXMgbGluZSBwcmVjb21wdXRlIHRoZSBkZWx0YSBiZWZvcmUgZWRpdG9yIHVwZGF0ZS4gVGhlIHJlYXNvbiBpc1xuICAvLyBkZWx0YSBpcyBjb21wdXRlZCB3aGVuIGl0IGlzIGFjY2Vzc2VkLiBOb3RlIHRoYXQgdGhpcyBjYW4gb25seSBiZVxuICAvLyBzYWZlbHkgY29tcHV0ZWQgZHVyaW5nIHRoZSBldmVudCBjYWxsLiBJZiBpdCBpcyBhY2Nlc3NlZCBhZnRlciBldmVudFxuICAvLyBjYWxsIGl0IG1pZ2h0IHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW9yLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20veWpzL3lqcy9ibG9iLzAwZWY0NzJkNjg1NDVjYjI2MGFiZDM1YzJkZTRiM2I3ODcxOWM5ZTQvc3JjL3V0aWxzL1lFdmVudC5qcyNMMTMyXG4gIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IGV2ZW50LmRlbHRhKTtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW2ldO1xuICAgICAgJHN5bmNFdmVudChiaW5kaW5nLCBldmVudCk7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIHdhcyBhIGNvbGxpc2lvbiBvbiB0aGUgdG9wIGxldmVsIHBhcmFncmFwaFxuICAgIC8vIHdlIG5lZWQgdG8gcmUtYWRkIGEgcGFyYWdyYXBoXG4gICAgaWYgKCRnZXRSb290KCkuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgICRnZXRSb290KCkuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGlmIChkb2VzU2VsZWN0aW9uTmVlZFJlY292ZXJpbmcoc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gY3VycmVudEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSkge1xuICAgICAgICAgICRzeW5jTG9jYWxDdXJzb3JQb3NpdGlvbihiaW5kaW5nLCBwcm92aWRlcik7XG4gICAgICAgICAgaWYgKGRvZXNTZWxlY3Rpb25OZWVkUmVjb3ZlcmluZyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VsZWN0ZWQgbm9kZSBpcyBkZWxldGVkLCBtb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHByZXZpb3VzIG9yIHBhcmVudCBub2RlLlxuICAgICAgICAgICAgY29uc3QgYW5jaG9yTm9kZUtleSA9IHNlbGVjdGlvbi5hbmNob3Iua2V5O1xuICAgICAgICAgICAgJG1vdmVTZWxlY3Rpb25Ub1ByZXZpb3VzTm9kZShhbmNob3JOb2RlS2V5LCBjdXJyZW50RWRpdG9yU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzeW5jTGV4aWNhbFNlbGVjdGlvblRvWWpzKGJpbmRpbmcsIHByb3ZpZGVyLCBwcmV2U2VsZWN0aW9uLCAkZ2V0U2VsZWN0aW9uKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHN5bmNMb2NhbEN1cnNvclBvc2l0aW9uKGJpbmRpbmcsIHByb3ZpZGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBvblVwZGF0ZTogKCkgPT4ge1xuICAgICAgc3luY0N1cnNvclBvc2l0aW9ucyhiaW5kaW5nLCBwcm92aWRlcik7XG4gICAgfSxcbiAgICBza2lwVHJhbnNmb3JtczogdHJ1ZSxcbiAgICB0YWc6IGlzRnJvbVVuZG9NYW5nZXIgPyAnaGlzdG9yaWMnIDogJ2NvbGxhYm9yYXRpb24nXG4gIH0pO1xufVxuZnVuY3Rpb24gJGhhbmRsZU5vcm1hbGl6YXRpb25NZXJnZUNvbmZsaWN0cyhiaW5kaW5nLCBub3JtYWxpemVkTm9kZXMpIHtcbiAgLy8gV2UgaGFuZGxlIHRoZSBtZXJnZSBvcGVyYXRpb25zIGhlcmVcbiAgY29uc3Qgbm9ybWFsaXplZE5vZGVzS2V5cyA9IEFycmF5LmZyb20obm9ybWFsaXplZE5vZGVzKTtcbiAgY29uc3QgY29sbGFiTm9kZU1hcCA9IGJpbmRpbmcuY29sbGFiTm9kZU1hcDtcbiAgY29uc3QgbWVyZ2VkTm9kZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub3JtYWxpemVkTm9kZXNLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZUtleSA9IG5vcm1hbGl6ZWROb2Rlc0tleXNbaV07XG4gICAgY29uc3QgbGV4aWNhbE5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KG5vZGVLZXkpO1xuICAgIGNvbnN0IGNvbGxhYk5vZGUgPSBjb2xsYWJOb2RlTWFwLmdldChub2RlS2V5KTtcbiAgICBpZiAoY29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYlRleHROb2RlKSB7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUobGV4aWNhbE5vZGUpKSB7XG4gICAgICAgIC8vIFdlIG11dGF0ZSB0aGUgdGV4dCBjb2xsYWIgbm9kZXMgYWZ0ZXIgcmVtb3ZpbmdcbiAgICAgICAgLy8gYWxsIHRoZSBkZWFkIG5vZGVzIGZpcnN0LCBvdGhlcndpc2Ugb2Zmc2V0cyBicmVhay5cbiAgICAgICAgbWVyZ2VkTm9kZXMucHVzaChbY29sbGFiTm9kZSwgbGV4aWNhbE5vZGUuX190ZXh0XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBjb2xsYWJOb2RlLmdldE9mZnNldCgpO1xuICAgICAgICBpZiAob2Zmc2V0ID09PSAtMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGNvbGxhYk5vZGUuX3BhcmVudDtcbiAgICAgICAgY29sbGFiTm9kZS5fbm9ybWFsaXplZCA9IHRydWU7XG4gICAgICAgIHBhcmVudC5feG1sVGV4dC5kZWxldGUob2Zmc2V0LCAxKTtcbiAgICAgICAgY29sbGFiTm9kZU1hcC5kZWxldGUobm9kZUtleSk7XG4gICAgICAgIGNvbnN0IHBhcmVudENoaWxkcmVuID0gcGFyZW50Ll9jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnRDaGlsZHJlbi5pbmRleE9mKGNvbGxhYk5vZGUpO1xuICAgICAgICBwYXJlbnRDaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lcmdlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgW2NvbGxhYk5vZGUsIHRleHRdID0gbWVyZ2VkTm9kZXNbaV07XG4gICAgaWYgKGNvbGxhYk5vZGUgaW5zdGFuY2VvZiBDb2xsYWJUZXh0Tm9kZSAmJiB0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbGxhYk5vZGUuX3RleHQgPSB0ZXh0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3luY0xleGljYWxVcGRhdGVUb1lqcyhiaW5kaW5nLCBwcm92aWRlciwgcHJldkVkaXRvclN0YXRlLCBjdXJyRWRpdG9yU3RhdGUsIGRpcnR5RWxlbWVudHMsIGRpcnR5TGVhdmVzLCBub3JtYWxpemVkTm9kZXMsIHRhZ3MpIHtcbiAgc3luY1dpdGhUcmFuc2FjdGlvbihiaW5kaW5nLCAoKSA9PiB7XG4gICAgY3VyckVkaXRvclN0YXRlLnJlYWQoKCkgPT4ge1xuICAgICAgLy8gV2UgY2hlY2sgaWYgdGhlIHVwZGF0ZSBoYXMgY29tZSBmcm9tIGEgb3JpZ2luIHdoZXJlIHRoZSBvcmlnaW5cbiAgICAgIC8vIHdhcyB0aGUgY29sbGFib3JhdGlvbiBiaW5kaW5nIHByZXZpb3VzbHkuIFRoaXMgY2FuIGhlbHAgdXNcbiAgICAgIC8vIHByZXZlbnQgdW5uZWNlc3NhcmlseSByZS1kaWZmaW5nIGFuZCBwb3NzaWJsZSByZS1hcHBseWluZ1xuICAgICAgLy8gdGhlIHNhbWUgY2hhbmdlIGVkaXRvciBzdGF0ZSBhZ2Fpbi4gRm9yIGV4YW1wbGUsIGlmIGEgdXNlclxuICAgICAgLy8gdHlwZXMgYSBjaGFyYWN0ZXIgYW5kIHdlIGdldCBpdCwgd2UgZG9uJ3Qgd2FudCB0byB0aGVuIGluc2VydFxuICAgICAgLy8gdGhlIHNhbWUgY2hhcmFjdGVyIGFnYWluLiBUaGUgZXhjZXB0aW9uIHRvIHRoaXMgaGV1cmlzdGljIGlzXG4gICAgICAvLyB3aGVuIHdlIG5lZWQgdG8gaGFuZGxlIG5vcm1hbGl6YXRpb24gbWVyZ2UgY29uZmxpY3RzLlxuICAgICAgaWYgKHRhZ3MuaGFzKCdjb2xsYWJvcmF0aW9uJykgfHwgdGFncy5oYXMoJ2hpc3RvcmljJykpIHtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWROb2Rlcy5zaXplID4gMCkge1xuICAgICAgICAgICRoYW5kbGVOb3JtYWxpemF0aW9uTWVyZ2VDb25mbGljdHMoYmluZGluZywgbm9ybWFsaXplZE5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGlydHlFbGVtZW50cy5oYXMoJ3Jvb3QnKSkge1xuICAgICAgICBjb25zdCBwcmV2Tm9kZU1hcCA9IHByZXZFZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgICAgICAgY29uc3QgbmV4dExleGljYWxSb290ID0gJGdldFJvb3QoKTtcbiAgICAgICAgY29uc3QgY29sbGFiUm9vdCA9IGJpbmRpbmcucm9vdDtcbiAgICAgICAgY29sbGFiUm9vdC5zeW5jUHJvcGVydGllc0Zyb21MZXhpY2FsKGJpbmRpbmcsIG5leHRMZXhpY2FsUm9vdCwgcHJldk5vZGVNYXApO1xuICAgICAgICBjb2xsYWJSb290LnN5bmNDaGlsZHJlbkZyb21MZXhpY2FsKGJpbmRpbmcsIG5leHRMZXhpY2FsUm9vdCwgcHJldk5vZGVNYXAsIGRpcnR5RWxlbWVudHMsIGRpcnR5TGVhdmVzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBwcmV2RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgICAgIHN5bmNMZXhpY2FsU2VsZWN0aW9uVG9ZanMoYmluZGluZywgcHJvdmlkZXIsIHByZXZTZWxlY3Rpb24sIHNlbGVjdGlvbik7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENPTk5FQ1RFRF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ09OTkVDVEVEX0NPTU1BTkQnKTtcbmNvbnN0IFRPR0dMRV9DT05ORUNUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdUT0dHTEVfQ09OTkVDVF9DT01NQU5EJyk7XG5mdW5jdGlvbiBjcmVhdGVVbmRvTWFuYWdlcihiaW5kaW5nLCByb290KSB7XG4gIHJldHVybiBuZXcgVW5kb01hbmFnZXIocm9vdCwge1xuICAgIHRyYWNrZWRPcmlnaW5zOiBuZXcgU2V0KFtiaW5kaW5nLCBudWxsXSlcbiAgfSk7XG59XG5mdW5jdGlvbiBpbml0TG9jYWxTdGF0ZShwcm92aWRlciwgbmFtZSwgY29sb3IsIGZvY3VzaW5nLCBhd2FyZW5lc3NEYXRhKSB7XG4gIHByb3ZpZGVyLmF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlKHtcbiAgICBhbmNob3JQb3M6IG51bGwsXG4gICAgYXdhcmVuZXNzRGF0YSxcbiAgICBjb2xvcixcbiAgICBmb2N1c1BvczogbnVsbCxcbiAgICBmb2N1c2luZzogZm9jdXNpbmcsXG4gICAgbmFtZVxuICB9KTtcbn1cbmZ1bmN0aW9uIHNldExvY2FsU3RhdGVGb2N1cyhwcm92aWRlciwgbmFtZSwgY29sb3IsIGZvY3VzaW5nLCBhd2FyZW5lc3NEYXRhKSB7XG4gIGNvbnN0IHtcbiAgICBhd2FyZW5lc3NcbiAgfSA9IHByb3ZpZGVyO1xuICBsZXQgbG9jYWxTdGF0ZSA9IGF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCk7XG4gIGlmIChsb2NhbFN0YXRlID09PSBudWxsKSB7XG4gICAgbG9jYWxTdGF0ZSA9IHtcbiAgICAgIGFuY2hvclBvczogbnVsbCxcbiAgICAgIGF3YXJlbmVzc0RhdGEsXG4gICAgICBjb2xvcixcbiAgICAgIGZvY3VzUG9zOiBudWxsLFxuICAgICAgZm9jdXNpbmc6IGZvY3VzaW5nLFxuICAgICAgbmFtZVxuICAgIH07XG4gIH1cbiAgbG9jYWxTdGF0ZS5mb2N1c2luZyA9IGZvY3VzaW5nO1xuICBhd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZShsb2NhbFN0YXRlKTtcbn1cblxuZXhwb3J0IHsgQ09OTkVDVEVEX0NPTU1BTkQsIFRPR0dMRV9DT05ORUNUX0NPTU1BTkQsIGNyZWF0ZUJpbmRpbmcsIGNyZWF0ZVVuZG9NYW5hZ2VyLCBpbml0TG9jYWxTdGF0ZSwgc2V0TG9jYWxTdGF0ZUZvY3VzLCBzeW5jQ3Vyc29yUG9zaXRpb25zLCBzeW5jTGV4aWNhbFVwZGF0ZVRvWWpzLCBzeW5jWWpzQ2hhbmdlc1RvTGV4aWNhbCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/yjs/LexicalYjs.dev.mjs\n");

/***/ })

};
;