import { useFloating, autoUpdate } from '@floating-ui/react-dom';
import { CollaborationContext } from '@lexical/react/LexicalCollaborationContext';
import { CollaborationPlugin } from '@lexical/react/LexicalCollaborationPlugin';
import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';
import { kInternal, nn } from '@liveblocks/core';
import { useRoom, useClient, useSelf } from '@liveblocks/react';
import { LiveblocksYjsProvider } from '@liveblocks/yjs';
import React__default, { useState, useEffect, useContext, useRef, useCallback, useLayoutEffect } from 'react';
import { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';
import { Doc } from 'yjs';
import { CommentPluginProvider } from './comments/comment-plugin-provider.mjs';
import { ThreadMarkNode } from './comments/thread-mark-node.mjs';
import { MentionNode } from './mentions/mention-node.mjs';
import { MentionPlugin } from './mentions/mention-plugin.mjs';

const providersMap = /* @__PURE__ */ new Map();
function getEditorStatus(provider) {
  if (provider === void 0) {
    return "not-loaded";
  }
  return provider.synced ? "synchronized" : "loading";
}
function useEditorStatus() {
  const room = useRoom();
  const provider = providersMap.get(room.id);
  const [status, setStatus] = useState(getEditorStatus(provider));
  useEffect(() => {
    const provider2 = providersMap.get(room.id);
    setStatus(getEditorStatus(provider2));
    if (provider2 === void 0) {
      return;
    }
    const cb = () => setStatus(getEditorStatus(provider2));
    provider2.on("sync", cb);
    return () => provider2.off("sync", cb);
  }, [room]);
  return status;
}
const LiveblocksPlugin = ({
  children
}) => {
  const client = useClient();
  const hasResolveMentionSuggestions = client[kInternal].resolveMentionSuggestions !== void 0;
  const [editor] = useLexicalComposerContext();
  const room = useRoom();
  const collabContext = useContext(CollaborationContext);
  const previousRoomIdRef = useRef(null);
  if (!editor.hasNodes([ThreadMarkNode, MentionNode])) {
    throw new Error(
      "LiveblocksPlugin requires Lexical configuration to be wrapped in the `liveblocksConfig(options)` function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-react-lexical#liveblocksConfig"
    );
  }
  const [containerRef, setContainerRef] = useState(void 0);
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = useFloating({
    strategy: "fixed",
    placement: "bottom",
    whileElementsMounted: (...args) => {
      return autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  useEffect(() => {
    if (process.env.NODE_ENV !== "production") {
      if (!editor.getEditorState().isEmpty()) {
        console.warn(
          "Warning: LiveblocksPlugin: editorState in initialConfig detected, but must be null."
        );
      }
    }
  }, []);
  useEffect(() => {
    room[kInternal].reportTextEditor("lexical", "root");
  }, [room]);
  const info = useSelf((me) => me.info);
  const username = info?.name || "";
  const cursorcolor = info?.color;
  const providerFactory = useCallback(
    (id, yjsDocMap) => {
      if (previousRoomIdRef.current !== null && previousRoomIdRef.current !== id) {
        const previousProvider = providersMap.get(id);
        if (previousProvider !== void 0) {
          previousProvider.destroy();
        }
      }
      let doc = yjsDocMap.get(id);
      if (doc === void 0) {
        doc = new Doc();
        const provider = new LiveblocksYjsProvider(room, doc);
        yjsDocMap.set(id, doc);
        providersMap.set(id, provider);
      }
      return nn(
        providersMap.get(id),
        "Internal error. Should never happen"
      );
    },
    [room]
  );
  useEffect(() => {
    collabContext.name = username || "";
  }, [collabContext, username]);
  const root = useRootElement();
  useLayoutEffect(() => {
    if (root === null)
      return;
    setReference({
      getBoundingClientRect: () => root.getBoundingClientRect()
    });
  }, [setReference, root]);
  const handleFloatingRef = useCallback(
    (node) => {
      setFloating(node);
      setContainerRef({ current: node });
    },
    [setFloating, setContainerRef]
  );
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("div", {
    ref: handleFloatingRef,
    style: {
      position: strategy,
      top: 0,
      left: 0,
      transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
      minWidth: "max-content"
    }
  }), /* @__PURE__ */ React__default.createElement(CollaborationPlugin, {
    key: room.id,
    id: room.id,
    providerFactory,
    username,
    cursorColor: cursorcolor,
    cursorsContainerRef: containerRef,
    shouldBootstrap: true
  }), hasResolveMentionSuggestions && /* @__PURE__ */ React__default.createElement(MentionPlugin, null), /* @__PURE__ */ React__default.createElement(CommentPluginProvider, null, children));
};
function useRootElement() {
  const [editor] = useLexicalComposerContext();
  const subscribe = useCallback(
    (onStoreChange) => {
      return editor.registerRootListener(onStoreChange);
    },
    [editor]
  );
  const getSnapshot = useCallback(() => {
    return editor.getRootElement();
  }, [editor]);
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}

export { LiveblocksPlugin, useEditorStatus, useRootElement };
//# sourceMappingURL=liveblocks-plugin-provider.mjs.map
