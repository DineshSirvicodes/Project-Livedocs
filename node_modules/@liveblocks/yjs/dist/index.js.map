{"version":3,"sources":["../src/index.ts","../../../node_modules/lib0/map.js","../../../node_modules/lib0/set.js","../../../node_modules/lib0/array.js","../../../node_modules/lib0/observable.js","../src/awareness.ts","../src/doc.ts","../src/version.ts"],"names":["create"],"mappings":"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","sourcesContent":["import type {\n  BaseUserMeta,\n  Json,\n  JsonObject,\n  LsonObject,\n  Room,\n} from \"@liveblocks/client\";\nimport type { BaseMetadata, DE, DM, DP, DS, DU } from \"@liveblocks/core\";\nimport { ClientMsgCode, detectDupes } from \"@liveblocks/core\";\nimport { Observable } from \"lib0/observable\";\nimport type * as Y from \"yjs\";\n\nimport { Awareness } from \"./awareness\";\nimport yDocHandler from \"./doc\";\nimport { PKG_FORMAT, PKG_NAME, PKG_VERSION } from \"./version\";\n\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\ntype ProviderOptions = {\n  autoloadSubdocs?: boolean;\n};\n\nexport class LiveblocksYjsProvider<\n  P extends JsonObject = DP,\n  S extends LsonObject = DS,\n  U extends BaseUserMeta = DU,\n  E extends Json = DE,\n  M extends BaseMetadata = DM,\n> extends Observable<unknown> {\n  private room: Room<P, S, U, E, M>;\n  private rootDoc: Y.Doc;\n  private options: ProviderOptions;\n\n  private unsubscribers: Array<() => void> = [];\n\n  public awareness: Awareness<P, S, U, E, M>;\n\n  public rootDocHandler: yDocHandler;\n  public subdocHandlers: Map<string, yDocHandler> = new Map();\n\n  constructor(\n    room: Room<P, S, U, E, M>,\n    doc: Y.Doc,\n    options: ProviderOptions | undefined = {}\n  ) {\n    super();\n    this.rootDoc = doc;\n    this.room = room;\n    this.options = options;\n    this.rootDocHandler = new yDocHandler({\n      doc,\n      isRoot: true,\n      updateDoc: this.updateDoc,\n      fetchDoc: this.fetchDoc,\n    });\n    // if we have a connectionId already during construction, use that\n    this.awareness = new Awareness(this.rootDoc, this.room);\n\n    this.unsubscribers.push(\n      this.room.events.status.subscribe((status) => {\n        if (status === \"connected\") {\n          this.rootDocHandler.syncDoc();\n        } else {\n          this.rootDocHandler.synced = false;\n        }\n      })\n    );\n\n    this.unsubscribers.push(\n      this.room.events.ydoc.subscribe((message) => {\n        const { type } = message;\n        if (type === ClientMsgCode.UPDATE_YDOC) {\n          // don't apply updates that came from the client\n          return;\n        }\n        const { stateVector, update, guid } = message;\n        const canWrite = this.room.getSelf()?.canWrite ?? true;\n        // find the right doc and update\n        if (guid !== undefined) {\n          this.subdocHandlers.get(guid)?.handleServerUpdate({\n            update,\n            stateVector,\n            readOnly: !canWrite,\n          });\n        } else {\n          this.rootDocHandler.handleServerUpdate({\n            update,\n            stateVector,\n            readOnly: !canWrite,\n          });\n        }\n      })\n    );\n\n    this.rootDocHandler.on(\"synced\", () => {\n      const state = this.rootDocHandler.synced;\n      for (const [_, handler] of this.subdocHandlers) {\n        handler.syncDoc();\n      }\n      this.emit(\"synced\", [state]);\n      this.emit(\"sync\", [state]);\n    });\n    this.rootDoc.on(\"subdocs\", this.handleSubdocs);\n    this.syncDoc();\n  }\n\n  private handleSubdocs = ({\n    loaded,\n    removed,\n    added,\n  }: {\n    loaded: Set<Y.Doc>;\n    removed: Set<Y.Doc>;\n    added: Set<Y.Doc>;\n  }) => {\n    loaded.forEach(this.createSubdocHandler);\n    if (this.options.autoloadSubdocs) {\n      for (const subdoc of added) {\n        if (!this.subdocHandlers.has(subdoc.guid)) {\n          subdoc.load();\n        }\n      }\n    }\n    for (const subdoc of removed) {\n      if (this.subdocHandlers.has(subdoc.guid)) {\n        this.subdocHandlers.get(subdoc.guid)?.destroy();\n        this.subdocHandlers.delete(subdoc.guid);\n      }\n    }\n  };\n\n  private updateDoc = (update: string, guid?: string) => {\n    const canWrite = this.room.getSelf()?.canWrite ?? true;\n    if (canWrite) {\n      this.room.updateYDoc(update, guid);\n    }\n  };\n\n  private fetchDoc = (vector: string, guid?: string) => {\n    this.room.fetchYDoc(vector, guid);\n  };\n\n  private createSubdocHandler = (subdoc: Y.Doc): void => {\n    if (this.subdocHandlers.has(subdoc.guid)) {\n      // if we already handle this subdoc, just fetch it again\n      this.subdocHandlers.get(subdoc.guid)?.syncDoc();\n      return;\n    }\n    const handler = new yDocHandler({\n      doc: subdoc,\n      isRoot: false,\n      updateDoc: this.updateDoc,\n      fetchDoc: this.fetchDoc,\n    });\n    this.subdocHandlers.set(subdoc.guid, handler);\n  };\n\n  // attempt to load a subdoc of a given guid\n  public loadSubdoc = (guid: string): boolean => {\n    for (const subdoc of this.rootDoc.subdocs) {\n      if (subdoc.guid === guid) {\n        subdoc.load();\n        return true;\n      }\n    }\n    // should we throw instead?\n    return false;\n  };\n\n  private syncDoc = () => {\n    this.rootDocHandler.syncDoc();\n    for (const [_, handler] of this.subdocHandlers) {\n      handler.syncDoc();\n    }\n  };\n\n  // The sync'd property is required by some provider implementations\n  get synced(): boolean {\n    return this.rootDocHandler.synced;\n  }\n\n  destroy(): void {\n    this.unsubscribers.forEach((unsub) => unsub());\n    this.awareness.destroy();\n    this.rootDocHandler.destroy();\n    this._observers = new Map();\n    for (const [_, handler] of this.subdocHandlers) {\n      handler.destroy();\n    }\n    this.subdocHandlers.clear();\n    super.destroy();\n  }\n\n  // Some provider implementations expect to be able to call connect/disconnect, implement as noop\n  disconnect(): void {\n    // This is a noop for liveblocks as connections are managed by the room\n  }\n\n  connect(): void {\n    // This is a noop for liveblocks as connections are managed by the room\n  }\n}\n","/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nexport const create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template K,V\n * @param {Map<K,V>} m\n * @return {Map<K,V>}\n */\nexport const copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template {Map<any, any>} MAP\n * @template {MAP extends Map<any,infer V> ? function():V : unknown} CF\n * @param {MAP} map\n * @param {MAP extends Map<infer K,any> ? K : unknown} key\n * @param {CF} createT\n * @return {ReturnType<CF>}\n */\nexport const setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nexport const map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n","/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nexport const create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nexport const toArray = set => Array.from(set)\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {T}\n */\nexport const first = set =>\n  set.values().next().value || undefined\n\n/**\n * @template T\n * @param {Iterable<T>} entries\n * @return {Set<T>}\n */\nexport const from = entries => new Set(entries)\n","/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\nimport * as set from './set.js'\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {ArrayLike<L>} arr\n * @return {L}\n */\nexport const last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nexport const create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nexport const copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nexport const appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nexport const from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n * @template {ArrayLike<ITEM>} ARR\n *\n * @param {ARR} arr\n * @param {function(ITEM, number, ARR):boolean} f\n * @return {boolean}\n */\nexport const every = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (!f(arr[i], i, arr)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @template {ArrayLike<S>} ARR\n * @param {ARR} arr\n * @param {function(S, number, ARR):boolean} f\n * @return {boolean}\n */\nexport const some = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (f(arr[i], i, arr)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @template ELEM\n *\n * @param {ArrayLike<ELEM>} a\n * @param {ArrayLike<ELEM>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nexport const flatten = arr => fold(arr, /** @type {Array<ELEM>} */ ([]), (acc, val) => acc.concat(val))\n\n/**\n * @template T\n * @param {number} len\n * @param {function(number, Array<T>):T} f\n * @return {Array<T>}\n */\nexport const unfold = (len, f) => {\n  const array = new Array(len)\n  for (let i = 0; i < len; i++) {\n    array[i] = f(i, array)\n  }\n  return array\n}\n\n/**\n * @template T\n * @template RESULT\n * @param {Array<T>} arr\n * @param {RESULT} seed\n * @param {function(RESULT, T, number):RESULT} folder\n */\nexport const fold = (arr, seed, folder) => arr.reduce(folder, seed)\n\nexport const isArray = Array.isArray\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {Array<T>}\n */\nexport const unique = arr => from(set.from(arr))\n\n/**\n * @template T\n * @template M\n * @param {ArrayLike<T>} arr\n * @param {function(T):M} mapper\n * @return {Array<T>}\n */\nexport const uniqueBy = (arr, mapper) => {\n  /**\n   * @type {Set<M>}\n   */\n  const happened = set.create()\n  /**\n   * @type {Array<T>}\n   */\n  const result = []\n  for (let i = 0; i < arr.length; i++) {\n    const el = arr[i]\n    const mapped = mapper(el)\n    if (!happened.has(mapped)) {\n      happened.add(mapped)\n      result.push(el)\n    }\n  }\n  return result\n}\n\n/**\n * @template {ArrayLike<any>} ARR\n * @template {function(ARR extends ArrayLike<infer T> ? T : never, number, ARR):any} MAPPER\n * @param {ARR} arr\n * @param {MAPPER} mapper\n * @return {Array<MAPPER extends function(...any): infer M ? M : never>}\n */\nexport const map = (arr, mapper) => {\n  /**\n   * @type {Array<any>}\n   */\n  const res = Array(arr.length)\n  for (let i = 0; i < arr.length; i++) {\n    res[i] = mapper(/** @type {any} */ (arr[i]), i, /** @type {any} */ (arr))\n  }\n  return /** @type {any} */ (res)\n}\n","/**\n * Observable class prototype.\n *\n * @module observable\n */\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as array from './array.js'\n\n/**\n * Handles named events.\n * @experimental\n *\n * This is basically a (better typed) duplicate of Observable, which will replace Observable in the\n * next release.\n *\n * @template {{[key in keyof EVENTS]: function(...any):void}} EVENTS\n */\nexport class ObservableV2 {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<string, Set<any>>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, /** @type {string} */ (name), set.create).add(f)\n    return f\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, /** @type {any} */ (_f))\n      f(...args)\n    }\n    this.on(name, /** @type {any} */ (_f))\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name The event name.\n   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n\n/* c8 ignore start */\n/**\n * Handles named events.\n *\n * @deprecated\n * @template N\n */\nexport class Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n/* c8 ignore end */\n","// TODO: apparently Yjs is full of anys or something, see if we can fix this\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\nimport type {\n  BaseMetadata,\n  BaseUserMeta,\n  Json,\n  JsonObject,\n  LsonObject,\n  Room,\n  User,\n} from \"@liveblocks/client\";\nimport { Observable } from \"lib0/observable\";\nimport type * as Y from \"yjs\";\n\nconst Y_PRESENCE_KEY = \"__yjs\";\nconst Y_PRESENCE_ID_KEY = \"__yjs_clientid\";\n\ntype MetaClientState = {\n  clock: number;\n  lastUpdated: number;\n};\n\n/**\n * This class will store Yjs awareness in Liveblock's presence under the __yjs key\n * IMPORTANT: The Yjs awareness protocol uses ydoc.clientId to reference users\n * to their respective documents. To avoid mapping Yjs clientIds to liveblock's connectionId,\n * we simply set the clientId of the doc to the connectionId. Then no further mapping is required\n */\nexport class Awareness<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  M extends BaseMetadata,\n> extends Observable<unknown> {\n  private room: Room<P, S, U, E, M>;\n  public doc: Y.Doc;\n  public states: Map<number, unknown> = new Map();\n  // used to map liveblock's ActorId to Yjs ClientID, both unique numbers representing a client\n  public actorToClientMap: Map<number, number> = new Map();\n  // Meta is used to keep track and timeout users who disconnect. Liveblocks provides this for us, so we don't need to\n  // manage it here. Unfortunately, it's expected to exist by various integrations, so it's an empty map.\n  public meta: Map<number, MetaClientState> = new Map();\n  // _checkInterval this would hold a timer to remove users, but Liveblock's presence already handles this\n  // unfortunately it's typed by various integrations\n  public _checkInterval: number = 0;\n\n  private othersUnsub: () => void;\n  constructor(doc: Y.Doc, room: Room<P, S, U, E, M>) {\n    super();\n    this.doc = doc;\n    this.room = room;\n    // Add the clientId to presence so we can map it to connectionId later\n    this.room.updatePresence({\n      [Y_PRESENCE_ID_KEY]: this.doc.clientID,\n    } as unknown as Partial<P>);\n    this.othersUnsub = this.room.events.others.subscribe((event) => {\n      let updates:\n        | { added: number[]; updated: number[]; removed: number[] }\n        | undefined;\n\n      this.rebuildActorToClientMap(event.others);\n      // When others are changed, we emit an event that contains arrays added/updated/removed.\n      if (event.type === \"leave\") {\n        const targetClientId = this.actorToClientMap.get(\n          event.user.connectionId\n        );\n        if (targetClientId !== undefined) {\n          updates = { added: [], updated: [], removed: [targetClientId] };\n        }\n        // rebuild after the user leaves so we can get the ID of the user who left\n        this.rebuildActorToClientMap(event.others);\n      }\n      if (event.type === \"enter\" || event.type === \"update\") {\n        this.rebuildActorToClientMap(event.others);\n        const targetClientId = this.actorToClientMap.get(\n          event.user.connectionId\n        );\n        if (targetClientId !== undefined) {\n          updates = {\n            added: event.type === \"enter\" ? [targetClientId] : [],\n            updated: event.type === \"update\" ? [targetClientId] : [],\n            removed: [],\n          };\n        }\n      }\n      if (updates !== undefined) {\n        this.emit(\"change\", [updates, \"presence\"]);\n        this.emit(\"update\", [updates, \"presence\"]);\n      }\n    });\n  }\n\n  rebuildActorToClientMap(\n    others: readonly User<JsonObject, BaseUserMeta>[]\n  ): void {\n    this.actorToClientMap.clear();\n    others.forEach((user) => {\n      if (user.presence[Y_PRESENCE_ID_KEY] !== undefined) {\n        this.actorToClientMap.set(\n          user.connectionId,\n          user.presence[Y_PRESENCE_ID_KEY] as number\n        );\n      }\n    });\n  }\n\n  destroy(): void {\n    this.emit(\"destroy\", [this]);\n    this.othersUnsub();\n    this.setLocalState(null);\n    super.destroy();\n  }\n\n  getLocalState(): JsonObject | null {\n    const presence = this.room.getPresence();\n    if (\n      Object.keys(presence).length === 0 ||\n      typeof presence[Y_PRESENCE_KEY] === \"undefined\"\n    ) {\n      return null;\n    }\n    return presence[Y_PRESENCE_KEY] as JsonObject | null;\n  }\n\n  setLocalState(state: Partial<JsonObject> | null): void {\n    const presence = this.room.getSelf()?.presence;\n    if (state === null) {\n      if (presence === undefined) {\n        // if presence is already undefined, we don't need to change anything here\n        return;\n      }\n      this.room.updatePresence({ ...presence, [Y_PRESENCE_KEY]: null });\n      this.emit(\"update\", [\n        { added: [], updated: [], removed: [this.doc.clientID] },\n        \"local\",\n      ]);\n      return;\n    }\n    // if presence was undefined, it's added, if not, it's updated\n    const yPresence = presence?.[Y_PRESENCE_KEY];\n    const added = yPresence === undefined ? [this.doc.clientID] : [];\n    const updated = yPresence === undefined ? [] : [this.doc.clientID];\n    this.room.updatePresence({\n      [Y_PRESENCE_KEY]: {\n        ...((yPresence as JsonObject) || {}),\n        ...(state || {}),\n      },\n    } as unknown as Partial<P>);\n    this.emit(\"update\", [{ added, updated, removed: [] }, \"local\"]);\n  }\n\n  setLocalStateField(field: string, value: JsonObject | null): void {\n    const presence = this.room.getSelf()?.presence[Y_PRESENCE_KEY];\n    const update = { [field]: value } as Partial<JsonObject>;\n    this.room.updatePresence({\n      [Y_PRESENCE_KEY]: { ...((presence as JsonObject) || {}), ...update },\n    } as unknown as Partial<P>);\n  }\n\n  // Translate liveblocks presence to yjs awareness\n  getStates(): Map<number, unknown> {\n    const others = this.room.getOthers();\n    const states = others.reduce((acc: Map<number, unknown>, otherUser) => {\n      const otherPresence = otherUser.presence[Y_PRESENCE_KEY];\n      const otherClientId = otherUser.presence[Y_PRESENCE_ID_KEY] as\n        | number\n        | undefined;\n      if (otherPresence !== undefined && otherClientId !== undefined) {\n        // set states of map clientId to yjs presence\n        acc.set(otherClientId, otherPresence || {});\n      }\n      return acc;\n    }, new Map());\n\n    // add this client's yjs presence to states (local client not represented in others)\n    const localPresence = this.room.getSelf()?.presence[Y_PRESENCE_KEY];\n    if (localPresence !== undefined) {\n      states.set(this.doc.clientID, localPresence);\n    }\n    return states;\n  }\n}\n","import { Base64 } from \"js-base64\";\nimport { Observable } from \"lib0/observable\";\nimport * as Y from \"yjs\";\n\nexport default class yDocHandler extends Observable<unknown> {\n  private unsubscribers: Array<() => void> = [];\n\n  private _synced = false;\n  private doc: Y.Doc;\n  private updateRoomDoc: (update: string) => void;\n  private fetchRoomDoc: (vector: string) => void;\n\n  constructor({\n    doc,\n    isRoot,\n    updateDoc,\n    fetchDoc,\n  }: {\n    doc: Y.Doc;\n    isRoot: boolean;\n    updateDoc: (update: string, guid?: string) => void;\n    fetchDoc: (vector: string, guid?: string) => void;\n  }) {\n    super();\n    this.doc = doc;\n    // this.doc.load(); // this just emits a load event, it doesn't actually load anything\n    this.doc.on(\"update\", this.updateHandler);\n    this.updateRoomDoc = (update: string) => {\n      updateDoc(update, isRoot ? undefined : this.doc.guid);\n    };\n    this.fetchRoomDoc = (vector: string) => {\n      fetchDoc(vector, isRoot ? undefined : this.doc.guid);\n    };\n\n    this.syncDoc();\n  }\n\n  public handleServerUpdate = ({\n    update,\n    stateVector,\n    readOnly,\n  }: {\n    update: string;\n    stateVector: string | null;\n    readOnly: boolean;\n  }): void => {\n    // apply update from the server\n    Y.applyUpdate(this.doc, Base64.toUint8Array(update), \"backend\");\n    // if this update is the result of a fetch, the state vector is included\n    if (stateVector) {\n      if (!readOnly) {\n        // Use server state to calculate a diff and send it\n        try {\n          const localUpdate = Y.encodeStateAsUpdate(\n            this.doc,\n            Base64.toUint8Array(stateVector)\n          );\n          this.updateRoomDoc(Base64.fromUint8Array(localUpdate));\n        } catch (e) {\n          // something went wrong encoding local state to send to the server\n          console.warn(e);\n        }\n      }\n      // now that we've sent our local and received from server, we're in sync\n      // calling `syncDoc` again will sync up the documents\n      this.synced = true;\n    }\n  };\n\n  public syncDoc = (): void => {\n    this.synced = false;\n\n    // The state vector is sent to the server so it knows what to send back\n    // if you don't send it, it returns everything\n    const encodedVector = Base64.fromUint8Array(Y.encodeStateVector(this.doc));\n    this.fetchRoomDoc(encodedVector);\n  };\n\n  // The sync'd property is required by some provider implementations\n  get synced(): boolean {\n    return this._synced;\n  }\n\n  set synced(state: boolean) {\n    if (this._synced !== state) {\n      this._synced = state;\n      this.emit(\"synced\", [state]);\n      this.emit(\"sync\", [state]);\n    }\n  }\n\n  private updateHandler = (update: Uint8Array, origin: string) => {\n    if (origin !== \"backend\") {\n      const encodedUpdate = Base64.fromUint8Array(update);\n      this.updateRoomDoc(encodedUpdate);\n    }\n  };\n\n  destroy(): void {\n    this.doc.off(\"update\", this.updateHandler);\n    this.unsubscribers.forEach((unsub) => unsub());\n    this._observers = new Map();\n    this.doc.destroy();\n  }\n}\n","declare const __VERSION__: string;\ndeclare const TSUP_FORMAT: string;\n\nexport const PKG_NAME = \"@liveblocks/yjs\";\nexport const PKG_VERSION = typeof __VERSION__ === \"string\" && __VERSION__;\nexport const PKG_FORMAT = typeof TSUP_FORMAT === \"string\" && TSUP_FORMAT;\n"]}